{"meta":{"title":"LincentMa's Blog","subtitle":null,"description":null,"author":"LicentMa","url":"http://lincentma.men"},"pages":[{"title":"about","date":"2017-06-15T05:55:42.000Z","updated":"2017-06-20T03:17:17.880Z","comments":true,"path":"about/index.html","permalink":"http://lincentma.men/about/index.html","excerpt":"","text":"一名SWJTU的计算机科学与技术专业的致力于后端的程序猿1234567891011121314151617181920&#123; name: '马凌 / lincentma' age: 24, gender: '男', address: '四川省成都市郫都区犀浦镇西南交通大学', education: [ ['本科/西南交通大学'], ['硕士/西南交通大学'] ], Github: 'https://github.com/lingma1993', email: 'mlstd@163.com', skills: [ ['Java','Python', 'PHP', ], ['MySQL','Redis'], ['Hadoop', 'Hive'], ['git'], ['Linux'] ], description: 'stay hungry，stay foolish'&#125; 关于工作致力于：工作高效，简单可依赖致力于：自己成为一专多长的人才 关于生活生活不止眼前的苟且，还有诗和远方的田野，你赤手空拳来到人世间，为找到那片海不顾一切。 关于她为白首不相离而努力"},{"title":"guestbook","date":"2017-06-28T14:22:38.000Z","updated":"2017-06-28T14:22:38.844Z","comments":true,"path":"guestbook/index.html","permalink":"http://lincentma.men/guestbook/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-06-15T04:22:36.000Z","updated":"2017-06-15T07:18:28.114Z","comments":false,"path":"categories/index.html","permalink":"http://lincentma.men/categories/index.html","excerpt":"","text":""},{"title":"随笔一记,生活点滴记录","date":"2017-06-28T14:32:59.000Z","updated":"2017-06-28T14:39:38.488Z","comments":true,"path":"mooddatabase/index.html","permalink":"http://lincentma.men/mooddatabase/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-06-15T04:22:27.000Z","updated":"2017-06-15T07:18:54.414Z","comments":false,"path":"tags/index.html","permalink":"http://lincentma.men/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"学习《阿里巴巴Java开发手册》","slug":"learn_alibaba_java","date":"2017-07-23T08:24:02.000Z","updated":"2017-07-26T11:03:57.412Z","comments":true,"path":"learn_alibaba_java.html","link":"","permalink":"http://lincentma.men/learn_alibaba_java.html","excerpt":"","text":"经验，是提高自己的重要途径之一。 学习笔记：编程规约命名风格 “骆驼拼写法”分为两种。第一个词的首字母小写，后面每个词的首字母大写，叫做“小骆驼拼写法”（lowerCamelCase）；第一个词的首字母，以及后面每个词的首字母都大写，叫做“大骆驼拼写法”（UpperCamelCase），又称“帕斯卡拼写法”。类名大骆驼，方法名、参数名、成员变量、局部变量都是小骆驼。 POJO类（只有getter和setter方法的简单类）：布尔类型变量不要加is，否则会引起部分框架解析引起序列化错误。 接口类的方法和属性不要加任何修饰符号，包括public。JDK8允许接口有默认实现，default方法。 基于SOA理念，暴露出来的一定是接口，内部实现类加Impl后缀。 常量定义 常量的复用层次： 跨应用共享常量 应用内共享常量 子工程内共享常量 包内共享常量 类内共享常量： private static final 变量值在范围内变化，设置为枚举类。成员名称全部大写。 OOP规约 直接通过类名访问类的静态变量和静态方法，而不是通过类的对象，增加编译器的解析成本。 所有覆写方法都必须加上@override注解。 所有相同类型的包装对象之间的值的比较，通过equals方法。 原因：Integer在128 127 分为内的复制，Integer对象是在IntegerCache.cache产生，会复用已有的对象，区间之外的所有数据都在堆上产生，并不会复用已有对象。 == 不仅比较值的大小，还比较对象的地址。 POJO类属性必须使用包装类型，返回值和参数也必须使用包装数据类型。预防NPE现象。 基本类型 包装器类型 boolean Boolean char Character int Integer byte Byte short Short long Long float Float double Double 使用索引访问String的split方法，需要对最后一个分隔符后面有无内容进行检查，否则会报IndexOutOfBoundsException。 public String[] split(String regex,int limit)方法：split(String regex) 方法，其实也就等同于split(String regex，0)方法，把结尾的空字符串丢弃！ 可以使用split(“分隔符”,1)或者是org.apache.commons.lang.StringUtils提供的split 参考文章：java 字符串split有很多坑，使用时请小心！！ 循环体内字符串的链接方式： 用String和“+”：因为“+”拼接字符串，每拼接一次都是再内存重新开辟一个新的内存区域（堆里边）,然后把得到的新的字符串存在这块内存，很容易引起内存溢出。 使用StringBuilder的append方法进行扩展。是在已有的内存空间追加的字符串。 commonlang工具包的StringUtils.join(list,”,”);来一步实现这个拼接而且还能指定分隔的符号。 对象的clone方法默认是前拷贝，实现深拷贝需要重写clone方法。 基本数据类型的拷贝是没有意义的，String类型这样的引用的拷贝才是有意义的。 需要注意的是，如果在拷贝一个对象时，要想让这个拷贝的对象和源对象完全彼此独立，那么在引用链上的每一级对象都要被显式的拷贝。所以创建彻底的深拷贝是非常麻烦的，尤其是在引用关系非常复杂的情况下， 或者在引用链的某一级上引用了一个第三方的对象， 而这个对象没有实现clone方法， 那么在它之后的所有引用的对象都是被共享的。 参考文章：详解Java中的clone方法 — 原型模式 集合处理 只要重写equals方法，就必须重写hashCode。 为了保证同一个对象，保证在equals相同的情况下hashcode值必定相同，如果重写了equals而未重写hashcode方法，可能就会出现两个没有关系的对象equals相同的（因为equal都是根据对象的特征进行重写的），但hashcode确实不相同的。 Set存放不重复队形，先比较hashCode，再用equals比较，提高效率。 String两个方法都重写了，放心使用。 参考文章：为什么重写equals时必须重写hashCode方法？ ArrayList之subList： Java.util.List中有一个subList方法，用来返回一个list的一部分的视图。 1List&lt;E&gt; subList(int fromIndex, int toIndex); 它返回原来list的从[fromIndex, toIndex)之间这一部分的List(下面称之为sublist)，但是这个sublist是依赖于原来的List集合。 在subList中进行了结构性修改（list大小修改），原来的list的大小也会发生变化，抛出一个ConcurrentModificationException。 集合转为数组的方法，必须使用集合的toArray(T[] array)，类型与大小完全一致。 不带参数的toArray方法，是构造的一个Object数组，然后进行数据拷贝，此时进行转型就会产生ClassCastException。 Arrays.asList()数组转为集合方法，不能使用挂起修改集合相关的方法，如add、remove、clear等，会抛出UnsupportedOperationException异常。 设计模式：适配器模式。只是转换接口，后台的数据仍是数组。 Arrays.asList方法返回的ArrayList是继承自AbstractList同时实现了RandomAccess和Serializable接口，AbstractList定义add等方法抛出异常。 解决方法： 12345//1List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1,2,3));//2int i[]=&#123;11,22,33&#125;; Arrays.asList(ArrayUtils.toObject(i)); Java泛型通配符PECS原则： 如果要从集合中读取类型T的数据，并且不能写入，可以使用 ? extends 通配符；(Producer Extends) 如果要从集合中写入类型T的数据，并且不需要读取，可以使用 ? super 通配符；(Consumer Super) 如果既要存又要取，那么就不要使用任何通配符。 不要在foreach循环中进行元素的remove/add操作。如果要remove，需在Iterator中。如果并发，需给Iterator加锁。 List类会在内部维护一个modCount的变量，用来记录修改次数。 每生成一个Iterator，Iterator就会记录该modCount，每次调用next()方法就会将该记录与外部类List的modCount进行对比，发现不相等就会抛出多线程编辑异常。 1234//foreach和迭代器的hasNext()方法，foreach这个语法糖，实际上就是while(itr.hasNext())&#123; itr.next()&#125; 123public boolean hasNext() &#123; return cursor != size;&#125; cursor是用于标记迭代器位置的变量，该变量由0开始，每次调用next执行+1操作。 你的代码在执行删除“1”后，size=1，cursor=1，此时hasNext()返回false，结束循环，因此你的迭代器并没有调用next查找第二个元素，也就无从检测modCount了，因此也不会出现多线程修改异常但当你删除“2”时，迭代器调用了两次next，此时size=1，cursor=2，hasNext()返回true，于是迭代器傻乎乎的就又去调用了一次next()，因此也引发了modCount不相等，抛出多线程修改的异常。 当你的集合有三个元素的时候，你就会神奇的发现，删除“1”是会抛出异常的，但删除“2”就没有问题了，究其原因，和上面的程序执行顺序是一致的。 参考文章：为什么java不要在foreach循环里进行元素的remove/add操作 在 JDK 7 版本以上， Comparator 要满足自反性，传递性，对称性，不然 Arrays.sort ，Collections.sort 会报 IllegalArgumentException 异常。 保证等于和大小与分开，要严格有序。 Comparable 是排序接口。若一个类实现了Comparable接口，就意味着“该类支持排序”。 Comparable 接口仅仅只包括一个函数： Comparator 是比较器接口。我们若需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)，可以通过“实现Comparator类来新建一个比较器”，然后通过该比较器对类进行排序。 Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。 1234567891011package java.lang;import java.util.*;public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125;public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2); boolean equals(Object obj);&#125; 集合初始化，指定集合的初始值大小。 Collection的初始容量也显得异常重要。所以：对于已知的情景，请为集合指定初始容量。 HashMap初始化容量计算 = （需要存储元素的个数 / 负载因子） + 1 12345678910111213141516171819202122// ArrayList新容量扩大到原容量的1.5倍，右移一位相关于原数值除以2。int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//Vector线程安全，速度慢。默认初始容量为10，加载因子为1：即当 元素个数 超过 容量长度 时，进行扩容扩容增量：原容量的1倍int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity);//HashMapstatic final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;static final float DEFAULT_LOAD_FACTOR = 0.75f;if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1;//HashTableint newCapacity = oldCapacity * 2 + 1;//StringBuildervoid expandCapacity(int minimumCapacity) &#123; int newCapacity = value.length * 2 + 2; if (newCapacity minimumCapacity &lt; 0) newCapacity = minimumCapacity; if (newCapacity &lt; 0) &#123; if (minimumCapacity &lt; 0) // overflow throw new OutOfMemoryError(); newCapacity = Integer.MAX_VALUE; &#125; value = Arrays.copyOf(value, newCapacity); &#125; 集合名称 默认容量 加载因子 扩容容量(扩大到原来的) ArrayList 10 1 1.5 Vector 10 1 2 HashSet 16 0.75 2 HashMap 16 0.75 2 HashTable 11 0.75 *2 +1 StringBuilder（StringBuffer） 16 条件判断 *2+2 遍历Map类，使用entrySet。 同时遍历key和value时，keySet与entrySet方法的性能差异取决于key的具体情况，如复杂度（复杂对象）、离散度、冲突率等。换言之，取决于HashMap查找value的开销。entrySet一次性取出所有key和value的操作是有性能开销的，当这个损失小于HashMap查找value的开销时，entrySet的性能优势就会体现出来。 同时遍历key和value时，与HashMap不同，entrySet的性能远远高于keySet。这是由TreeMap的查询效率决定的，也就是说，TreeMap查找value的开销较大，明显高于entrySet一次性取出所有key和value的开销。因此，遍历TreeMap时强烈推荐使用entrySet方法。 123456789101112131415//keySet遍历2次，一次转为Iterator对象，一次从HashMap中取出对应的valuefor (String key : map.keySet()) &#123; value = map.get(key);&#125;//entrySetfor (Entry&lt;String, String&gt; entry: map.entrySet()) &#123; key = entry.getKey(); value = entry.getValue();&#125;//for循环for (String value : map.values()) &#123;&#125;//JDK8 增强for循环Map&lt;String, Integer&gt; items = new HashMap&lt;&gt;();items.forEach((k,v)&gt;System.out.println(\"key : \" + k + \"; value : \" + v)); 参考文章：Java Map遍历方式的选择 Map类集合K/V为null需要注意的地方： 集合类 Key Value Super 说明 Hashtable 不允许为 null 不允许为 null Dictionary 线程安全 ConcurrentHashMap 不允许为 null 不允许为 null AbstractMap 分段所锁技术 TreeMap 不允许为 null 允许为 null AbstractMap 线程不安全 HashMap 允许为 null 允许为 null AbstractMap 线程不安全 由于 HashMap的干扰，很多人认为 ConcurrentHashMap是可以置入 null值，注意存储null值时会抛出 NPE异常。 集合的有序性和稳定性：ArrayList是order/unsort，HashMap是unorder/unsort，TreeSet是order/sort 利用Set唯一性去重，避免使用List的contains方法遍历去重。Collection的contains()和remove()操作都是线性时间复杂度，用set也会隐式的调用contains()方法，不过你用的是HashSet,这个contains()应该只会用常数时间，所以如果考虑平均时间复杂度，用set可能会占优；最坏情况下，两者可能差不多 。 并发处理 获取单例对象，保证线程安全，以及方法的线程安全。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//立即加载（饿汉模式），在调用getInstance()方法前，实例就被创建了，getInstance()方法没有同步，所以可能出现非线程安全问题。public class Singleton &#123; private final static Singleton INSTANCE = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return INSTANCE; &#125;&#125;//延迟加载（懒汉模式），延迟加载就是在getInstance()方法中创建实例。在多线程的环境中，延迟加载中使用同步代码块，对类加锁。虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125;//DCL双检查锁机制。 DCL双检查锁机制即使用volatile关键字（使变量在多个线程中可见）修改对象和synchronized代码块//两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。//instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。//给 instance 分配内存//调用 Singleton 的构造函数来初始化成员变量//将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）//JVM 的即时编译器中存在指令重排序的优化，只需要将 instance 变量声明成 volatile 来避免指令重排序。public class Singleton &#123; private static volatile Singleton singleton = null; private Singleton()&#123;&#125; public static Singleton getSingleton()&#123; if(singleton == null)&#123; synchronized (Singleton.class)&#123; if(singleton == null)&#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125;//【推荐】静态内部类//使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。//但是如果对象是序列化的就无法达到效果了。public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125;//枚举//枚举的缺点是它无法从另一个基类继承，因为它已经继承自java.lang.Enum。public enum FooEnumSingleton &#123; INSTANCE; public static FooEnumSingleton getInstance() &#123; return INSTANCE; &#125; public void bar() &#123; &#125;&#125; 线程资源通过线城池提供，通过ThreadPoolExecutor方式创建。 ThreadPoolExecutor作为java.util.concurrent包对外提供基础实现，以内部线程池的形式对外提供管理任务执行，线程调度，线程池管理等等服务 Executors方法提供的线程服务，都是通过参数设置来实现不同的线程池机制。 关系：Executors可以认为是封装好的线城池服务，ThreadPoolExecutor更加明确线程池的运行机制。 Executors.newCachedThreadPool(); ``//创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE，允许创建线程为Integer.MAX_VALUE,容易OOM Executors.newSingleThreadExecutor(); ``//创建容量为1的缓冲池，请求队列为长度为Integer.MAX_VALUE,容易OOM， Executors.newFixedThreadPool(``int``); ``//创建固定容量大小的缓冲池请，求队列为长度为Integer.MAX_VALUE,容易OOM 123456789101112131415161718192021222324252627282930public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; /*corePoolSize 核心线程池大小maximumPoolSize 线程池最大容量大小keepAliveTime 线程池空闲时，线程存活的时间TimeUnit 时间单位ThreadFactory 线程工厂BlockingQueue任务队列RejectedExecutionHandler 线程拒绝策略*/ 123456789101112131415161718192021222324252627282930313233public class Test &#123; public static void main(String[] args) &#123; ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(5)); for(int i=0;i&lt;15;i++)&#123; MyTask myTask = new MyTask(i); executor.execute(myTask); System.out.println(\"线程池中线程数目：\"+executor.getPoolSize()+\"，队列中等待执行的任务数目：\"+ executor.getQueue().size()+\"，已执行玩别的任务数目：\"+executor.getCompletedTaskCount()); &#125; executor.shutdown(); &#125;&#125; class MyTask implements Runnable &#123; private int taskNum; public MyTask(int num) &#123; this.taskNum = num; &#125; @Override public void run() &#123; System.out.println(\"正在执行task \"+taskNum); try &#123; Thread.currentThread().sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"task \"+taskNum+\"执行完毕\"); &#125;&#125; 参考文章：[深入理解Java之线程池](http://www.importnew.com/19011.html) SimpleDateFormat类线程不安全 线程不安全原因： SimpleDateFormat(下面简称sdf)类内部有一个Calendar对象引用,它用来储存和这个sdf相关的日期信息,例如sdf.parse(dateStr), sdf.format(date) 。 calendar这个共享变量的访问没有做到线程安全 解决方法： 将SimpleDateFormat定义成局部变量： 加一把线程同步锁：synchronized(lock)； 【推荐】使用ThreadLocal: 每个线程都将拥有自己的SimpleDateFormat对象副本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.Map;public class DateUtil &#123; /** 锁对象 */ private static final Object lockObj = new Object(); /** 存放不同的日期模板格式的sdf的Map */ private static Map&lt;String, ThreadLocal&lt;SimpleDateFormat&gt;&gt; sdfMap = new HashMap&lt;String, ThreadLocal&lt;SimpleDateFormat&gt;&gt;(); /** * 返回一个ThreadLocal的sdf,每个线程只会new一次sdf * * @param pattern * @return */ private static SimpleDateFormat getSdf(final String pattern) &#123; ThreadLocal&lt;SimpleDateFormat&gt; tl = sdfMap.get(pattern); // 此处的双重判断和同步是为了防止sdfMap这个单例被多次put重复的sdf if (tl == null) &#123; synchronized (lockObj) &#123; tl = sdfMap.get(pattern); if (tl == null) &#123; // 只有Map中还没有这个pattern的sdf才会生成新的sdf并放入map System.out.println(\"put new sdf of pattern \" + pattern + \" to map\"); // 这里是关键,使用ThreadLocal&lt;SimpleDateFormat&gt;替代原来直接new SimpleDateFormat tl = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123; @Override protected SimpleDateFormat initialValue() &#123; System.out.println(\"thread: \" + Thread.currentThread() + \" init pattern: \" + pattern); return new SimpleDateFormat(pattern); &#125; &#125;; sdfMap.put(pattern, tl); &#125; &#125; &#125; return tl.get(); &#125; /** * 是用ThreadLocal&lt;SimpleDateFormat&gt;来获取SimpleDateFormat,这样每个线程只会有一个SimpleDateFormat * * @param date * @param pattern * @return */ public static String format(Date date, String pattern) &#123; return getSdf(pattern).format(date); &#125; public static Date parse(String dateStr, String pattern) throws ParseException &#123; return getSdf(pattern).parse(dateStr); &#125;&#125; 高并发的同步调用考虑锁的性能消耗，锁的粒度尽可能小。 在获得锁之前做完所有需要做的事，只把锁用在需要同步的资源上，用完之后立即释放它。减少锁持有时间。 减小锁粒度：ConcurrentHashMap。 锁粗化：如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。 锁消除：即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。 分别用不同的锁来保护同一个类中多个独立的状态变量，而不是对整个类域只使用一个锁。锁分离。ReadWriteLock。 参考文章：Java 高并发九：锁的优化和注意事项详解 对多个资源、库表、对象加锁，需要保持一致的加锁顺序。 当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。 此外还有加锁时限、死锁检测等方法预防死锁。 并发修改同一记录必须加锁。 乐观锁，大多是基于数据版本(Version)记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。 提交版本必须大于记录当前版本才能执行更新。 悲观锁（Pessimistic Lock），正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。 多线程并行之Timer 定时任务用Timer实现有可能出现异常，因为它是基于绝对时间而不是相对时间进行调度的。当环境的系统时间被修改后，原来的定时任务可能就不跑了。另外需要注意一点，捕获并处理定时任务的异常。如果在TimerTask里抛出了异常，那么Timer认为定时任务被取消并终止执行线程。 异步转同步操作CountDownLatch CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。 CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。 构造器中的**计数值（count）实际上就是闭锁需要等待的线程数量**。这个值只能被设置一次，而且CountDownLatch**没有提供任何机制去重新设置这个计数值**。这种通知机制是通过 **CountDownLatch.countDown()**方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调 用了这个方法，count的值等于0，然后主线程就能通过await()方法，恢复执行自己的任务。 参考文章：[什么时候使用CountDownLatch](http://www.importnew.com/15731.html) 多线程之Random 任何情况下都不要在多个线程间共享一个java.util.Random实例，而该把它放入ThreadLocal之中。 Java7在所有情形下都更推荐使用java.util.concurrent.ThreadLocalRandom——它向下兼容已有的代码且运营成本更低。 1234567891011121314151617181920private static void testTL_Random( final int threads, final long cnt )&#123; final CountDownLatch latch = new CountDownLatch( threads ); final ThreadLocal&lt;Random&gt; rnd = new ThreadLocal&lt;Random&gt;() &#123; @Override protected Random initialValue() &#123; return new Random( 100 ); &#125; &#125;; for ( int i = 0; i &lt; threads; ++i ) &#123; final Thread thread = new Thread( new RandomTask( null, i, cnt, latch ) &#123; @Override protected Random getRandom() &#123; return rnd.get(); &#125; &#125; ); thread.start(); &#125;&#125; 参考文章：多线程环境下生成随机数 volatile 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 volatile不能确保原子性 可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过AtomicInteger。 java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。 好的一面是它通过一个直接机器码指令设置值时，能够最小程度地影响其他线程的执行。坏的一面是如果它在与其他线程竞争设置值时失败了，它不得不再次尝试。在高竞争下，这将转化为一个自旋锁，线程不得不持续尝试设置值，无限循环直到成功。 JDK8中LongAdder实例，并使用intValue()和add()来获取和设置值。神奇的地方发生在幕后。这个类所做的事情是当一个直接CAS由于竞争失败时，它将delta保存在为该线程分配的一个内部单元对象中，然后当intValue()被调用时，它会将这些临时单元的值再相加到结果和中。这就减少了返回重新CAS或者阻塞其他线程的必要。 参考文章： 你真的了解volatile关键字吗？ Java 8 LongAdders：管理并发计数器的正确方式 HashMap在resize可能发生死链，加锁解决。 当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。 首先如果多个线程同时使用put方法添加元素，而且假设正好存在两个put的key发生了碰撞(hash值一样)，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程的put的数据被覆盖。 线程安全： Hashtable ConcurrentHashMap(性能优势) Synchronized Map 参考文章：如何线程安全的使用HashMap ThreadLocal 参考文章：彻底理解ThreadLocal 参考文章： 【Java编码规范】《阿里巴巴Java开发手册（正式版）》更新（v1.2.0版）——迄今最完善版本 白话阿里巴巴Java开发手册(编程规约) 白话阿里巴巴Java开发手册（异常日志） 白话阿里巴巴Java开发手册（安全规约）","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://lincentma.men/categories/学习笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lincentma.men/tags/java/"},{"name":"alibaba","slug":"alibaba","permalink":"http://lincentma.men/tags/alibaba/"}]},{"title":"SSM框架整合理解","slug":"frame_ssm","date":"2017-07-17T16:32:21.000Z","updated":"2017-07-17T16:34:41.340Z","comments":true,"path":"frame_ssm.html","link":"","permalink":"http://lincentma.men/frame_ssm.html","excerpt":"","text":"SSM框架整合理解 把IntelliJ IDEA+Maven+Spring + SpringMVC + MyBatis项目部署，框架流程梳理调试了一遍，加深自己的理解。 回顾SSM框架SpringSpring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。Spring的核心思想是IoC（控制反转），即不再需要程序员去显式地new一个对象，而是让Spring框架帮你来完成这一切。 SpringMVCSpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。SpringMVC相当于SSH框架中struts。 mybatismybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。 SSM框架流程 SSM框架搭建创建Maven的Web项目 通过IntelliJ IDEA创建maven项目： 选中Createfrom archetype，选择maven-archetype-webapp 在Properties中添加一个参数 archetypeCatalog=internal，提高maven项目构建速度 SSH框架Web项目框架 main： 创建java文件夹：项目代码 resources文件夹： mapping文件夹：数据库表xml xml配置文件 webapp： WEB-INF： 创建jsp文件夹：不同显示页面 web.xml:配置文件 Tomcat启动项目 为项目配置Tomcat 配置各种XML pom.xml——引入项目所需要的jar包 spring核心依赖 mybatis依赖 mybatis-spring整合包依赖 mysql驱动依赖 其他依赖： 日志相关：log4j、slf4j 连接池相关：commons-dbcp、c3p0、Druid Json相关：fastjson 其他：jstl PS：此外还有SpringBoot可以简化xml中的配置项数量。SpringBoot完全抛弃了繁琐的XML文件配置方式，而是替代性地用注解方式来实现。 参考文章：IDEA下从零开始搭建SpringBoot工程 调试过程中的错误有很大一部分是所引的jar没有在pom.xml配置，这部分需要仔细细致。 关于jar包的版本号的修改，可以在标签中用变量保存版本号，中具体的jar包的版本用变量代替，方便后续修改。 web.xml 这是整个web项目的配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;display-name&gt;cloudmusic_ssm_demo&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 防止spring内存溢出监听器，比如quartz --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- spring mvc servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 此处也可以配置成 *.do 形式 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- session配置 --&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; 中的配置，加载SpringMVC的配置文件。 SpringMVC具有统一的入口DispatcherServlet，所有的请求都通过DispatcherServlet。DispatcherServlet是前置控制器，配置在web.xml文件中的。拦截匹配的请求，Servlet拦截匹配规则要自已定义，把拦截下来的请求，依据某某规则分发到目标Controller来处理。 拦截所有的请求，并加载所有的ssm配置文件（路径为classpath:spring-mvc.xml） 在web.xml中使用contextConfigLocation参数定义要装入的Spring配置文件。 加载路径为classpath:spring-mybatis.xml文件 参考文章： SSM:spring+springmvc+mybatis框架中的XML配置文件功能详细解释 spring-mvc.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\"&gt; &lt;!-- 自动扫描 @Controller--&gt; &lt;context:component-scan base-package=\"com.ssm.demo.controller\"/&gt; &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id=\"mappingJacksonHttpMessageConverter\" class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;ref bean=\"mappingJacksonHttpMessageConverter\"/&gt; &lt;!-- JSON转换器 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!-- 文件上传配置 --&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 默认编码 --&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"/&gt; &lt;!-- 上传文件大小限制为31M，31*1024*1024 --&gt; &lt;property name=\"maxUploadSize\" value=\"32505856\"/&gt; &lt;!-- 内存中的最大值 --&gt; &lt;property name=\"maxInMemorySize\" value=\"4096\"/&gt; &lt;/bean&gt;&lt;/beans&gt; controller注入：使用组件扫描方式，扫描包下面所有的Controller，可以使用注解来指定访问路径。 Spring 所有功能都在 Bean 的基础上演化而来，所以必须事先将 Controller 变成 Bean。配置了一个 AnnotationMethodHandlerAdapter，它负责根据 Bean 中的 Spring MVC 注解对 Bean 进行加工处理，使这些 Bean 变成控制器并映射特定的 URL 请求。 视图解析：在Controller中设置视图名的时候会自动加上前缀和后缀。 spring-mybatis.xml：Spring与MyBatis的整合配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=\"com.ssm.demo\"/&gt; &lt;!-- 第一种方式：加载一个properties文件 --&gt; &lt;bean id=\"propertyConfigurer\" class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"location\" value=\"classpath:jdbc.properties\"/&gt; &lt;/bean&gt; &lt;!-- 第二种方式：加载多个properties文件 &lt;bean id=\"configProperties\" class=\"org.springframework.beans.factory.config.PropertiesFactoryBean\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;value&gt;classpath:common.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"fileEncoding\" value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean id=\"propertyConfigurer\" class=\"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer\"&gt; &lt;property name=\"properties\" ref=\"configProperties\"/&gt; &lt;/bean&gt; --&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driverClass&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbcUrl&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=\"initialSize\" value=\"$&#123;initialSize&#125;\"&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=\"maxActive\" value=\"$&#123;maxActive&#125;\"&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=\"maxIdle\" value=\"$&#123;maxIdle&#125;\"&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=\"minIdle\" value=\"$&#123;minIdle&#125;\"&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=\"maxWait\" value=\"$&#123;maxWait&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- mybatis和spring完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapping/*.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.ssm.demo.dao\"/&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt;&lt;/beans&gt; 自动扫描，自动注入，配置数据库 自动扫描,将标注Spring注解的类自动转化Bean，同时完成Bean的注入 加载数据资源属性文件 配置数据源（三种方式，采用DBCP） 配置sessionfactory 装配Dao接口 声明式事务管理 注解事务切面 Mapper.xml映射文件中定义了操作数据库的sql，每一个sql是一个statement，映射文件是myBatis的核心。 jdbc.properties：JDBC属性文件 123456789101112131415driverClass=com.mysql.jdbc.DriverjdbcUrl=jdbc:mysql://localhost:3306/db_ssm?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNullusername=rootpassword=147789#定义初始连接数initialSize=0#定义最大连接数maxActive=20#定义最大空闲maxIdle=20#定义最小空闲minIdle=1#定义最长等待时间maxWait=60000 创建业务流程 以数据库查询表内容为例 持久层：DAO层（mapper）做数据持久层的工作，负责与数据库进行联络的一些任务都封装在此， DAO层的设计首先是设计DAO的接口， 然后在Spring的配置文件中定义此接口的实现类， 然后就可在模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰， DAO层的数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。 业务层：Service层 主要负责业务模块的逻辑应用设计。 首先设计接口，再设计其实现的类 接着再在Spring的配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。 Service层的业务实现，具体要调用到已定义的DAO层的接口， 封装Service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性，程序显得非常简洁。 表现层：Controller层（Handler层）负责具体的业务模块流程的控制 在此层里面要调用Service层的接口来控制业务流程， 控制的配置也同样是在Spring的配置文件里面进行，针对具体的业务流程，会有不同的控制器，我们具体的设计过程中可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块，这样不仅使程序结构变得清晰，也大大减少了代码量。 模型层：Model层 主要存放实体类 项目代码结构： controller： “@RequestMapping”请求路径映射，如果标注在某个controller的类级别上，则表明访问此类路径下的方法都要加上其配置的路径；最常用是标注在方法上，表明哪个具体的方法来接受处理某次请求。 调用service层方法 spring mvc 支持如下的返回方式：ModelAndView, Model, ModelMap, Map,View, String, void。本文返回的是String，通过model进行使用。 参考文章：SpringMVC返回（return）方式详解 service：建立service接口和实现类 impl:接口对应实现类： 调用Dao层的数据库操作以及model层的实体类 dao 定义接口中的方法 一个Dao对应一个对应的mapper文件，实现Dao对应的定义的接口方法 mapping： mapper.xml：实现dao中接口定义的方法 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.ssm.demo.dao.UserDao\"&gt; &lt;resultMap id=\"UserBaseMap\" type=\"com.ssm.demo.model.User\"&gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"BIGINT\"/&gt; &lt;result column=\"user_name\" property=\"userName\" jdbcType=\"VARCHAR\"/&gt; &lt;result column=\"user_phone\" property=\"userPhone\" jdbcType=\"VARCHAR\"/&gt; &lt;result column=\"user_email\" property=\"userEmail\" jdbcType=\"VARCHAR\"/&gt; &lt;result column=\"user_pwd\" property=\"userPwd\" jdbcType=\"VARCHAR\"/&gt; &lt;result column=\"pwd_salt\" property=\"pwdSalt\" jdbcType=\"VARCHAR\"/&gt; &lt;result column=\"create_time\" property=\"createTime\" jdbcType=\"DATE\"/&gt; &lt;result column=\"modify_time\" property=\"modifyTime\" jdbcType=\"DATE\"/&gt; &lt;result column=\"is_delete\" property=\"isDelete\" jdbcType=\"SMALLINT\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;select id=\"selectUserById\" parameterType=\"java.lang.Long\" resultMap=\"UserBaseMap\"&gt; SELECT * FROM t_user WHERE id = #&#123;userId&#125; &lt;/select&gt; &lt;select id=\"selectUserByPhoneOrEmail\" resultMap=\"UserBaseMap\"&gt; SELECT * FROM t_user WHERE user_email = #&#123;emailOrPhone&#125; OR user_phone = #&#123;emailOrPhone&#125; AND user_state = #&#123;state&#125; &lt;/select&gt; &lt;select id=\"selectAllUser\" resultMap=\"UserBaseMap\"&gt; SELECT * FROM t_user &lt;/select&gt;&lt;/mapper&gt; namespace:当前库表映射文件的命名空间，唯一的不能重复 映射实体类的数据类型 id：resultMap的唯一标识 column:库表的字段名 property:实体类里的属性名 id：当前sql的唯一标识 parameterType：输入参数的数据类型 返回值的数据类型：resultMap适合使用返回值是自定义实体类的情况 ； resultType适合使用返回值的数据类型是非自定义的，即jdk的提供的类型。 {}:用来接受参数的，如果是传递一个参数#{id}内容任意，如果是多个参数就有一定的规则,采用的是预编译的形式select model 实体属性——对应表中的元组的属性 getter和setter方法 DataBase ===&gt; Entity ===&gt; Mapper.xml ===&gt; Mapper.Java ===&gt; Service.java ===&gt; Controller.java ===&gt; Jsp. 参考文章SSM框架整合（IntelliJ IDEA + maven + Spring + SpringMVC + MyBatis） SSM框架感受 本质上的MVC，xml配置、注解，以及mapper的映射，让开发更加简洁和思路清晰 ##","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"http://lincentma.men/categories/开发笔记/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://lincentma.men/tags/SSM/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://lincentma.men/tags/SpringMVC/"},{"name":"Spring","slug":"Spring","permalink":"http://lincentma.men/tags/Spring/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://lincentma.men/tags/Mybatis/"}]},{"title":"【面试持续更新】2018校招记录","slug":"interview_record","date":"2017-07-14T16:10:57.000Z","updated":"2017-07-27T13:02:26.374Z","comments":true,"path":"interview_record.html","link":"","permalink":"http://lincentma.men/interview_record.html","excerpt":"","text":"【面试持续更新】2018校招记录工商银行一句话，谈人生谈理想，不谈技术 中兴提前批一面 简单自我介绍 实习经历详细介绍 前端请求与后端处理的异常情况如何处理 SQL模糊查询语句，如何提高查询效率 实习所用PHP框架是如何与数据库相连接的 常用Shell命令 Git开发流程 二面 再次自我介绍 工作地点意向询问 网络请求如何加速（不理解是询问那一方面的加速，自己回答分机房说不对） 实习相关问题 然后就陷入了尴尬的安静 海康威视提前批一面 简单自我介绍 Spark特性有哪些？ 除了Hadoop之外有哪些其他的大数据处理框架？ MapReduce处理过程 Hadoop部署节点？如何部署？ Java与python的交互了解多少？如何进行交互？ Java内存模型介绍？ Java多线程介绍？ JVM调优经验 使用过Redis等NoSQL数据库吗，Redis如何部署？Redis中的数据最终存储在哪里？ 自己询问的问题： 部门业务应用场景：大数据构建多特征模型进行行为安全预测判断 技术能力要求：部门有不同方向，不必太在意招聘中的所有要求都需要符合 什么时候有下一步的结果：他也不知道。。。。","categories":[{"name":"面试","slug":"面试","permalink":"http://lincentma.men/categories/面试/"}],"tags":[{"name":"interview","slug":"interview","permalink":"http://lincentma.men/tags/interview/"}]},{"title":"自己用过的框架","slug":"used_frames","date":"2017-07-14T15:46:16.000Z","updated":"2017-07-14T15:48:14.875Z","comments":true,"path":"used_frames.html","link":"","permalink":"http://lincentma.men/used_frames.html","excerpt":"","text":"自己用过的框架Java之SSH SSH不是一个框架，而是多个框架的集成，是目前较流行的一种Web应用程序开源集成框架，用于构建灵活、易于扩展的多层Web应用程序。 系统从职责上分为四层：表示层、业务逻辑层、数据持久层和域模块层。 Spring+Struts+Hibernate（SSH） 其中使用Struts作为系统的整体基础架构，负责MVC的分离，在Struts框架的模型部分，利用hibernate框架对持久层提供支持，业务层用spring支持。 系统的基本业务流程是： 在表示层中，首先通过JSP页面实现交互界面，负责传送请求(Request)和接收响应(Response)，然后Struts根据配置文件(struts-config.xml)将ActionServlet接收到的Request委派给相应的Action处理。 在业务层中，管理服务组件的 Spring IoC容器负责向Action提供业务模型(Model)组件和该组件的协作对象数据处理(DAO)组件完成业务逻辑，并提供事务处理、缓冲池等容器组件以提升系统性能和保证数据的完整性。 在持久层中，则依赖于Hibernate的对象化映射和数据库交互，处理DAO组件请求的数据，并返回处理结果。 SSH配置流程： 创建web项目 配置struts： 添加Struts2所需要的基本jar包到 lib目录 在web.xml 文件里添加struts的过滤器配置 在src目录下创建struts配置文件struts.xml 配置spring： 在lib目录下导入spring相关的jar包（2个spring跟struts结合的jar包） 在web.xml文件下配置监听器 配置hibernate: 在lib目录里导入hibernate相关的jar包 创建实体类 创建实体类对应的xxx..hbm.xml映射文件 应用IOC实现DAO接口 编写Action类 编写Service(接口类)和ServiceImpl(实现类) Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 Struts它通过采用 Java Servlet/JSP 技术，实现了基于JavaEE Web应用的MVC设计模式的应用框架，是MVC经典设计模式中的一个经典产品。 Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。 Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Spring+SpringMVC+Mybatis（SSM） SpringMVC 做控制器(controller)，Spring 管理各层的组件，MyBatis 负责持久化层。 Struts2与SpringMVC MyBatis与Hibernate MyBatis可以进行更为细致的SQL优化，可以减少查询字段。 MyBatis容易掌握，而Hibernate门槛较高。 Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。 Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。 Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。 Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳，更新操作不能指定刷新指定记录，会清空整个表，但是也可以使用第三方缓存。 Hibernate 封装性好，屏蔽了数据库差异，自动生成SQL语句，应对数据库变化能力较弱，SQL语句优化困难。 MyBatis仅实现了SQL语句和对象的映射，需要针对具体的数据库写SQL语句，应对数据库变化能力较强，SQL语句优化较为方便。 SSM配置流程： 创建web项目 在WEB-INF/lib导入jar包（亦可以根目录下用maven配置文件poom.xml进行配置管理jar包） 配置MyBatis:dao层编写dao类以及对应的mapper和xml（为dao接口方法提供sql语句配置） 配置spring：在applicationContext.xml.xml文件下配置 配置springmvc：配置springMVC.xml 编写Service以及ServiceImpl 编写Controller（相当于struts中的action） SSM和SSH不同主要在MVC实现方式，以及ORM持久化方面不同（Hiibernate与Mybatis）。SSM越来越轻量级配置，将注解开发发挥到极致，且ORM实现更加灵活，SQL优化更简便；而SSH较注重配置开发，其中的Hiibernate对JDBC的完整封装更面向对象，对增删改查的数据维护更自动化，但SQL优化方面较弱，且入门门槛稍高。 参考文章 SSH框架的底层机制及原理 SSH的框架整合 SSH框架总结（框架分析+环境搭建+实例源码下载） SSH和SSM对比总结 手把手教你整合最优雅SSM框架：SpringMVC + Spring + MyBatis SSM SPRING+SPING MVC + MYBATIS 三大框架整合详细步骤 PHP之ODP ODP是公司发布的在线业务开发平台，面向全百度的在线业务支撑平台，专注于总结大社区类业务模式，其提供了标准的webserver环境、标准php环境、AP框架、SAF社区业务框架、基础库、RAL资源访问层、KSARCH通用服务等组件，统一业务的逻辑和部署结构，为测试、运维等提供一致的视图。 这也是自己实习时候一直在用的框架。 Online Develop Platform = Linux+Lightted/nginx+mysql+PHP ODP核心包含了ODP的核心功能组件，包括运行环境、核心基础库、数据交互层、框架等。 横向看，ODP核心通过库、框架、工具等集成支持了各类规范和模式，也为全流程支持提供接口。 向上看，ODP核心直接为产品线业务提供运行环境和研发支持。 向下看，ODP核心通过数据交互层将底层的通用服务提供给业务。 AP框架目录： 1234567891011模板层： odp/template/appname/Actiono: odp/app/appname/actions/PageService: odp/app/appname/models/service/page/DataService: odp/app/appname/models/service/data/Dao: odp/app/appname/models/dao/Controller: odp/app/appname/controller/ ODP应用程序结构： 123456789101112131415161718192021222324252627282930313233343536newapp // 应用名称+--action // 动作类目录| +--api // 子系统交互api目录| | --Sample.php // 示例api服务端action| --Sample.php // 示例普通action+--api // saf api接口和服务类| --Interface.php // 接口类| --Service.php // 实现类+--conf // 配置目录| +--newapp // 配置目录，配置文件可以拆分| --global.conf // app全局配置文件| --log.conf // log示例配置文件+--controllers // 控制类目录| --Main.php // 主控制类| --Api.php // api控制类+--doc // 文档目录+--library // 本地类根目录| +--newapp // app本地类目录| --Util.php // 示例本地类+--models // 数据目录| +--dao // 数据获取目录| | --Sample.php // 示例| +--service // 页面数据服务目录| +--data // 主题数据服务目录| | --Sample.php // 示例| +--page // 页面数据服务目录| --Sample.php // 示例| --SampleApi.php // api示例+--script // 脚本目录| --sampleScript.php // 示例脚本+--test // 测试目录+--Bootstrap.php // ap框架的引导文件+--build.sh // 打包脚本+--index.php // 入口文件+--Makefile // 自动部署脚本--readme.txt // readme文件，告诉你如何部署和运行 DB，通过对应参数的不同，实现自动拼接不同的SQL语句。 1234567891011121314$tables 数据表列表，可以是数组或者字符串$fields 字段列表，可以是数组或者字符串$conds 条件列表，可以是数组或者字符串$options 选项列表，可以是数组或者字符串$appends 结尾操作列表，可以是数组或者字符串例如：$table = ‘student’;$fields = array(‘number’, ‘class’);$conds = array(‘grade =‘ =&gt;‘three’, ‘school =‘ =&gt; ‘希望小学’);调用select($table, $fields, $conds); 就会生成 select number, class from student where grade = ‘three’ and school = ‘希望小学’ 的sql语句并执行之。 逻辑分层之间的调用关系，只能向后依赖，不能向前依赖或者跨层之间依赖。此次逻辑分层从前到后，依次为：Action、PageService、DataService、Dao。具体来说便是指，Dao不能依赖于DataService,PageService,Action；DataService不能依赖于PageService和Action；PageService不能依赖于Action。Action不能直接调用DataService，也不能直接调用Dao；PageService不能直接调用Dao。 SAF是ODP环境提供的业务层框架，SAF框架建立的目的是为了把业务逻辑开发过程中一些共性的问题抽取出来，并提供统一的解决方案。SAF框架包含控制器组件，通用业务组件（参数处理，session处理，日志打印等）以及通用配置组件。可以将SAF框架理解为一个工具库，SAF为我们提供了很多的通用功能例如验证用户的登录信息，接收用户提交的数据，更改用户的信息，记录用户的操作行为等。 SAF框架提供了一个很重要的功能就是钩子（Hook）机制，通过在钩子函数中覆写对应的钩子函数,可以实现对cgi(GET POST等)数据的特殊处理，对登陆信息的校验/修改以及对输出到log日志文件的内容的修改等功能。 RAL是一个支持多种交互协议和打包格式的php扩展。RAL规定了一套高度抽象的交互过程规范，将整个后端交互过程分成了交互协议和数据打包/解包两大块，可以支持一些常用的后端交互协议，标准化协议扩充的开发过程，促进代码复用。RAL集成了负载均衡、健康检查等功能，让上游端不需要再关注这些繁琐的通用逻辑，同时实现版本可以在性能方面有更优的表现。 参考文章： ODP教程 | 百度外卖手册 Python之Tornado 自己做Sug平台展示时候选择的Python Web框架 Tornado 和现在的主流 Web 服务器框架（包括大多数 Python 的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。得利于其 非阻塞的方式和对 epoll 的运用，Tornado 每秒可以处理数以千计的连接，这意味着对于实时 Web 服务来说，Tornado 是一个理想的 Web 框架。我们开发这个 Web 服务器的主要目的就是为了处理 FriendFeed 的实时功能 ——在 FriendFeed 的应用里每一个活动用户都会保持着一个服务器连接。 参考文章： Tornado Nginx 无论做什么框架，很多时候都离不开nginx NGINX 有一个主进程（它执行特权操作，如读取配置和绑定端口）和一些工作进程与辅助进程。 反向代理反向代理应该是Nginx做的最多的一件事了。反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 12345678910server &#123; listen 80; server_name localhost; client_max_body_size 1024M; location / &#123; proxy_pass http://localhost:8080; proxy_set_header Host $host:$server_port; &#125; &#125; 负载均衡负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。 RR每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 1234567891011121314upstream test &#123; server localhost:8080; server localhost:8081;&#125;server &#123; listen 81; server_name localhost; client_max_body_size 1024M; location / &#123; proxy_pass http://test; proxy_set_header Host $host:$server_port; &#125;&#125; 权重指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 1234upstream test &#123; server localhost:8080 weight=9; server localhost:8081 weight=1;&#125; ip_hashiphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 12345upstream test &#123; ip_hash; server localhost:8080; server localhost:8081;&#125; fair按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream backend &#123; fair; server localhost:8080; server localhost:8081;&#125; url_hash按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 123456upstream backend &#123; hash $request_uri; hash_method crc32; server localhost:8080; server localhost:8081;&#125; 动静分离1234567891011121314151617181920212223242526272829upstream test&#123; server localhost:8080; server localhost:8081; &#125; server &#123; listen 80; server_name localhost; location / &#123; root e:wwwroot; index index.html; &#125; # 所有静态请求都由nginx处理，存放目录为html location ~ .(gif|jpg|jpeg|png|bmp|swf|css|js)$ &#123; root e:wwwroot; &#125; # 所有动态请求都转发给tomcat处理 location ~ .(jsp|do)$ &#123; proxy_pass http://test; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root e:wwwroot; &#125; &#125; 参考文章： 全面了解 Nginx 主要应用场景","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"http://lincentma.men/categories/开发笔记/"}],"tags":[{"name":"frame","slug":"frame","permalink":"http://lincentma.men/tags/frame/"}]},{"title":"尘封已久的新浪微博实习面试问题","slug":"merge_file_by_multi_threads","date":"2017-07-05T15:57:49.000Z","updated":"2017-07-05T16:48:31.318Z","comments":true,"path":"merge_file_by_multi_threads.html","link":"","permalink":"http://lincentma.men/merge_file_by_multi_threads.html","excerpt":"","text":"尘封已久的新浪微博实习面试问题 假设本地磁盘目录中有若干文本文件（每行存储一个字符串），要求实现一个多线程的应用程序，将这些文本文件合并为一个文件文件。 备注：编程语言为必须Java，考虑代码注释、日志打印及异常处理，可以忽略内存限制。 请将代码以PDF附件的形式回复，谢谢。 代码思路 最简单的想法，一个线程读一个线程写 其次的想法，多个线程读同一个文件，一个线程写（单线程消费, 这样就严格保证了顺序） 多线程分组读取，是否要考虑文件的顺序？如果考虑顺序该如何？ 线程池、生产者消费者模型 NIO 预先对目录中的文件进行分类；线程间通信，全局变量判断文件读取状态，避免重复读取 同步锁、队列 注释、日志、异常处理 思路参考 java多线程读取多个文件 导入数据库 对于处理大数据量的记录，并将处理结果写入文件中的处理方案：方案一(适合于处理和输出的数据量都很大的情况)：生产者：多个线程 读取一定量的数据并处理，然后将处理结果封装成一个队列元素，装进阻塞队列中消费者: 一个线程 取元素 追加写文件(csv) (多个线程写文件是不安全的) 方案二(目前在使用的，适用于需要处理的数据量大，但输出的数据量不大的情况)：生产者：一个线程，分页查询部分数据，将其封装成队列元素装进队列中消费者：多个线程 ，从队列中取出数据元素并处理，存储处理结果。生产者和消费者执行完毕后，再集中将消费者处理的结果一个个输出到相应文件中 java 使用线程池处理文件夹下面的文件 由于LinkedBlockingQueue实现是线程安全的，实现了先进先出等特性，是作为生产者消费者的首选。 LinkedBlockingQueue 可以指定容量，不指定的话，默认最大是Integer.MAX_VALUE，其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞， 直到有队列成员被放进来。 java多线程批量读取文件(一) 新浪面试题-多线程合并文件 java:NIO读写文件的示例 IntelliJ IDEA 之 jdk Language level 代码实现代码感悟 看了那么多资料，最后还是最简单的最好理解，一个线程读取然后再写，感觉向一个伪多线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.sinatest;import java.io.*;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;import java.util.ArrayList;import java.util.List;import java.util.concurrent.BlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.LinkedBlockingQueue;class fileWorker implements Runnable &#123; private File inputFile; private String outputFile; //构造函数 public fileWorker(File inputFile, String outputFile) &#123; this.inputFile = inputFile; this.outputFile = outputFile; &#125; @Override public synchronized void run() &#123; File output = new File(outputFile); if (!output.exists()) &#123; try &#123; output.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; FileInputStream fin = null; FileOutputStream fout = null; FileChannel fic = null; FileChannel foc = null; try &#123; fin = new FileInputStream(inputFile); fout = new FileOutputStream(output, true); // 从FileInputStream创建用于输入的FileChannel fic = fin.getChannel(); // 从FileOutputStream 创建用于输出的FileChannel foc = fout.getChannel(); // 16KB缓冲区 ByteBuffer bb = ByteBuffer.allocate(1024 &lt;&lt; 4); // 根据 read返回实际读出的字节数 中止循环 while (fic.read(bb) &gt; 0) &#123; // 缓冲区翻转用于输出到foc bb.flip(); foc.write(bb); // 清空缓冲区用于下次读取 bb.clear(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 安全释放资源 if (null != fic) try &#123; fic.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (null != foc) try &#123; foc.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (null != fin) try &#123; fin.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (null != fout) try &#123; fout.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Main &#123; //线程池线程数量 public static final int THREAD_POOL_SIZE = 5; //遍历文件夹 public static List&lt;File&gt; filePathsList = new ArrayList&lt;File&gt;(); //缓存队列 private static final BlockingQueue BLOCKING_QUEUE = new LinkedBlockingQueue(); //1、遍历文件夹 //2、线程池读取 //3、线程写入 public static void main(String[] args) &#123; //读取文件类型 String fileSuffix = \".txt\"; //读取文件目录 String fileFolder = \"D://Project//Java//MergeFile//datatest\"; //合并文件夹路径 String outputFilePath = \"D://Project//Java//MergeFile//output.txt\"; //遍历文件夹 getFileList(fileFolder, fileSuffix); //创建线程池 ExecutorService es = Executors.newFixedThreadPool(THREAD_POOL_SIZE); //每一个线程读取一个文件 for (File filePath : filePathsList) &#123; es.execute(new fileWorker(filePath, outputFilePath)); &#125; &#125; public static void getFileList(String fileFolder, String fileSuffix) &#123; File f = new File(fileFolder); File[] filePaths = f.listFiles(); for (File s : filePaths) &#123; if (s.isDirectory()) &#123; getFileList(s.toString(), fileSuffix); &#125; else &#123; if (-1 != s.getName().lastIndexOf(fileSuffix)) &#123; filePathsList.add(s); &#125; &#125; &#125; &#125;&#125; TODO [ ] 解决写入顺序问题 [ ] 采用生产者消费者模式实现，究竟是多线程读取一个文件，还是多线程读取多个文件，还是多线程写一个文件，哪一个在实际生产环境中是最合适的 [ ] 日志记录以及异常处理","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"http://lincentma.men/categories/开发笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lincentma.men/tags/java/"},{"name":"multi-thread","slug":"multi-thread","permalink":"http://lincentma.men/tags/multi-thread/"}]},{"title":"Python命令行查询成都铁路局12306检票口信息","slug":"find_train_check_in","date":"2017-07-04T13:16:33.000Z","updated":"2017-07-04T13:29:35.339Z","comments":true,"path":"find_train_check_in.html","link":"","permalink":"http://lincentma.men/find_train_check_in.html","excerpt":"","text":"Github地址： [Find-Train-Ticket-Check-in]: https://github.com/lingma1993/Find-Train-Ticket-Check-in 背景近日多地大雨导致铁路多趟列车停运，自己关注成都铁路12306微信公众号，发现一个新的侯乘信息查询功能。 该功能提供了动车和高铁的列车检票口的信息，正好圆了自己的之前挖的坑。 如何获取接口链接地址： chrome F12 点击查询在Network中找到相关接口的信息 http://www.cd-rail.com:9090/CTKF/GeneralProServlet?code=C50101&amp;login=[&quot;10.192.111.79&quot;,&quot;hhs&quot;,&quot;hhs&quot;]&amp;sql=[&quot;20170703&quot;,&quot;ICW&quot;]&amp;where=[]&amp;order=[] 通过Postman模拟数据请求获取数据获取信息请求的格式 接口参数 车站查询 参数名称 参数含义 参数示例 code C50101 login 登陆信息 [“10.192.111.79”,”hhs”,”hhs”] sql 查询语句 [“20170703”,”ICW”] where [] order [] 车次查询 参数名称 参数含义 参数示例 code C5010 login 登陆信息 [“10.192.111.79”,”hhs”,”hhs”] sql 查询语句 [“20170703”,”8503”,”ICW”] where [] order 车站名称查询 参数名称 参数含义 参数示例 code C50102 login 登陆信息 [“10.192.111.79”,”hhs”,”hhs”] sql 查询语句 [] where [] order [] 解析接口返回结果1[&#123;\"CHECK_STATUS\":\"停止检票\",\"CHECK_TICKET\":\"A10、A11\",\"END_CHECK_TIME\":\"2017/07/04 09:30:00\",\"END_STN\":\"重庆北\",\"END_STN_CODE\":\"CUW\",\"IN_DATE\":\"2017/07/04 18:59:52\",\"START_CHECK_TIME\":\"2017/07/04 09:14:00\",\"START_STN\":\"成都东\",\"START_STN_CODE\":\"ICW\",\"STATUS_TRAIN\":\"正点\",\"STN_CODE\":\"ICW\",\"TD_DATE_ARR\":\"00:00:00\",\"TD_DATE_DEP11\":\"09:33\",\"TRAIN_DEP\":\"G8503\",\"WAIT_ROOM\":\"2层候车区\",\"WGQBZ\":\"0\"&#125;] Python urlib、urlib2 构建Header，模拟Post请求 prettytable 处理返回数据格式化为表格 re 匹配站点名称以及检索结果 展示","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"http://lincentma.men/categories/开发笔记/"}],"tags":[{"name":"python","slug":"python","permalink":"http://lincentma.men/tags/python/"}]},{"title":"记如何折腾让博客加HTTPS","slug":"hexo_https","date":"2017-06-27T16:09:54.000Z","updated":"2017-06-27T16:58:24.162Z","comments":true,"path":"hexo_https.html","link":"","permalink":"http://lincentma.men/hexo_https.html","excerpt":"","text":"记如何折腾让博客加HTTPS 折腾了一晚上的博客的HTTPS问题，最后才明白一个道理，世上没有免费的午餐，如果有，那么也是你用最宝贵的时间或是其他换来的。 最终折腾完一圈，回到原点的时候，明白了需求分析而不是说走就走的重要。 背景1 - Google 抓取重定向301在Google搜索site:lincentma.men，查找自己的网站是否被Google收录。 自己的在Google Search Console 中，自己添加了sitemap之后，尝试抓取网站页面，显示： http://lincentma.men/ 请求编入索引 Googlebot类型： 桌面 已重定向 抓取时间：2017年6月26日星期一 GMT-7 下午8:25:37 此网址已重定向至：https://lincentma.men/ 1234567HTTP/1.1 301 Moved PermanentlyContent-Type: application/x-gzipLocation: https://lincentma.men/Server: Coding PagesVary: Accept-EncodingDate: Tue, 27 Jun 2017 03:25:39 GMTContent-Length: 57 导致在Google上没有自己博客更新的文章。 原因：Coding Pages 产生中间页从上面的HTTP响应头部的标志可以看出，Google重定向到了一个Coding Pages的服务商，也就是我双线同步博客的coding pages。 在其官网上我发现： 银牌会员的 Coding Pages 在访问时默认会先加载 Pages 跳转页，您可选择在网站首页任意位置放置「Hosted by Coding Pages」的文字版或图片版，然后勾选下方的「已放置 Hosted by Coding Pages」选项，通过审核后您的 Pages 将不会显示跳转页。请务必将「Hosted by Coding Pages」持续保留在网站首页，撤掉后跳转页会再次出现。 也就是没有银牌会员或者没有在博客上加载广告的时候，就会先跳转到中间页。Google在抓取页面的时候就会发现和目标地址不一致，导致抓取失败。所以没有免费的午餐。 2 - 百度 HTTPS站点认证失败失败详情：您的站点有链接未通过https检验。 知识点 抓取操作不会跟踪重定向。如果您抓取的网页存在重定向，您将需要手动前往重定向到的网址。 301转向(或叫301重定向，301跳转)是当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。 302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。302 重定向会造成网址URL 劫持现象。 HTTP请求格式： 请求头 说明 Host 接受请求的服务器地址，可以是IP:端口号，也可以是域名 User-Agent 发送请求的应用程序名称 Connection 指定与连接相关的属性，如Connection:Keep-Alive Accept-Charset 通知服务端可以发送的编码格式 Accept-Encoding 通知服务端可以发送的数据压缩格式 Accept-Language 通知服务端可以发送的语言 HTTP响应格式： 响应头 说明 Server 服务器应用程序软件的名称和版本 Content-Type 响应正文的类型（是图片还是二进制字符串） Content-Length 响应正文长度 Content-Charset 响应正文使用的编码 Content-Encoding 响应正文使用的数据压缩格式 Content-Language 响应正文使用的语言 HTTPS：HTTPS 协议就是 HTTP+SSL/TLS，即在 HTTP 基础上加入 SSL /TLS 层，提供了内容加密、身份认证和数据完整性3大功能，目的就是为了加密数据，用于安全的数据传输。 其中一个问题：网站改用 HTTPS 以后，由 HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用 301、302 跳转） [推荐文章]: http://support.upyun.com/hc/kb/article/1044299/ Google宣布了，从2017年1月份正式发布的Chrome 56开始，Google将把某些包含敏感内容的https页面标记为“不安全”。 HTTPS是趋势，然而Github不支持自定义域名的强制HTTPS，Coding国内的必须加广告才能强制HTTPS且没有中间跳转页。所以自己就开始了折腾HTTPS的道路。 折腾HTTPS：折腾：配置CloudFare失败终究会有免费的午餐，那就是CloudFare。 配置教程知识点 CloudFlare作为一家CDN提供商，他为免费用户提供的服务室不完整的，根据官网SSL服务的介绍，CloudFlare仅会在浏览器与CloudFlare的通讯中加密，CloudFlare与本地服务器的通讯本身并没有加密。这也是Flexible和Full模式的区别所在。 SSL：在客户端与服务器间传输的数据是通过使用对称算法（如 DES 或 RC4）进行加密的。公用密钥算法（通常为 RSA）是用来获得加密密钥交换和数字签名的，此算法使用服务器的SSL数字证书中的公用密钥。有了服务器的SSL数字证书，客户端也可以验证服务器的身份。SSL 协议的版本 1 和 2 只提供服务器认证。版本 3 添加了客户端认证，此认证同时需要客户端和服务器的数字证书。 关于Let&#39;s Encrypt：[给站点添加 https 小绿锁]: http://www.cnblogs.com/xinpureZhu/articles/lets-encrypt-to-add-https-site-little-green-lock.html 但是，都设置好了。然后就无法访问网页的了。DNS的锅。 发现阿里云的DNS修改后仍处于未更改的状态，即使CloudFlare显示Status：Active。 自己认为可能的是国外DNS被墙，或者是强制HTTPS生效时间过长导致没有及时生效。 返回Coding Pages 加广告无奈返回去添加广告。 知识点 Hexo ，快速、简单且功能强大的 Node.js 博客框架。 页面布局 Hexo中自己感觉一个很有意思的特点是，在_config.yml以及md文件中，通过对于指定字段的true或者false的设置来实现功能，对于使用者来说是黑盒操作，降低了使用难度，提高了使用的体验。这是一种很好的方式。 阿里云更改域名配置买了一个域名：lincentma.men 参考文章：[hexo博客添加域名实现双线部署（github和coding)]: http://blog.csdn.net/qiuchengjia/article/details/52923156 知识点 域名解析就是国际域名或者国内域名以及中文域名等域名申请后做的到IP地址的转换过程。IP地址是网路上标识您站点的数字地址，为了简单好记，采用域名来代替ip地址标识站点地址。域名的解析工作由DNS服务器完成。 域名解析的A：A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。 域名解析的CNAME：别名记录。这种记录允许您将多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。 A记录就是把一个域名解析到一个IP地址（Address，特制数字IP地址），而CNAME记录就是把域名解析到另外一个域名。 还有MX记录（邮件记录）和NS记录（解析服务器记录，NS记录只对子域名生效） TODO [ ] 站点地图的HTTPS是安全的，其他页面是信息不安全的，why？ [ ] Ngnix与SSL [ ] 自己在Github博客申请SSL证书","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"http://lincentma.men/categories/开发笔记/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://lincentma.men/tags/hexo/"},{"name":"https","slug":"https","permalink":"http://lincentma.men/tags/https/"}]},{"title":"【解析】Java Skills For Interview","slug":"java_skills_for_interview","date":"2017-06-25T17:43:55.000Z","updated":"2017-06-26T07:25:20.279Z","comments":true,"path":"java_skills_for_interview.html","link":"","permalink":"http://lincentma.men/java_skills_for_interview.html","excerpt":"","text":"【解析】Java Skills For Interview 从网上偶得之，把每个函数弄明白，源码是怎么写的，为什么这么写。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140//import不要使用通配符，需要import哪一个就import哪一个。import java.util.*; public class JavaSkillsForInterview &#123; public static void main(String[] args) &#123; // String String s = \"abc\"; s.charAt(0);//返回指定索引处的 char 值。 s.length();//返回此字符串的长度。 s.substring(0, 1);//返回字符串的子字符串。beginIndex - 起始索引（包括），endIndex - 结束索引（不包括）。左闭右开。 s.substring(1);//返回beginIndex - 起始索引（包括）到字符串末尾的子字符串。 s.equals(\"b\");//将此字符串与指定的对象比较。 s = s.trim();//返回字符串的副本，忽略前导空白和尾部空白。用于删除字符串的头尾空白符。 s.indexOf(\"a\");//返回指定字符在此字符串中第一次出现处的索引。如果此字符串中没有这样的字符，则返回-1。 s.indexOf(\"a\", 1);//返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 s.lastIndexOf(\"a\");//返回指定字符在此字符串中最后一次出现处的索引。 s.lastindexOf(\"a\", 1);//返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 s.toCharArray();//【常用】将此字符串转换为一个新的字符数组。 Integer.valueOf(s); // returns an Integer object，valueOf会返回一个Integer（整型）对象 //【注意】Integer类有一个静态缓存，存储了256个特殊的Integer对象——每个对象分别对应`-128 和127之间的一个值。 // Integer.valueOf(\"127\")==Integer.valueOf(\"127\");【true】 // Integer.valueOf(\"128\")==Integer.valueOf(\"128\");【false】 Integer.parseInt(s); // returns an int primitive， 将形参s转化为整数。Interger.parseInt(\"1\")=1; String.valueOf(s); // integer to string 返回指定参数的字符串表示形式。 // StringBuilder StringBuilder sb = new StringBuilder(); sb.append(\"a\");//将指定的字符串追加到此字符序列。 sb.insert(0, \"a\"); //在index指示的字符之前插入指定的字符串。 sb.deleteCharAt(sb.length() - 1); //在这个序列中的指定位置，此方法将删除字符。 sb.reverse(); //此方法会导致此字符序列被替换为该序列的反转序列。 sb.toString(); //该方法返回一个字符串，它表示这个序列中的数据。 //String 长度大小不可变 //StringBuffer 和 StringBuilder 长度可变 //StringBuffer 线程安全 StringBuilder 线程不安全 //StringBuilder 速度快 // Array int[] a = new int[10];//初始化方式1 char[] b = &#123;'a', 'b'&#125;;//初始化方式2 int[][] c = new int[10][10];//二维数组 int m = a.length;//数组长度 int n = c[0].length;//二维数组的列数 int max = Integer.MAX_VALUE; //MAX_VALUE = 0x7fffffff （Java语言规范规定int型为4字节） int min = Integer.MIN_VALUE; //MIN_VALUE = 0x80000000 Arrays.sort(a);//数组升序排序 （import java.util.Arrays;）int[]，double[]，char[]等基数据类型的数组，只提供了默认的升序排列，没有提供相应的降序排列方法。 for (int i = 0; i &lt; c.length; i++) &#123; System.out.println(c[i]); &#125;// 遍历数组输出元素 // List //List是一个接口，而ArrayList是一个类。 ArrayList继承并实现了List。 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();//List初始化 ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); //ArrayList初始化 List&lt;List&lt;Integer&gt;&gt; list2 = new ArrayList&lt;List&lt;Integer&gt;&gt;(); //而为List list.add(0);//指定元素E追加到列表的末尾。此方法返回true。 list.add(0, 1);//方法将指定的元素E在此列表中的指定位置。此方法不返回任何值。 list.addAll(list1);//方法会将所有指定集合中的元素添加到此列表的结尾。 list.get(0);//此方法返回在此列表中的指定位置的元素。 list.size();//此方法返回此列表中的元素数。 list.remove(list.size() - 1);//此方法返回从列表中移除的元素。 //Collections是一个类而Collection是一个接口。 Collections.sort(list);//方法用于指定列表按升序进行排序，根据其元素的自然顺序。 Collections.sort(list, Collections.reverseOrder());//反序排列。 //自定义排序。根据Collections.sort重载方法来实现。 Collections.sort(list, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o1 - o2;// 0-&gt;1 // return o2 - o1; 1-&gt;0 &#125; &#125;); // Stack // import java.util.Stack; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); stack.push(0);//把项item压入栈顶，返回item参数。 stack.pop();//返回位于堆栈顶部的元素，在这个过程中除去它。 stack.peek();//返回到堆栈顶部的元素，但不会将其删除。 stack.isEmpty();//栈是否为空。空返回true，否则false。 // isEmpty() 和 empty()的区别：命名区别。 // For example, it was named empty() in original class but was named isEmpty() of Collection interface. stack.size(); //栈中元素的个数。 stack.search(\"code\"); //此方法返回从1开始的位置，一个对象在栈中。栈顶位置为1。 // Queue add ‐‐‐‐‐‐&gt; remove, peek // import java.util.Queue; import java.util.LinkedList; Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;(); q.add(0);//增加一个元索。 q.remove();//移除并返回队列头部的元素。 q.peek();//返回队列头部的元素。 //Queue使用也可以offer()来加入元素，使用poll()来获取并移出元素。 q.isEmpty();//返回队列是否为空。 q.size();//返回队列中元素的个数。 // HashMap // import java.util.HashMap; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();//初始化。 map.put('c', 1);//关联与此映射中的指定键指定的值。添加映射。 map.get('c');//返回指定键映射在此标识哈希映射，或者null，如果映射不包含此键的值。 if (map.containsKey('c')) &#123;//如果此映射包含指定键的映射关系返回true。 &#125; if (map.containsValue(1)) &#123;//如果此映射一个或多个键映射到指定值返回true。 &#125; for (Character d : map.keySet()) &#123;//遍历Hashmap的键集合。Set keySet()返回此映射中包含的键的set视图。 &#125; for (Integer i : map.values()) &#123;//遍历Hashmap的值集合。Collection values()返回此映射中包含的值的collection视图。 &#125; map.isEmpty();//如果此映射不包含键 - 值映射关系返回true。 map.size();//返回键 - 值映射关系在这个映射中的数量。 // HashSet // HashSet借助HashMap来实现的，利用HashMap中Key的唯一性，来保证HashSet中不出现重复值。 // HashMap中的Key是根据对象的hashCode() 和 euqals()来判断是否唯一的。 // import java.util.HashSet; HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();//初始化。 set.add(0);//将指定的元素添加到此集合，如果它是不存在的。 set.remove(0);//从集合中删除指定的元素（如果存在）。 if (set.contains(0)) &#123;//如果此set包含指定的元素，则返回true。 &#125; set.isEmpty();//返回true如果此set不包含任何元素。 set.size();//返回元素的数目（它的基数）。 // mini heap // import java.util.PriorityQueue; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;Integer&gt;();//初始化。 pq.add(0);//该方法调用返回true(所指定的Collection.add(E)) pq.offer(0);//该方法调用返回true(所指定的Queue.offer(E)) pq.remove();//该方法调用返回true，如果此队列由于调用而更改的结果。 pq.peek();//在方法调用返回此队列的头部，或null，如果此队列为空。但它不会将其删除。 pq.poll();//方法用于检索并移除此队列的头，则返回null，如果此队列为空。 pq.isEmpty();//判读是否为空。 pq.size();//在方法调用返回的元素在此集合数 while (!pq.isEmpty()) &#123; &#125; &#125;&#125; 阿里巴巴Java开发规范阿里巴巴Java开发规范","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"http://lincentma.men/categories/开发笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lincentma.men/tags/java/"}]},{"title":"二叉树遍历那点事","slug":"binary_tree_traversal","date":"2017-06-24T15:34:33.000Z","updated":"2017-06-24T16:06:53.106Z","comments":true,"path":"binary_tree_traversal.html","link":"","permalink":"http://lincentma.men/binary_tree_traversal.html","excerpt":"","text":"二叉树遍历那点事 刷leetcode，碰见二叉树，看了一下午二叉树遍历，还在茫然着，写出来就明白了。好脑子不如烂笔头。 二叉树结构123456789101112131415161718192021222324252627282930313233343536373839// Definition for binary treepublic class BinaryTreeNode &#123; private int data; private BinaryTreeNode left; private BinaryTreeNode right; public BinaryTreeNode() &#123;&#125; public BinaryTreeNode(int data, BinaryTreeNode left, BinaryTreeNode right) &#123; super(); this.data = data; this.left = left; this.right = right; &#125; public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; public BinaryTreeNode getLeft() &#123; return left; &#125; public void setLeft(BinaryTreeNode left) &#123; this.left = left; &#125; public BinaryTreeNode getRight() &#123; return right; &#125; public void setRight(BinaryTreeNode right) &#123; this.right = right; &#125;&#125; 数组转换为二叉树 二叉树上的元素存放位置在数组中是固定的。 如果树的i位置（从0开始按层编号）有元素，就放在数组的i号位置，没有元素，数组对应的位置就空着。i的左右子树的编号为2i+1和2i+2。 123456789101112131415161718192021222324252627282930public class BinaryTree &#123; BinaryTreeNode root; class TreeNode &#123; int value; TreeNode left; TreeNode right; public TreeNode(int paraValue) &#123; this.value = paraValue; &#125; &#125; public BinaryTree(int[] array) &#123; root = createBinaryTreeByArray(array, 0); &#125; private TreeNode createBinaryTreeByArray(int[] array, int index) &#123; TreeNode tn = null; if (index &lt; array.length) &#123; int value = array[index]; tn = new TreeNode(value); tn.left = createBinaryTreeByArray(array, 2 * index + 1); tn.right = createBinaryTreeByArray(array, 2 * index + 2); return tn; &#125; return tn; &#125;&#125; 递归与非递归一言以蔽之，非递归比递归难太多。 前序递归遍历算法：访问根结点–&gt;递归遍历根结点的左子树–&gt;递归遍历根结点的右子树中序递归遍历算法：递归遍历根结点的左子树–&gt;访问根结点–&gt;递归遍历根结点的右子树后序递归遍历算法：递归遍历根结点的左子树–&gt;递归遍历根结点的右子树–&gt;访问根结点 明白了思路，递归代码几行就能搞定了。 但是问题来了： 摘自知乎： 递归是函数自身调用自身，涉及到保护现场（变量入栈，记录地址等），时间和空间开销较大，而这操作都是在栈上，调用层级太多很容易溢出。 迭代（非递归）虽然也是用栈，可是这个栈和递归栈可不是一个概念，这个栈完全可以在堆上开辟，空间更大，不容易溢出。迭代也不涉及函数调用，效率也更高。 如何写出非递归的遍历呢？如何把手写遍历结果的过程用代码表达出来。 非递归方法需要借助栈 前序二叉树递归前序遍历的递归定义：先根节点，后左子树，再右子树。 1234567public void preOrder(BinaryTreeNode root) &#123; if (null != root) &#123; System.out.print(root.val); preOrder(root.getLeft()); preOrder(root.getRight()); &#125;&#125; 非递归在手写结果的过程中，我们可以总结出以下规律： 画出二叉树的图，输出顺序都是沿左下方向的直线，输出顺序LIFO，后进先出，满足栈的定义。 借助栈来保存节点，通过节点来打印右子树的数据。 只有入栈时才输出数据 1234567891011121314151617public void preOrderNonRecursive(BinaryTreeNode root) &#123; Stack&lt;BinaryTreeNode&gt; stack = new Stack&lt;BinaryTreeNode&gt;(); while (true) &#123; //首先从根节点开始遍历所有的左子树，并输出节点数据 while (root != null) &#123; System.out.print(root.getData() + \"\\t\"); stack.push(root); root = root.getLeft(); &#125; //循环终止条件：栈容量为0，说明右子树以及遍历完全，跳出。 if (stack.isEmpty()) break; //当上面的while循环完成后，也就是左子树输出完成，栈弹出元素，也就是离得最近的有右子树的节点。 root = stack.pop(); //返回循环，以该节点作为新的root循环输出。 root = root.getRight(); &#125;&#125; 中序二叉树递归中序遍历的递归定义：先左子树，后根节点，再右子树。 1234567public static void inorder(BinaryTreeNode root) &#123; if (root != null) &#123; inorder(root.nodeLeft); System.out.print(root.val); inorder(root.nodeRight); &#125;&#125; 非递归在手写结果的过程中，我们可以总结出以下规律： 与先序类似，只不过输出数据的时机发生了改变。 出栈的时候输出数据 123456789101112131415161718public void inOrderNonRecursive(BinaryTreeNode root) &#123; Stack&lt;BinaryTreeNode&gt; stack = new Stack&lt;BinaryTreeNode&gt;(); while (true) &#123; //遍历左子树，并保存到栈中 while (root != null) &#123; stack.push(root); root = root.getLeft(); &#125; //遍历跳出条件 if (stack.isEmpty()) break; //当上面的while循环完成后，也就是左子树输出完成，栈弹出元素，也就是离得最近的有右子树的节点。 root = stack.pop(); //根据中序遍历的输出顺序，先输出左子树的节点的值 System.out.print(root.getData() + \"\\t\"); //以最左下的节点为例，它的右节点为null，那么再次循环时，就会跳过遍历左子树的循环，栈出栈的节点为它的父节点，也就是根节点，输出其值，再转为其右子树，完成中序遍历的输出顺序。 root = root.getRight(); &#125;&#125; 后序二叉树递归后序遍历的递归定义：先左子树，后右子树，再根节点。 1234567public static void postOrder(BinaryTreeNode root)&#123; if (root != null)&#123; postOrder(root.nodeLeft); postOrder(root.nodeRight); System.out.print(root.val); &#125;&#125; 非递归在手写结果的过程中，我们可以总结出以下规律： 与前面区别在于，判读出栈时，要考虑该节点是否在之前已经访问过。 在stack中，最后添加的数据需要通过lastElement方法获取。 1234567891011121314151617181920212223242526272829303132333435363738public void postOrderNonRecursive(BinaryTreeNode root)&#123; Stack&lt;BinaryTreeNode&gt; stack=new Stack&lt;BinaryTreeNode&gt;(); while(true)&#123; //遍历左子树，并保存到栈中 if(root!=null)&#123; stack.push(root); root=root.getLeft(); &#125;else&#123;//此时，当遍历到最左下的叶节点时，它的左子树是null。 //后序遍历的顺序 if(stack.isEmpty()) return; // 遍历终止条件1：栈空 //栈中最近添加的元素的右子树为空则弹出并输出该元素 if(null==stack.lastElement().getRight())&#123; root=stack.pop(); //输出最开始左子树的叶节点，也就是遍历顺序中的左子树（以及代入的右子树值） System.out.print(root.getData()+\"\\t\"); //while循环终止条件1：出栈后的最近添加的元素则为父节点的右子树与之前出栈的元素相等 while(root==stack.lastElement().getRight())&#123; //root（右子树遍历完成）与此时栈中的最近添加的元素（父节点）的右子树相等，那么说明lastElement为根节点 //输出根节点 System.out.print(stack.lastElement().getData()+\"\\t\"); //出栈（右子树的叶节点） root=stack.pop(); // while终止条件2：栈空 if(stack.isEmpty())&#123; break; &#125; &#125; &#125; //栈不空，则root赋值为栈最近添加元素的右子树，开始从右子树继续遍历 if(!stack.isEmpty()) root=stack.lastElement().getRight(); else //栈空，赋值为null，确保进入遍历结束条件判断的地方 root=null; &#125; &#125;&#125; PS：感觉有点绕，stack.lastElement()这个也可以用pre节点来代替，这样可能更便于理解。 非递归的统一化非递归是否也可以像递归一样，只用修改语句的位置，实现不同方式的遍历呢？ 答案是肯定的，大牛就是多。 统一三种更简单的非递归遍历方法的基本思想：有重合元素的局部有序一定能导致整体有序。 三种非递归遍历唯一不同的就是局部入栈的三行代码的先后顺序。所以不管是根-&gt;左-&gt;右,左-&gt;根-&gt;右,左-&gt;右-&gt;根,甚至是根-&gt;右-&gt;左,右-&gt;根-&gt;左,右-&gt;左-&gt;根定义的新顺序，算法实现都无变化，除了改变局部入栈顺序。 123456789101112131415161718192021222324void postorderTraversalNew(TreeNode *root, vector&lt;int&gt; &amp;path)&#123; stack&lt; pair&lt;TreeNode *, bool&gt; &gt; s; s.push(make_pair(root, false)); bool visited; while(!s.empty()) &#123; root = s.top().first; visited = s.top().second; s.pop(); if(root == NULL) continue; if(visited) &#123; path.push_back(root-&gt;val); &#125; else &#123; s.push(make_pair(root, true)); s.push(make_pair(root-&gt;right, false)); s.push(make_pair(root-&gt;left, false)); &#125; &#125;&#125; PS: 有时间改写成Java版本的。 12 参考文章","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"http://lincentma.men/categories/开发笔记/"}],"tags":[{"name":"binary tree","slug":"binary-tree","permalink":"http://lincentma.men/tags/binary-tree/"},{"name":"recursive","slug":"recursive","permalink":"http://lincentma.men/tags/recursive/"},{"name":"iterate","slug":"iterate","permalink":"http://lincentma.men/tags/iterate/"}]},{"title":"Java、Python与PHP的虚拟机异同","slug":"program_language_virtual_machine","date":"2017-06-23T15:59:24.000Z","updated":"2017-06-23T16:07:27.662Z","comments":true,"path":"program_language_virtual_machine.html","link":"","permalink":"http://lincentma.men/program_language_virtual_machine.html","excerpt":"","text":"Java-JVM定义 JDK(Java Development Kit) 是 Java 语言的软件开发工具包（SDK）。JDK 物理存在，是 programming tools、JRE 和 JVM 的一个集合 JRE（Java Runtime Environment）Java 运行时环境，JRE 物理存在，主要由Java API 和 JVM 组成，提供了用于执行 java 应用程序最低要求的环境。 JVM(Java Virtual Machine) 是一种软件实现，执行像物理机程序的机器（即电脑）。JVM 通过执行 Java bytecode 可以使 java 代码在不改变的情况下运行在各种硬件之上。JVM是基于栈的。 JVM 执行 加载代码 验证代码 执行代码 提供运行环境 JVM 生命周期 启动：任何一个拥有main函数的class都可以作为JVM实例运行的起点 运行：main函数为起点，程序中的其他线程均有它启动，包括daemon守护线程和non-daemon普通线程。daemon是JVM自己使用的线程比如GC线程，main方法的初始线程是non-daemon。 消亡：所有线程终止时，JVM实例结束生命。 JVM结构及内存模型 名词解释： Class Loader：类加载器负责加载程序中的类型（类和接口），并赋予唯一的名字。为什么使用双亲委托模型——ClassLoader 隔离问题。 Execution Engine：执行引擎。执行引擎以指令为单位读取 Java 字节码。它就像一个 CPU 一样，一条一条地执行机器指令。 Runtime Data Areas:：运行时数据区。 PS：想起面试的时候被问到过这样的问题：你在使用java过程中是否遇到过OOM的情况？当时一阵懵比。现在总结下： PC寄存器（PC Register）是唯一一个在 Java 虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 JVM 栈（Java Virtual Machine Stack）：如果JVM Stack可以动态扩展，但是在尝试扩展时无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的虚拟机栈时抛出。 本地方法栈(Native method stack)：如果本地方法栈可以动态扩展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的本地方法栈，那Java虚拟机将会抛出一个OutOfMemoryError异常。 方法区(Method area)：如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。 运行时常量池(Runtime constant pool)：当创建类和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内存空间后就会抛出OutOfMemoryError 堆(Heap)：如果实际所需的堆超过了自动内存管理系统能提供的最大容量时抛出。 总结一下就是无法申请到足够的内存以及超出最大容量两方面原因 垃圾回收 新生代新生代由 Eden 与 Survivor Space（S0，S1）构成，大小通过-Xmn参数指定，Eden 与 Survivor Space 的内存大小比例默认为8:1，可以通过-XX:SurvivorRatio 参数指定，比如新生代为10M 时，Eden分配8M，S0和S1各分配1M。 Eden：希腊语，意思为伊甸园，在圣经中，伊甸园含有乐园的意思，根据《旧约·创世纪》记载，上帝耶和华照自己的形像造了第一个男人亚当，再用亚当的一个肋骨创造了一个女人夏娃，并安置他们住在了伊甸园。 大多数情况下，对象在Eden中分配，当Eden没有足够空间时，会触发一次Minor GC，虚拟机提供了-XX:+PrintGCDetails参数，告诉虚拟机在发生垃圾回收时打印内存回收日志。 Survivor：意思为幸存者，是新生代和老年代的缓冲区域。当新生代发生GC（Minor GC）时，会将存活的对象移动到S0内存区域，并清空Eden区域，当再次发生Minor GC时，将Eden和S0中存活的对象移动到S1内存区域。 存活对象会反复在S0和S1之间移动，当对象从Eden移动到Survivor或者在Survivor之间移动时，对象的GC年龄自动累加，当GC年龄超过默认阈值15时，会将该对象移动到老年代，可以通过参数-XX:MaxTenuringThreshold 对GC年龄的阈值进行设置。 老年代老年代的空间大小即-Xmx 与-Xmn 两个参数之差，用于存放经过几次Minor GC之后依旧存活的对象。当老年代的空间不足时，会触发Major GC/Full GC，速度一般比Minor GC慢10倍以上。 永久代在JDK8之前的HotSpot实现中，类的元数据如方法数据、方法信息（字节码，栈和变量大小）、运行时常量池、已确定的符号引用和虚方法表等被保存在永久代中，32位默认永久代的大小为64M，64位默认为85M，可以通过参数-XX:MaxPermSize进行设置，一旦类的元数据超过了永久代大小，就会抛出OOM异常。 虚拟机团队在JDK8的HotSpot中，把永久代从Java堆中移除了，并把类的元数据直接保存在本地内存区域（堆外内存），称之为元空间。 这样做有什么好处？有经验的同学会发现，对永久代的调优过程非常困难，永久代的大小很难确定，其中涉及到太多因素，如类的总数、常量池大小和方法数量等，而且永久代的数据可能会随着每一次Full GC而发生移动。 而在JDK8中，类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用内存空间，可以避免永久代的内存溢出问题，不过需要监控内存的消耗情况，一旦发生内存泄漏，会占用大量的本地内存。 判断垃圾回收 引用计数法：在对象上添加一个引用计数器，每当有一个对象引用它时，计数器加1，当使用完该对象时，计数器减1，计数器值为0的对象表示不可能再被使用。引用计数法实现简单，判定高效，但不能解决对象之间相互引用的问题。 可达性分析法：通过一系列称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，搜索路径称为 “引用链”，以下对象可作为GC Roots： 本地变量表中引用的对象 方法区中静态变量引用的对象 方法区中常量引用的对象 Native方法引用的对象 当一个对象到 GC Roots 没有任何引用链时，意味着该对象可以被回收。 垃圾回收算法 标记-清除算法对待回收的对象进行标记。算法缺点：效率问题，标记和清除过程效率都很低；空间问题，收集之后会产生大量的内存碎片，不利于大对象的分配。 复制算法复制算法将可用内存划分成大小相等的两块A和B，每次只使用其中一块，当A的内存用完了，就把存活的对象复制到B，并清空A的内存，不仅提高了标记的效率，因为只需要标记存活的对象，同时也避免了内存碎片的问题，代价是可用内存缩小为原来的一半。 标记-整理算法在老年代中，对象存活率较高，复制算法的效率很低。在标记-整理算法中，标记出所有存活的对象，并移动到一端，然后直接清理边界以外的内存。 参考文章 [清蒸 JVM （一）]: http://www.importnew.com/23658.html [Java GC的那些事（上）]: http://www.importnew.com/23633.html [Java GC的那些事（下）]: http://www.importnew.com/23640.html PythonPVMPVM是Python的运行引擎。他通常表现为python系统的一部分。并且他是实际运行脚本的组件。 编译器：将源码编译成运行在虚拟机上执行的opcode(pyc文件)，pyc文件是在python虚拟机上执行的一种跨平台字节码。 运行时：虚拟机解释器把opcode(pyc文件)解释成具体机器的机器码，执行。 JVM与PVM Java代码从源程序到执行，要经过的过程是：编译器(javac)把源代码转化为字节码，然后解释器（Java.exe）把字节码转换为计算机理解的机器码来执行。其中编译器和解释器都是Java虚拟机（JVM）的一部分，由于针对不同的硬件与OS，Java解释器有所不同，因此可以实现“一次编译、到处执行”。所以JVM是Java跨平台特性的关键所在。 对于Python，其源代码到执行也要经过如下过程：源代码—&gt;字节码—&gt;机器码。与Java不同的是，Python使用的虚拟机是基于其他语言实现的，比如我们一般使用的Python实际为Cpython，也就是其虚拟机由C实现，这个虚拟机负责把Python源码编译为字节码，再解释执行。另外，还有Jypython、Ironpython等。 PHP-Zend&amp;HHVM Zend引擎默认做法，是先编译为opcode，然后再逐条执行，通常每条指令对应的是C语言级别的函数。如果我们产生大量重复的opcode（纯PHP写的代码和函数），对应的则是Zend多次逐条执行这些C代码。 HHVM生成和执行PHP的中间字节码（HHVM生成自己格式的中间字节码），执行时通过JIT（Just In Time，即时编译是种软件优化技术，指在运行时才会去编译字节码为机器码）转为机器码执行。JIT将大量重复执行的字节码在运行的时候编译为机器码，达到提高执行效率的目的。通常，触发JIT的条件是代码或者函数被多次重复调用。 写在最后时间匆忙，囫囵吞枣，努力完善。 后端开发离不开Java，python和php，深入学习原理，比较异同，最佳使用。 2017.06.23","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"http://lincentma.men/categories/开发笔记/"}],"tags":[{"name":"python","slug":"python","permalink":"http://lincentma.men/tags/python/"},{"name":"java","slug":"java","permalink":"http://lincentma.men/tags/java/"},{"name":"virtual machine","slug":"virtual-machine","permalink":"http://lincentma.men/tags/virtual-machine/"},{"name":"php","slug":"php","permalink":"http://lincentma.men/tags/php/"}]},{"title":"几个小问题的解答","slug":"learn_for_some_questions","date":"2017-06-22T15:25:38.000Z","updated":"2017-06-22T15:43:43.699Z","comments":true,"path":"learn_for_some_questions.html","link":"","permalink":"http://lincentma.men/learn_for_some_questions.html","excerpt":"","text":"她给我提了一下几个问题，自己一眼看上去觉得简单，但是说不出来所以然，犯了眼高手低的毛病，记录自省。 [x] 一共10级楼梯，每次可以走一步或两步，求一共多少种走法。 [x] 一个细胞，一个小时分裂一次，生命周期是3小时，求n小时后容器内，有多少细胞。 [x] 斐波那契数列的实现。 [x] 递归算法的核心 Question1—走楼梯思路楼梯问题，一眼看上去，应该是一个递归问题跑不了了。 那么该如何递归，找到其中的规律呢？ 逆向思考。 要想走到M(M=10)级,可以分为2种情况。 从m-2级迈两步 从m-1级迈一步 那么对于m-2和m-1的情况也是各自分为两种，以此类推。 那么走法的和就是m-2的走法和m-1的走法之和。 那么递归到最基本的（当前人在第0阶台阶） 第0阶台阶：0 第1阶台阶：1 第2阶台阶：2（1+1或者2） 得到公式，也就是斐波那契数列。$$f(n)=f(n-1)+f(n-2)$$ 代码1234567891011121314151617181920212223242526272829import java.util.Scanner;/** * Created by ml on 2017/6/21. */public class taijie &#123; public static int countNumber(int stepsNum) &#123; int sum = 0; if (stepsNum == 0) &#123; return 0; &#125; if (stepsNum == 1) &#123; return 1; &#125; else if (stepsNum == 2) &#123; return 2; &#125; else if (stepsNum &gt; 2) &#123; return countNumber(stepsNum - 2) + countNumber(stepsNum - 1); &#125; return sum; &#125; public static void main(String[] args) &#123; long startMili=System.currentTimeMillis(); for (int i = 0; i &lt;= 10; i++) &#123; System.out.println(\"楼梯台阶数:\" + i + \", 走法有:\" + countNumber(i)); &#125; long endMili=System.currentTimeMillis(); System.out.println(\"耗时:\" + String.valueOf(endMili - startMili) + \"毫秒\"); &#125;&#125; 1234567891011121314楼梯台阶数:0, 走法有:0楼梯台阶数:1, 走法有:1楼梯台阶数:2, 走法有:2楼梯台阶数:3, 走法有:3楼梯台阶数:4, 走法有:5楼梯台阶数:5, 走法有:8楼梯台阶数:6, 走法有:13楼梯台阶数:7, 走法有:21楼梯台阶数:8, 走法有:34楼梯台阶数:9, 走法有:55楼梯台阶数:10, 走法有:89耗时:0毫秒Process finished with exit code 0 其他的方法该算法的运算时间是指数级增长的，还有其他方法吗？ 动态规划？ 其实动态规划（dynamicprogramming）是通过组合子问题而解决整个问题的解。乍一看和递归的写法差不多，都是相加。但是递归式是包含了许多重复计算的步骤，对应台阶就是每一个台阶计算前面都是重复的。动态规划算法对每个子问题只求解一次，将其结果保存起来，从而避免每次遇到各个子问题时重新计算答案。 代码如下： 1234567891011121314151617181920212223242526272829import java.util.Scanner;/** * Created by ml on 2017/6/21. */public class taijie &#123; public static int climbStairs(int n) &#123; if (n == 0 || n == 1 || n == 2) &#123; return n; &#125; //注意坐标起始点的区别 int[] r = new int[n+1]; r[1] = 1; r[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; r[i] = r[i-1] + r[i-2]; &#125; return r[n]; &#125; public static void main(String[] args) &#123; long startMili=System.currentTimeMillis(); for (int i = 0; i &lt;= 10; i++) &#123; System.out.println(\"楼梯台阶数:\" + i + \", 走法有:\" + climbStairs(i)); &#125; long endMili=System.currentTimeMillis(); System.out.println(\"耗时:\" + String.valueOf(endMili - startMili) + \"毫秒\"); &#125;&#125; 1234567891011121314楼梯台阶数:0, 走法有:0楼梯台阶数:1, 走法有:1楼梯台阶数:2, 走法有:2楼梯台阶数:3, 走法有:3楼梯台阶数:4, 走法有:5楼梯台阶数:5, 走法有:8楼梯台阶数:6, 走法有:13楼梯台阶数:7, 走法有:21楼梯台阶数:8, 走法有:34楼梯台阶数:9, 走法有:55楼梯台阶数:10, 走法有:89耗时:0毫秒Process finished with exit code 0 之前数学课本上如何思考的？ 先求出走完台阶需要几步？ 再求出总步数中，走一个台阶是几步，走两个台阶式几步，不同种类为排列组合计算 类似问题再看一个硬币的凑法： 用1分、2分和5分的硬币凑成1元，共有多少种不同的凑法？（华为机试题） 它和走楼梯的区别在于，楼梯不同顺序是不同的走法，硬币则与顺序无关，程序可用穷举法。 123456789101112131415161718192021public class coin &#123; public static int getKinds()&#123; int num=0; for (int i = 0; i &lt; 21; i++) &#123; for (int j = 0; j &lt;= 100-5*i; j++) &#123; for (int k = 0; k &lt;= 100-5*i-2*j; k++) &#123; if(5*i+2*j+k==100)&#123; num++; &#125; &#125; &#125; &#125; return num; &#125; public static void main(String[] args) &#123; System.out.println(getKinds()); &#125;&#125; 那么这个问题可以推广为一般性问题吗？M阶，一次走a阶或者b阶或者。。。，求不同走法。 参考文章Question2—细胞分裂非递归思路乍一看，关键是如何处理生命周期是3小时。如何在分裂的同时提出死亡的细胞。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/** * Created by ml on 2017/6/22. * 思路：每个细胞定义为一维数组的元素，元素的值为细胞的生存时间，每分裂一次，在数组末尾添加新的元素，初始值为0，同时原来的元素值加1 * 当元素的值为3时，将该元素剔除 * 最后返回该数组的大小 */public class xibao &#123; public static int cellNum2(int n) &#123; ArrayList&lt;Integer&gt; cell = new ArrayList&lt;Integer&gt;(); //定义cellnum int cellnum = 0; //加入初始细胞 cell.add(0); for (int i = 0; i &lt; n; i++) &#123; //记录当前数组大小（剔除完成后的数组） int size = cell.size(); //计算分裂后新的数组的大小 cellnum = 2 * cell.size(); //原有生存时间加1 for (int j = 0; j &lt; cell.size(); j++) &#123; cell.set(j, cell.get(j) + 1); &#125; //遍历剔除元素值为3 PS：ArrayList中遍历可以删除的只有迭代器 Iterator&lt;Integer&gt; it = cell.iterator(); while (it.hasNext()) &#123; if (it.next().equals(3)) it.remove(); &#125; //在数组末尾添加新的元素 for (int j = size; j &lt; cellnum; j++) &#123; cell.add(0); &#125; &#125; return cell.size(); &#125; public static int cellNum(int n) &#123; HashMap&lt;Integer, Integer&gt; cell = new HashMap&lt;&gt;(); int cellnum = 1; for (int i = 1; i &lt;= n; i++) &#123; cellnum *= 2; int size = cell.size(); for (int j = size; j &lt; cellnum; j++) &#123; cell.put(j, 0); &#125; Iterator&lt;HashMap.Entry&lt;Integer, Integer&gt;&gt; iter = cell.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry = iter.next(); int key = (int) entry.getKey(); int val = (int) entry.getValue(); if (key &lt; size) &#123; cell.put(key, val + 1); &#125; &#125; &#125; return cell.size(); &#125; public static void main(String[] args) &#123; long startMili = System.currentTimeMillis(); int n = 6; System.out.println(n + \"小时后容器细胞:\" + cellNum2(n) + \"个\"); long endMili = System.currentTimeMillis(); System.out.println(\"耗时:\" + String.valueOf(endMili - startMili) + \"毫秒\"); &#125;&#125; 12343小时后容器细胞:7个耗时:0毫秒Process finished with exit code 0 关于ArrayList 迭代器是作为当前集合的内部类实现的，当迭代器创建的时候保持了当前集合的引用； 集合内部维护一个字段叫modiCount，用来记录集合被修改的次数，比如add，remove，set等都会使该字段递增； 迭代器内部也维护着当前集合的修改次数的字段，迭代器创建时该字段初始化为集合的modiCount值 当每一次迭代时，迭代器会比较迭代器维护的字段和modiCount的值是否相等，如果不相等就抛ConcurrentModifiedException异常； 当然，如果用迭代器调用remove方法，那么集合和迭代器维护的修改字数都会递增，以保持两个状态的一致。 这就是为什么你只可以用迭代器来删除，而不能用其他方式来修改集合。 这类问题如何递归？公式法：$$n=t/a~~~~y=2^n$$但是这个只适用于最简单的没有任何附加状态条件的情况。 递归如何来分析？ 细胞的生存周期是3个小时，那我们就可以把细胞在题目中状态分为以下几个状态： a：刚分裂态——1 b：分裂1小时态——a分裂出b和a c：分裂2小时态——b分裂出c和a d：分裂3小时态——死亡（停止分裂） 那么，我们就可以根据细胞状态设定函数。分析每一个状态的来源是哪里即可。$$a(t)=a(t-1)+b(t-1)+c(t-1)\\\\b(t)=a(t-1)\\\\c(t)=b(t-1)\\\\d(t)=d(t-1)+c(t-1)$$容器中存活的细胞数目就是a、b、c三种状态数量的总和。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/** * Created by ml on 2017/6/22. */public class xibao &#123; public static int aStatus(int t) &#123; if (t == 0) &#123; return 1; &#125; return aStatus(t - 1) + bStatus(t - 1) + cStatus(t - 1); &#125; public static int bStatus(int t) &#123; if (t == 0) &#123; return 0; &#125; return aStatus(t-1); &#125; public static int cStatus(int t) &#123; if (t == 0) &#123; return 0; &#125; if (t == 1) &#123; return 0; &#125; return bStatus(t-1); &#125; public static int dStatus(int t) &#123; if (t == 0) &#123; return 0; &#125; if (t == 1) &#123; return 0; &#125; if (t == 2) &#123; return 0; &#125; return dStatus(t-1) + cStatus(t-1); &#125; public static void main(String[] args) &#123; long startMili = System.currentTimeMillis(); int n = 3; int res = aStatus(n) + bStatus(n) + cStatus(n); System.out.println(n + \"小时后容器细胞:\" + res + \"个\"); long endMili = System.currentTimeMillis(); System.out.println(\"耗时:\" + String.valueOf(endMili - startMili) + \"毫秒\"); &#125;&#125; 12343小时后容器细胞:7个耗时:0毫秒Process finished with exit code 0 参考文章Question3—Fibonacci数列经典问题：求Fibonacci数列前n项。$${an}：a1=1，a2=1，a_{n+2}=a_{n+1}+a_n（n≥1）。$$ PS: Markdown 中公式书写规则 \\\\符号后接的字符为上标 ^符号后接的字符为上标 _符号后接的字符为下标 如果同时有两个下标，则需要使用{}来将符号括起来 代码1234567891011121314151617181920212223242526272829303132333435public class fab &#123; public static void main(String[] args) &#123; for(int i = 1; i &lt; 10; i ++)&#123; System.out.print(recursion(i) + \" \"); &#125; System.out.println(); for(int i = 1; i &lt; 10; i ++)&#123; System.out.print(loop(i) + \" \"); &#125; &#125; /** * 递归 */ public static int recursion(int n)&#123; if(n &lt;= 2)&#123; return 1; &#125; return recursion(n -1) + recursion(n -2); &#125; /** * 循环 */ public static int loop(int n)&#123; if(n &lt;= 2)&#123; return 1; &#125; int s1 = 1,s2 = 1, sum = 0; for(int i = 0 ; i &lt; n - 2; i ++)&#123; sum = s1 + s2; s1 = s2; s2 = sum; &#125; return sum; &#125;&#125; 1231 1 2 3 5 8 13 21 34 1 1 2 3 5 8 13 21 34 Process finished with exit code 0 值得注意的是（递归方法有栈溢出的风险）。 参考文章Question4—递归核心那么总结一下，递归算法的核心是什么呢？ 那就是： 在有限次可预见性结果中，找到结果与上一次结果之间的关系。 f(n)与f(n-1)的关系有时候很简单，如同走楼梯，状态单一；又有时如同细胞分裂，多种状态组合影响结果。 关键在于梳理清楚本次结果和上一次结果的关系有哪些方面或是因素，刚开始看的时候可能会很乱。 在草稿纸上写出前几次的结果，或者画图，这样更容易找到规律，这种规律实际上就是递归方程。 *在算法的分析中，当一个算法中包含递归调用时，其时间复杂度的分析会转化成为一个递归方程的求解。而对递归方程的求解，方法多种多样，不一而足。 动态规划就是在递归的基础上，保存每一步的数据，避免重复计算。在递归计算调用次数过多时，可以考虑更换其他方法解答。","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"http://lincentma.men/categories/开发笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lincentma.men/tags/java/"}]},{"title":"Rank小记","slug":"learn_rank","date":"2017-06-21T04:13:27.000Z","updated":"2017-06-22T03:16:46.299Z","comments":true,"path":"learn_rank.html","link":"","permalink":"http://lincentma.men/learn_rank.html","excerpt":"","text":"搜索引擎，你每天用的，知其然，不知其所以然。 ——读《搜索引擎 : 信息检索实践》 信息检索的定义信息检索是关于信息的结构、分析、组织、存储、搜索和检索的领域——Gerard Salton 搜索引擎的指标处理数十亿网页的商业化网络搜索引擎时代的今天，搜索引擎的指标体现在以下五个方面： 全 新 准 快 稳 其中Rank的目标就是准 Rank如何所搜即所得是Rank的目的。 海量网页快速排序 相关性：搜索结果与用户需求的匹配程度 多样性（Query对应多个结果，通过用户行为数据进行选择和匹配） 权威性（被引用次数，链接分析。类似于学术文章的因子。） 时效性（Query的频次随时间的变化趋势） 个性化（构建用户个人数据，计算结果与用户喜好匹配程度） 用户成本 如何排序自己的理解，排序就是算分，按照分数来进行排序，key是算分。 经典IR模型:TF-IDF是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。距离特征 Boolean Model：布尔（Boolean）模型是基于集合论和布尔代数的一种简单检索模型。它的特点是查找那些于某个查询词返回为“真”的文档。在该模型中，一个查询词就是一个布尔表达式，包括关键词以及逻辑运算符。通过布尔表达式，可以表达用户希望文档所具有的特征。 Vetor-Space:VSM概念简单，把对文本内容的处理简化为向量空间中的向量运算，并且它以空间上的相似度表达语义的相似度，直观易懂。当文档被表示为文档空间的向量，就可以通过计算向量之间的相似性来度量文档间的相似性。文本处理中最常用的相似性度量方式是余弦距离 Rank关键技术倒排索引在线计算转为离线计算分布式计算系统 Cache辣鸡信息：找出特征，计算分数，剔除。 人工识别与机器学习。Learning to Rank 找了一些文档博客，慢慢学习~ Point-Wise：RankSVMPair-Wise：RankNetList-Wise：RankForest 努力学算法一定可以搞懂的！","categories":[{"name":"intern","slug":"intern","permalink":"http://lincentma.men/categories/intern/"}],"tags":[{"name":"rank","slug":"rank","permalink":"http://lincentma.men/tags/rank/"}]},{"title":"为找工作而准备着","slug":"prepare_for_work","date":"2017-06-17T08:57:30.000Z","updated":"2017-06-22T03:15:06.575Z","comments":true,"path":"prepare_for_work.html","link":"","permalink":"http://lincentma.men/prepare_for_work.html","excerpt":"","text":"为找工作而准备着行业了解互联网+行业——改变传统行业 未来的行业是属于数据驱动的行业： 物流行业（快递物流数据），物流成本仍有巨大空间优化 金融行业（金融数据），普惠金融有广阔的空间 电商行业（交易数据），定制化，差异化，个性化会随着物质条件的不断提高而不断重要 视频行业（视频数据），视频对于文件具有更有效地传播 农业（作物，天气等数据），高品质农业作物的需求不断上升，小作坊式模式对于行情波动的适应性有巨大的改善空间 云（云数据），理论上任何公司的数据都可以上云来进行弹性管理，提高效率 新兴科技（新兴技术），探索无止境，更多广阔的市场是由新兴技术所开创 公司了解 物流行业：菜鸟物流 金融行业：蚂蚁金融、支付宝、微信支付 电商行业：阿里巴巴、京东、美团点评、网易严选考拉 视频行业：今日头条、腾讯视频、B站 农业：网易未央、京东、联想农业 云：阿里云、腾讯云 新兴科技：大疆科技 部门了解 技术营销：通过基础数据分析，找到赋能新方法 基础研发：如何让数据更加适合的展现 产品研发：如何研发用用户不易察觉的方式解决用户痛点的产品 内部研发：研发如何提高开发效率的工具 技术栈了解Unix/Linux 后端必须掌握的操作系统。建议的书籍：《Linux编程》《Unix环境高级编程》 网络编程 建议书籍：《Unix网络编程》《TCP/IP协议详解》 脚本语言PHP、Python深入学习。 数据库 无论是关系型数据库还是非关系型数据库，都是必须要吃透牢牢掌握的东西 工作使命感互联网的技术日新月异的目标就是让人们更加方面的获取一切，享受科技带来的便利； 不可否认互联网技术同样是一把双刃剑，人们在低成本享受的同时，同时也会出现键盘侠、恶意抹黑、舆论控制等让社会阴暗面放大的趋势。 如同微博让人们无所不谈，同时也会有水军，造谣；大疆无人机让我们获得前所未有的影像视角，同时也被用于装备军队送上战场。 在致力于互联网技术和产品不断发展的同时，同时还需要致力于让技术和产品如何正确地服务于人，而避免用于歧途。 数据亦然，发掘数据蕴含的价值创造正能量价值，尽所能。","categories":[{"name":"job","slug":"job","permalink":"http://lincentma.men/categories/job/"}],"tags":[{"name":"job","slug":"job","permalink":"http://lincentma.men/tags/job/"}]},{"title":"在百度实习的日子","slug":"internship_in_baidu","date":"2017-06-17T08:57:10.000Z","updated":"2017-06-22T03:16:19.535Z","comments":true,"path":"internship_in_baidu.html","link":"","permalink":"http://lincentma.men/internship_in_baidu.html","excerpt":"","text":"在百度实习的日子 转眼从百度离开回到了在学校的日子。也应该记录下自己在帝都，在百度的255天。 在百度糯米在百度糯米第一次接触了规范的开发流程，公司庞大的知识储备库，让自己如同海绵一样广泛吸水般吸收知识。有非常nice团队来让我迅速适应这样的开发环境，让我熟悉开发流程，带我一起和产品交流、和运营交流、和测试交流。 在百度搜索在百度搜索我接触到了搜索是如何运转，自己尝试接触Sug的海量数据进行数据分析监控，第一次理解亲身理解大数据所蕴含的价值。一次次的技术分享，让我更加深刻理解百度搜索里面的核心技术的深度，自己仍有很长的路要走。 在百度目前为止我见过最好的办公环境，nice的伙食，健身设备，班车交通，让我每个周末也来公司给自己充电。每天的问好，晚上的坐上班车返回住所，每一天任务的完成带给自己的充实感让自己不断向前。体验过996，体验过封闭开发，体验过部门内分享，体验过酸甜苦辣。感谢百度，感谢曾经的同事，感谢让自己不断成长。","categories":[{"name":"intern","slug":"intern","permalink":"http://lincentma.men/categories/intern/"}],"tags":[{"name":"intern","slug":"intern","permalink":"http://lincentma.men/tags/intern/"}]},{"title":"Hexo之重新初始化","slug":"hexo_init","date":"2017-06-15T07:04:32.000Z","updated":"2017-06-25T18:25:43.666Z","comments":true,"path":"hexo_init.html","link":"","permalink":"http://lincentma.men/hexo_init.html","excerpt":"","text":"站在巨人的肩膀上，搭建Hexo，事半功倍。但是巨人太多，选择好的巨人很重要，不然就不得其法，回到原点。 Hexo参考文档 [NexT]: http://theme-next.iissnan.com/getting-started.html “NexT” [NexT优化]: http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html Hexo搭建问题记录 多说评论替换 背景效果 腾讯云搭建Hexo Hexo 性能优化 [hexo博客进阶－性能优化]: https://www.liuxinggang.com/2016-12-06-hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%8D%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/ 自己更换电脑，没有保存Hexo的源文件，借此机会重新部署学习，完善自己的博客。","categories":[{"name":"教程","slug":"教程","permalink":"http://lincentma.men/categories/教程/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://lincentma.men/tags/hexo/"}]}]}
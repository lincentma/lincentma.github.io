<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LincentMa&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lincentma.men/"/>
  <updated>2017-06-27T16:58:24.162Z</updated>
  <id>http://lincentma.men/</id>
  
  <author>
    <name>LicentMa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记如何折腾让博客加HTTPS</title>
    <link href="http://lincentma.men/hexo_https.html"/>
    <id>http://lincentma.men/hexo_https.html</id>
    <published>2017-06-27T16:09:54.000Z</published>
    <updated>2017-06-27T16:58:24.162Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="记如何折腾让博客加HTTPS"><a href="#记如何折腾让博客加HTTPS" class="headerlink" title="记如何折腾让博客加HTTPS"></a>记如何折腾让博客加HTTPS</h1><blockquote>
<p>折腾了一晚上的博客的HTTPS问题，最后才明白一个道理，世上没有免费的午餐，如果有，那么也是你用最宝贵的时间或是其他换来的。</p>
<p>最终折腾完一圈，回到原点的时候，明白了需求分析而不是说走就走的重要。</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="1-Google-抓取重定向301"><a href="#1-Google-抓取重定向301" class="headerlink" title="1 - Google 抓取重定向301"></a>1 - Google 抓取重定向301</h3><p>在Google搜索site:lincentma.men，查找自己的网站是否被Google收录。</p>
<p>自己的在Google Search Console 中，自己添加了sitemap之后，尝试抓取网站页面，显示：</p>
<table>
<thead>
<tr>
<th><a href="http://lincentma.men/">http://lincentma.men/</a></th>
<th>请求编入索引</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Googlebot类型： 桌面</td>
</tr>
<tr>
<td></td>
<td>已重定向 抓取时间：2017年6月26日星期一 GMT-7 下午8:25:37</td>
</tr>
<tr>
<td></td>
<td>此网址已重定向至：<a href="https://lincentma.men/">https://lincentma.men/</a></td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 301 Moved Permanently</div><div class="line">Content-Type: application/x-gzip</div><div class="line">Location: https://lincentma.men/</div><div class="line">Server: Coding Pages</div><div class="line">Vary: Accept-Encoding</div><div class="line">Date: Tue, 27 Jun 2017 03:25:39 GMT</div><div class="line">Content-Length: 57</div></pre></td></tr></table></figure>
<p>导致在Google上没有自己博客更新的文章。</p>
<h4 id="原因：Coding-Pages-产生中间页"><a href="#原因：Coding-Pages-产生中间页" class="headerlink" title="原因：Coding Pages 产生中间页"></a>原因：Coding Pages 产生中间页</h4><p>从上面的HTTP响应头部的标志可以看出，Google重定向到了一个Coding Pages的服务商，也就是我双线同步博客的coding pages。</p>
<p>在其官网上我发现：</p>
<blockquote>
<p>银牌会员的 Coding Pages 在访问时默认会先加载 Pages 跳转页，您可选择在网站首页任意位置放置「Hosted by Coding Pages」的文字版或图片版，然后勾选下方的「已放置 Hosted by Coding Pages」选项，通过审核后您的 Pages 将不会显示跳转页。请务必将「Hosted by Coding Pages」持续保留在网站首页，撤掉后跳转页会再次出现。</p>
</blockquote>
<p>也就是没有银牌会员或者没有在博客上加载广告的时候，就会先跳转到中间页。Google在抓取页面的时候就会发现和目标地址不一致，导致抓取失败。所以没有免费的午餐。</p>
<h3 id="2-百度-HTTPS站点认证失败"><a href="#2-百度-HTTPS站点认证失败" class="headerlink" title="2 - 百度 HTTPS站点认证失败"></a>2 - 百度 HTTPS站点认证失败</h3><p>失败详情：您的站点有链接未通过https检验。</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>抓取操作不会跟踪重定向。如果您抓取的网页存在重定向，您将需要手动前往重定向到的网址。</li>
<li>301转向(或叫301重定向，301跳转)是当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。</li>
<li>302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。302 重定向会造成网址URL 劫持现象。</li>
<li>HTTP请求格式：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>请求头</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Host</strong></td>
<td>接受请求的服务器地址，可以是IP:端口号，也可以是域名</td>
</tr>
<tr>
<td><strong>User-Agent</strong></td>
<td>发送请求的应用程序名称</td>
</tr>
<tr>
<td><strong>Connection</strong></td>
<td>指定与连接相关的属性，如Connection:Keep-Alive</td>
</tr>
<tr>
<td><strong>Accept-Charset</strong></td>
<td>通知服务端可以发送的编码格式</td>
</tr>
<tr>
<td><strong>Accept-Encoding</strong></td>
<td>通知服务端可以发送的数据压缩格式</td>
</tr>
<tr>
<td><strong>Accept-Language</strong></td>
<td>通知服务端可以发送的语言</td>
</tr>
</tbody>
</table>
<ul>
<li>HTTP响应格式：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>响应头</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Server</strong></td>
<td>服务器应用程序软件的名称和版本</td>
</tr>
<tr>
<td><strong>Content-Type</strong></td>
<td>响应正文的类型（是图片还是二进制字符串）</td>
</tr>
<tr>
<td><strong>Content-Length</strong></td>
<td>响应正文长度</td>
</tr>
<tr>
<td><strong>Content-Charset</strong></td>
<td>响应正文使用的编码</td>
</tr>
<tr>
<td><strong>Content-Encoding</strong></td>
<td>响应正文使用的数据压缩格式</td>
</tr>
<tr>
<td><strong>Content-Language</strong></td>
<td>响应正文使用的语言</td>
</tr>
</tbody>
</table>
<ul>
<li><p>HTTPS：HTTPS 协议就是 HTTP+SSL/TLS，即在 HTTP 基础上加入 SSL /TLS 层，提供了内容加密、身份认证和数据完整性3大功能，目的就是为了加密数据，用于安全的数据传输。</p>
</li>
<li><p>其中一个问题：网站改用 HTTPS 以后，由 HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用 301、302 跳转）</p>
</li>
<li><p>[推荐文章]: <a href="http://support.upyun.com/hc/kb/article/1044299/" target="_blank" rel="external">http://support.upyun.com/hc/kb/article/1044299/</a></p>
</li>
</ul>
<ul>
<li>Google宣布了，从2017年1月份正式发布的Chrome 56开始，Google将把某些包含敏感内容的https页面标记为“不安全”。</li>
</ul>
<p>HTTPS是趋势，然而Github不支持自定义域名的强制HTTPS，Coding国内的必须加广告才能强制HTTPS且没有中间跳转页。所以自己就开始了折腾HTTPS的道路。</p>
<h2 id="折腾HTTPS："><a href="#折腾HTTPS：" class="headerlink" title="折腾HTTPS："></a>折腾HTTPS：</h2><h3 id="折腾：配置CloudFare失败"><a href="#折腾：配置CloudFare失败" class="headerlink" title="折腾：配置CloudFare失败"></a>折腾：配置CloudFare失败</h3><p>终究会有免费的午餐，那就是CloudFare。</p>
<h4 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h4><h4 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h4><ul>
<li><p>CloudFlare作为一家CDN提供商，他为免费用户提供的服务室不完整的，根据官网SSL服务的介绍，<strong>CloudFlare仅会在浏览器与CloudFlare的通讯中加密，CloudFlare与本地服务器的通讯本身并没有加密。</strong>这也是Flexible和Full模式的区别所在。</p>
</li>
<li><p>SSL：在客户端与服务器间传输的数据是通过使用对称算法（如 DES 或 RC4）进行加密的。公用密钥算法（通常为 RSA）是用来获得加密密钥交换和数字签名的，此算法使用服务器的SSL数字证书中的公用密钥。有了服务器的SSL数字证书，客户端也可以验证服务器的身份。SSL 协议的版本 1 和 2 只提供服务器认证。版本 3 添加了客户端认证，此认证同时需要客户端和服务器的数字证书。</p>
</li>
<li><p>关于Let&#39;s Encrypt：[给站点添加 https 小绿锁]: <a href="http://www.cnblogs.com/xinpureZhu/articles/lets-encrypt-to-add-https-site-little-green-lock.html" target="_blank" rel="external">http://www.cnblogs.com/xinpureZhu/articles/lets-encrypt-to-add-https-site-little-green-lock.html</a></p>
</li>
</ul>
<p>但是，都设置好了。然后就无法访问网页的了。DNS的锅。</p>
<p>发现阿里云的DNS修改后仍处于未更改的状态，即使CloudFlare显示Status：Active。</p>
<p>自己认为可能的是国外DNS被墙，或者是强制HTTPS生效时间过长导致没有及时生效。</p>
<h3 id="返回Coding-Pages-加广告"><a href="#返回Coding-Pages-加广告" class="headerlink" title="返回Coding Pages 加广告"></a>返回Coding Pages 加广告</h3><p>无奈返回去添加广告。</p>
<h4 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h4><ul>
<li>Hexo ，快速、简单且功能强大的 <a href="http://lib.csdn.net/base/nodejs" target="_blank" rel="external">Node.js</a> 博客框架。</li>
<li>页面布局</li>
<li>Hexo中自己感觉一个很有意思的特点是，在_config.yml以及md文件中，通过对于指定字段的true或者false的设置来实现功能，对于使用者来说是黑盒操作，降低了使用难度，提高了使用的体验。这是一种很好的方式。</li>
</ul>
<h3 id="阿里云更改域名配置"><a href="#阿里云更改域名配置" class="headerlink" title="阿里云更改域名配置"></a>阿里云更改域名配置</h3><p>买了一个域名：lincentma.men</p>
<p>参考文章：[hexo博客添加域名实现双线部署（github和coding)]: <a href="http://blog.csdn.net/qiuchengjia/article/details/52923156" target="_blank" rel="external">http://blog.csdn.net/qiuchengjia/article/details/52923156</a></p>
<h4 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h4><ul>
<li>域名解析就是国际域名或者国内域名以及中文域名等域名申请后做的到IP地址的转换过程。IP地址是网路上标识您站点的数字地址，为了简单好记，采用域名来代替ip地址标识站点地址。域名的解析工作由DNS服务器完成。</li>
<li>域名解析的A：A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。</li>
<li>域名解析的CNAME：别名记录。这种记录允许您将多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。</li>
<li>A记录就是把一个域名解析到一个<strong>IP地址</strong>（Address，特制数字IP地址），而CNAME记录就是把域名解析到另外一个<strong>域名</strong>。</li>
<li>还有MX记录（邮件记录）和NS记录（解析服务器记录，NS记录只对子域名生效）</li>
</ul>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>[ ] 站点地图的HTTPS是安全的，其他页面是信息不安全的，why？</li>
<li>[ ] Ngnix与SSL</li>
<li>[ ] 自己在Github博客申请SSL证书</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;记如何折腾让博客加HTTPS&quot;&gt;&lt;a href=&quot;#记如何折腾让博客加HTTPS&quot; class=&quot;headerlink&quot; title=&quot;记如何折腾让博客加HTTPS
    
    </summary>
    
      <category term="开发笔记" scheme="http://lincentma.men/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://lincentma.men/tags/hexo/"/>
    
      <category term="https" scheme="http://lincentma.men/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>【解析】Java Skills For Interview</title>
    <link href="http://lincentma.men/java_skills_for_interview.html"/>
    <id>http://lincentma.men/java_skills_for_interview.html</id>
    <published>2017-06-25T17:43:55.000Z</published>
    <updated>2017-06-26T07:25:20.279Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="【解析】Java-Skills-For-Interview"><a href="#【解析】Java-Skills-For-Interview" class="headerlink" title="【解析】Java Skills For Interview"></a>【解析】Java Skills For Interview</h1><blockquote>
<p>从网上偶得之，把每个函数弄明白，源码是怎么写的，为什么这么写。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//import不要使用通配符，需要import哪一个就import哪一个。</span></div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaSkillsForInterview</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="comment">// String</span></div><div class="line">        String s = <span class="string">"abc"</span>;</div><div class="line">        s.charAt(<span class="number">0</span>);<span class="comment">//返回指定索引处的 char 值。</span></div><div class="line">        s.length();<span class="comment">//返回此字符串的长度。</span></div><div class="line">        s.substring(<span class="number">0</span>, <span class="number">1</span>);<span class="comment">//返回字符串的子字符串。beginIndex - 起始索引（包括），endIndex - 结束索引（不包括）。左闭右开。</span></div><div class="line">        s.substring(<span class="number">1</span>);<span class="comment">//返回beginIndex - 起始索引（包括）到字符串末尾的子字符串。</span></div><div class="line">        s.equals(<span class="string">"b"</span>);<span class="comment">//将此字符串与指定的对象比较。</span></div><div class="line">        s = s.trim();<span class="comment">//返回字符串的副本，忽略前导空白和尾部空白。用于删除字符串的头尾空白符。</span></div><div class="line">        s.indexOf(<span class="string">"a"</span>);<span class="comment">//返回指定字符在此字符串中第一次出现处的索引。如果此字符串中没有这样的字符，则返回-1。</span></div><div class="line">        s.indexOf(<span class="string">"a"</span>, <span class="number">1</span>);<span class="comment">//返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</span></div><div class="line">        s.lastIndexOf(<span class="string">"a"</span>);<span class="comment">//返回指定字符在此字符串中最后一次出现处的索引。</span></div><div class="line">        s.lastindexOf(<span class="string">"a"</span>, <span class="number">1</span>);<span class="comment">//返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</span></div><div class="line">        s.toCharArray();<span class="comment">//【常用】将此字符串转换为一个新的字符数组。</span></div><div class="line">        Integer.valueOf(s); <span class="comment">// returns an Integer object，valueOf会返回一个Integer（整型）对象</span></div><div class="line">        <span class="comment">//【注意】Integer类有一个静态缓存，存储了256个特殊的Integer对象——每个对象分别对应`-128 和127之间的一个值。</span></div><div class="line">        <span class="comment">// Integer.valueOf("127")==Integer.valueOf("127");【true】</span></div><div class="line">        <span class="comment">// Integer.valueOf("128")==Integer.valueOf("128");【false】</span></div><div class="line">        Integer.parseInt(s); <span class="comment">// returns an int primitive， 将形参s转化为整数。Interger.parseInt("1")=1;</span></div><div class="line">        String.valueOf(s); <span class="comment">// integer to string 返回指定参数的字符串表示形式。</span></div><div class="line"></div><div class="line">        <span class="comment">// StringBuilder</span></div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        sb.append(<span class="string">"a"</span>);<span class="comment">//将指定的字符串追加到此字符序列。</span></div><div class="line">        sb.insert(<span class="number">0</span>, <span class="string">"a"</span>); <span class="comment">//在index指示的字符之前插入指定的字符串。</span></div><div class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>); <span class="comment">//在这个序列中的指定位置，此方法将删除字符。	</span></div><div class="line">        sb.reverse(); <span class="comment">//此方法会导致此字符序列被替换为该序列的反转序列。</span></div><div class="line">        sb.toString(); <span class="comment">//该方法返回一个字符串，它表示这个序列中的数据。</span></div><div class="line">        <span class="comment">//String 长度大小不可变</span></div><div class="line">        <span class="comment">//StringBuffer 和 StringBuilder 长度可变</span></div><div class="line">        <span class="comment">//StringBuffer 线程安全 StringBuilder 线程不安全</span></div><div class="line">        <span class="comment">//StringBuilder 速度快</span></div><div class="line">        </div><div class="line">        <span class="comment">// Array</span></div><div class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//初始化方式1</span></div><div class="line">        <span class="keyword">char</span>[] b = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>&#125;;<span class="comment">//初始化方式2</span></div><div class="line">        <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];<span class="comment">//二维数组</span></div><div class="line">        <span class="keyword">int</span> m = a.length;<span class="comment">//数组长度</span></div><div class="line">        <span class="keyword">int</span> n = c[<span class="number">0</span>].length;<span class="comment">//二维数组的列数</span></div><div class="line">        <span class="keyword">int</span> max = Integer.MAX_VALUE; <span class="comment">//MAX_VALUE = 0x7fffffff （Java语言规范规定int型为4字节）</span></div><div class="line">        <span class="keyword">int</span> min = Integer.MIN_VALUE; <span class="comment">//MIN_VALUE = 0x80000000</span></div><div class="line">        Arrays.sort(a);<span class="comment">//数组升序排序	（import java.util.Arrays;）int[]，double[]，char[]等基数据类型的数组，只提供了默认的升序排列，没有提供相应的降序排列方法。</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++) &#123;</div><div class="line">            System.out.println(c[i]);</div><div class="line">        &#125;<span class="comment">// 遍历数组输出元素</span></div><div class="line">        </div><div class="line">        <span class="comment">// List</span></div><div class="line">        <span class="comment">//List是一个接口，而ArrayList是一个类。 ArrayList继承并实现了List。 </span></div><div class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();<span class="comment">//List初始化</span></div><div class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">//ArrayList初始化</span></div><div class="line">        List&lt;List&lt;Integer&gt;&gt; list2 = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;(); <span class="comment">//而为List</span></div><div class="line">        list.add(<span class="number">0</span>);<span class="comment">//指定元素E追加到列表的末尾。此方法返回true。</span></div><div class="line">        list.add(<span class="number">0</span>, <span class="number">1</span>);<span class="comment">//方法将指定的元素E在此列表中的指定位置。此方法不返回任何值。</span></div><div class="line">        list.addAll(list1);<span class="comment">//方法会将所有指定集合中的元素添加到此列表的结尾。</span></div><div class="line">        list.get(<span class="number">0</span>);<span class="comment">//此方法返回在此列表中的指定位置的元素。</span></div><div class="line">        list.size();<span class="comment">//此方法返回此列表中的元素数。</span></div><div class="line">        list.remove(list.size() - <span class="number">1</span>);<span class="comment">//此方法返回从列表中移除的元素。</span></div><div class="line">        <span class="comment">//Collections是一个类而Collection是一个接口。</span></div><div class="line">        Collections.sort(list);<span class="comment">//方法用于指定列表按升序进行排序，根据其元素的自然顺序。</span></div><div class="line">        Collections.sort(list, Collections.reverseOrder());<span class="comment">//反序排列。</span></div><div class="line">        <span class="comment">//自定义排序。根据Collections.sort重载方法来实现。</span></div><div class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o1 - o2;<span class="comment">// 0-&gt;1</span></div><div class="line">                <span class="comment">// return o2 - o1; 1-&gt;0</span></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        <span class="comment">// Stack</span></div><div class="line">        <span class="comment">// import java.util.Stack;  </span></div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">        stack.push(<span class="number">0</span>);<span class="comment">//把项item压入栈顶，返回item参数。</span></div><div class="line">        stack.pop();<span class="comment">//返回位于堆栈顶部的元素，在这个过程中除去它。</span></div><div class="line">        stack.peek();<span class="comment">//返回到堆栈顶部的元素，但不会将其删除。</span></div><div class="line">        stack.isEmpty();<span class="comment">//栈是否为空。空返回true，否则false。</span></div><div class="line">        <span class="comment">// isEmpty() 和 empty()的区别：命名区别。</span></div><div class="line">        <span class="comment">// For example, it was named empty() in original class but was named isEmpty() of Collection interface.</span></div><div class="line">        stack.size(); <span class="comment">//栈中元素的个数。</span></div><div class="line">        stack.search(<span class="string">"code"</span>); <span class="comment">//此方法返回从1开始的位置，一个对象在栈中。栈顶位置为1。</span></div><div class="line">        </div><div class="line">        <span class="comment">// Queue add ‐‐‐‐‐‐&gt; remove, peek</span></div><div class="line">        <span class="comment">// import java.util.Queue;  import java.util.LinkedList;</span></div><div class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">        q.add(<span class="number">0</span>);<span class="comment">//增加一个元索。</span></div><div class="line">        q.remove();<span class="comment">//移除并返回队列头部的元素。</span></div><div class="line">        q.peek();<span class="comment">//返回队列头部的元素。</span></div><div class="line">        <span class="comment">//Queue使用也可以offer()来加入元素，使用poll()来获取并移出元素。</span></div><div class="line">        q.isEmpty();<span class="comment">//返回队列是否为空。</span></div><div class="line">        q.size();<span class="comment">//返回队列中元素的个数。</span></div><div class="line">        </div><div class="line">        <span class="comment">// HashMap</span></div><div class="line">        <span class="comment">// import java.util.HashMap;</span></div><div class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();<span class="comment">//初始化。</span></div><div class="line">        map.put(<span class="string">'c'</span>, <span class="number">1</span>);<span class="comment">//关联与此映射中的指定键指定的值。添加映射。</span></div><div class="line">        map.get(<span class="string">'c'</span>);<span class="comment">//返回指定键映射在此标识哈希映射，或者null，如果映射不包含此键的值。</span></div><div class="line">        <span class="keyword">if</span> (map.containsKey(<span class="string">'c'</span>)) &#123;<span class="comment">//如果此映射包含指定键的映射关系返回true。</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (map.containsValue(<span class="number">1</span>)) &#123;<span class="comment">//如果此映射一个或多个键映射到指定值返回true。</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (Character d : map.keySet()) &#123;<span class="comment">//遍历Hashmap的键集合。Set keySet()返回此映射中包含的键的set视图。</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (Integer i : map.values()) &#123;<span class="comment">//遍历Hashmap的值集合。Collection values()返回此映射中包含的值的collection视图。</span></div><div class="line">        &#125;</div><div class="line">        map.isEmpty();<span class="comment">//如果此映射不包含键 - 值映射关系返回true。</span></div><div class="line">        map.size();<span class="comment">//返回键 - 值映射关系在这个映射中的数量。</span></div><div class="line">        </div><div class="line">        <span class="comment">// HashSet</span></div><div class="line">        <span class="comment">// HashSet借助HashMap来实现的，利用HashMap中Key的唯一性，来保证HashSet中不出现重复值。</span></div><div class="line">        <span class="comment">// HashMap中的Key是根据对象的hashCode() 和 euqals()来判断是否唯一的。</span></div><div class="line">        <span class="comment">// import java.util.HashSet;</span></div><div class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();<span class="comment">//初始化。</span></div><div class="line">        set.add(<span class="number">0</span>);<span class="comment">//将指定的元素添加到此集合，如果它是不存在的。</span></div><div class="line">        set.remove(<span class="number">0</span>);<span class="comment">//从集合中删除指定的元素（如果存在）。</span></div><div class="line">        <span class="keyword">if</span> (set.contains(<span class="number">0</span>)) &#123;<span class="comment">//如果此set包含指定的元素，则返回true。</span></div><div class="line">        &#125;</div><div class="line">        set.isEmpty();<span class="comment">//返回true如果此set不包含任何元素。</span></div><div class="line">        set.size();<span class="comment">//返回元素的数目（它的基数）。</span></div><div class="line">        </div><div class="line">        <span class="comment">// mini heap</span></div><div class="line">        <span class="comment">// import java.util.PriorityQueue;</span></div><div class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();<span class="comment">//初始化。</span></div><div class="line">        pq.add(<span class="number">0</span>);<span class="comment">//该方法调用返回true(所指定的Collection.add(E))</span></div><div class="line">        pq.offer(<span class="number">0</span>);<span class="comment">//该方法调用返回true(所指定的Queue.offer(E))</span></div><div class="line">        pq.remove();<span class="comment">//该方法调用返回true，如果此队列由于调用而更改的结果。</span></div><div class="line">        pq.peek();<span class="comment">//在方法调用返回此队列的头部，或null，如果此队列为空。但它不会将其删除。</span></div><div class="line">        pq.poll();<span class="comment">//方法用于检索并移除此队列的头，则返回null，如果此队列为空。	</span></div><div class="line">        pq.isEmpty();<span class="comment">//判读是否为空。</span></div><div class="line">        pq.size();<span class="comment">//在方法调用返回的元素在此集合数</span></div><div class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="阿里巴巴Java开发规范"><a href="#阿里巴巴Java开发规范" class="headerlink" title="阿里巴巴Java开发规范"></a>阿里巴巴Java开发规范</h2><p><a href="http://orj5hqpmw.bkt.clouddn.com/4ce9918d7f5a082177a8a2741d0ab3ce.pdf" target="_blank" rel="external">阿里巴巴Java开发规范</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;【解析】Java-Skills-For-Interview&quot;&gt;&lt;a href=&quot;#【解析】Java-Skills-For-Interview&quot; class=&quot;hea
    
    </summary>
    
      <category term="开发笔记" scheme="http://lincentma.men/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://lincentma.men/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历那点事</title>
    <link href="http://lincentma.men/binary_tree_traversal.html"/>
    <id>http://lincentma.men/binary_tree_traversal.html</id>
    <published>2017-06-24T15:34:33.000Z</published>
    <updated>2017-06-24T16:06:53.106Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="二叉树遍历那点事"><a href="#二叉树遍历那点事" class="headerlink" title="二叉树遍历那点事"></a>二叉树遍历那点事</h1><blockquote>
<p>刷leetcode，碰见二叉树，看了一下午二叉树遍历，还在茫然着，写出来就明白了。好脑子不如烂笔头。</p>
</blockquote>
<h2 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Definition for binary tree</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</div><div class="line">    <span class="keyword">private</span> BinaryTreeNode left;</div><div class="line">    <span class="keyword">private</span> BinaryTreeNode right;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">(<span class="keyword">int</span> data, BinaryTreeNode left, BinaryTreeNode right)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">        <span class="keyword">this</span>.left = left;</div><div class="line">        <span class="keyword">this</span>.right = right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> left;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(BinaryTreeNode left)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.left = left;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(BinaryTreeNode right)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.right = right;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数组转换为二叉树"><a href="#数组转换为二叉树" class="headerlink" title="数组转换为二叉树"></a>数组转换为二叉树</h2><ul>
<li>二叉树上的元素存放位置在数组中是固定的。</li>
<li>如果树的i位置（从0开始按层编号）有元素，就放在数组的i号位置，没有元素，数组对应的位置就空着。i的左右子树的编号为2i+1和2i+2。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</div><div class="line"></div><div class="line">    BinaryTreeNode root;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> value;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> paraValue)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.value = paraValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        root = createBinaryTreeByArray(array, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">createBinaryTreeByArray</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        TreeNode tn = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (index &lt; array.length) &#123;</div><div class="line">            <span class="keyword">int</span> value = array[index];</div><div class="line">            tn = <span class="keyword">new</span> TreeNode(value);</div><div class="line">            tn.left = createBinaryTreeByArray(array, <span class="number">2</span> * index + <span class="number">1</span>);</div><div class="line">            tn.right = createBinaryTreeByArray(array, <span class="number">2</span> * index + <span class="number">2</span>);</div><div class="line">            <span class="keyword">return</span> tn;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> tn;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="递归与非递归"><a href="#递归与非递归" class="headerlink" title="递归与非递归"></a>递归与非递归</h2><p>一言以蔽之，非递归比递归难太多。</p>
<p>前序递归遍历算法：访问根结点–&gt;递归遍历根结点的左子树–&gt;递归遍历根结点的右子树<br>中序递归遍历算法：递归遍历根结点的左子树–&gt;访问根结点–&gt;递归遍历根结点的右子树<br>后序递归遍历算法：递归遍历根结点的左子树–&gt;递归遍历根结点的右子树–&gt;访问根结点</p>
<p>明白了思路，递归代码几行就能搞定了。</p>
<p>但是问题来了：</p>
<p>摘自知乎：</p>
<ul>
<li>递归是函数自身调用自身，涉及到保护现场（变量入栈，记录地址等），时间和空间开销较大，而这操作都是在栈上，调用层级太多很容易溢出。</li>
<li>迭代（非递归）虽然也是用栈，可是这个栈和递归栈可不是一个概念，这个栈完全可以在堆上开辟，空间更大，不容易溢出。迭代也不涉及函数调用，效率也更高。</li>
</ul>
<p>如何写出非递归的遍历呢？如何把手写遍历结果的过程用代码表达出来。</p>
<p>非递归方法需要借助栈</p>
<h2 id="前序二叉树"><a href="#前序二叉树" class="headerlink" title="前序二叉树"></a>前序二叉树</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>前序遍历的递归定义：先根节点，后左子树，再右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</div><div class="line">    System.out.print(root.val);</div><div class="line">    preOrder(root.getLeft());</div><div class="line">    preOrder(root.getRight());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><p>在手写结果的过程中，我们可以总结出以下规律：</p>
<ul>
<li>画出二叉树的图，输出顺序都是沿左下方向的直线，输出顺序LIFO，后进先出，满足栈的定义。</li>
<li>借助栈来保存节点，通过节点来打印右子树的数据。</li>
<li>只有入栈时才输出数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNonRecursive</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</div><div class="line">  Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="comment">//首先从根节点开始遍历所有的左子树，并输出节点数据</span></div><div class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</div><div class="line">      System.out.print(root.getData() + <span class="string">"\t"</span>);</div><div class="line">      stack.push(root);</div><div class="line">      root = root.getLeft();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//循环终止条件：栈容量为0，说明右子树以及遍历完全，跳出。</span></div><div class="line">    <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">break</span>;</div><div class="line">    <span class="comment">//当上面的while循环完成后，也就是左子树输出完成，栈弹出元素，也就是离得最近的有右子树的节点。</span></div><div class="line">    root = stack.pop();</div><div class="line">    <span class="comment">//返回循环，以该节点作为新的root循环输出。</span></div><div class="line">    root = root.getRight();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="中序二叉树"><a href="#中序二叉树" class="headerlink" title="中序二叉树"></a>中序二叉树</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>中序遍历的递归定义：先左子树，后根节点，再右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</div><div class="line">        inorder(root.nodeLeft);</div><div class="line">        System.out.print(root.val);</div><div class="line">        inorder(root.nodeRight);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h3><p>在手写结果的过程中，我们可以总结出以下规律：</p>
<ul>
<li>与先序类似，只不过输出数据的时机发生了改变。</li>
<li>出栈的时候输出数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderNonRecursive</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</div><div class="line">  Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="comment">//遍历左子树，并保存到栈中</span></div><div class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</div><div class="line">      stack.push(root);</div><div class="line">      root = root.getLeft();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遍历跳出条件</span></div><div class="line">    <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">break</span>;</div><div class="line">    <span class="comment">//当上面的while循环完成后，也就是左子树输出完成，栈弹出元素，也就是离得最近的有右子树的节点。</span></div><div class="line">    root = stack.pop();</div><div class="line">    <span class="comment">//根据中序遍历的输出顺序，先输出左子树的节点的值</span></div><div class="line">    System.out.print(root.getData() + <span class="string">"\t"</span>);</div><div class="line">    <span class="comment">//以最左下的节点为例，它的右节点为null，那么再次循环时，就会跳过遍历左子树的循环，栈出栈的节点为它的父节点，也就是根节点，输出其值，再转为其右子树，完成中序遍历的输出顺序。</span></div><div class="line">    root = root.getRight();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="后序二叉树"><a href="#后序二叉树" class="headerlink" title="后序二叉树"></a>后序二叉树</h2><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>后序遍历的递归定义：先左子树，后右子树，再根节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</div><div class="line">        postOrder(root.nodeLeft);</div><div class="line">        postOrder(root.nodeRight);</div><div class="line">        System.out.print(root.val);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="非递归-2"><a href="#非递归-2" class="headerlink" title="非递归"></a>非递归</h3><p>在手写结果的过程中，我们可以总结出以下规律：</p>
<ul>
<li>与前面区别在于，判读出栈时，要考虑该节点是否在之前已经访问过。</li>
<li>在stack中，最后添加的数据需要通过lastElement方法获取。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderNonRecursive</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</div><div class="line">    Stack&lt;BinaryTreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</div><div class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">        <span class="comment">//遍历左子树，并保存到栈中</span></div><div class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(root);</div><div class="line">            root=root.getLeft();</div><div class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//此时，当遍历到最左下的叶节点时，它的左子树是null。</span></div><div class="line">            <span class="comment">//后序遍历的顺序</span></div><div class="line">            <span class="keyword">if</span>(stack.isEmpty()) <span class="keyword">return</span>; <span class="comment">// 遍历终止条件1：栈空</span></div><div class="line">          </div><div class="line">            <span class="comment">//栈中最近添加的元素的右子树为空则弹出并输出该元素</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>==stack.lastElement().getRight())&#123;</div><div class="line">                root=stack.pop();</div><div class="line">                <span class="comment">//输出最开始左子树的叶节点，也就是遍历顺序中的左子树（以及代入的右子树值）</span></div><div class="line">                System.out.print(root.getData()+<span class="string">"\t"</span>);</div><div class="line">                <span class="comment">//while循环终止条件1：出栈后的最近添加的元素则为父节点的右子树与之前出栈的元素相等</span></div><div class="line">                <span class="keyword">while</span>(root==stack.lastElement().getRight())&#123;</div><div class="line">                    <span class="comment">//root（右子树遍历完成）与此时栈中的最近添加的元素（父节点）的右子树相等，那么说明lastElement为根节点</span></div><div class="line">                    <span class="comment">//输出根节点</span></div><div class="line">                    System.out.print(stack.lastElement().getData()+<span class="string">"\t"</span>);</div><div class="line">                    <span class="comment">//出栈（右子树的叶节点）</span></div><div class="line">                    root=stack.pop();</div><div class="line">                    <span class="comment">// while终止条件2：栈空</span></div><div class="line">                    <span class="keyword">if</span>(stack.isEmpty())&#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//栈不空，则root赋值为栈最近添加元素的右子树，开始从右子树继续遍历</span></div><div class="line">            <span class="keyword">if</span>(!stack.isEmpty())</div><div class="line">                root=stack.lastElement().getRight();</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="comment">//栈空，赋值为null，确保进入遍历结束条件判断的地方</span></div><div class="line">                root=<span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PS：感觉有点绕，stack.lastElement()这个也可以用pre节点来代替，这样可能更便于理解。</p>
<h2 id="非递归的统一化"><a href="#非递归的统一化" class="headerlink" title="非递归的统一化"></a>非递归的统一化</h2><p>非递归是否也可以像递归一样，只用修改语句的位置，实现不同方式的遍历呢？</p>
<p>答案是肯定的，大牛就是多。</p>
<ul>
<li><p>统一三种更简单的非递归遍历方法的基本思想：<strong>有重合元素的局部有序一定能导致整体有序</strong>。</p>
<p><img src="http://zisong.qiniudn.com/algorithm%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.png" alt="Alt text"></p>
</li>
</ul>
<ul>
<li>三种非递归遍历唯一不同的就是局部入栈的三行代码的先后顺序。所以不管是<code>根-&gt;左-&gt;右</code>,<code>左-&gt;根-&gt;右</code>,<code>左-&gt;右-&gt;根</code>,甚至是<code>根-&gt;右-&gt;左</code>,<code>右-&gt;根-&gt;左</code>,<code>右-&gt;左-&gt;根</code>定义的新顺序，算法实现都无变化，除了改变局部入栈顺序。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderTraversalNew</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">stack</span>&lt; pair&lt;TreeNode *, <span class="keyword">bool</span>&gt; &gt; s;</div><div class="line">    s.push(make_pair(root, <span class="literal">false</span>));</div><div class="line">    <span class="keyword">bool</span> visited;</div><div class="line">    <span class="keyword">while</span>(!s.empty())</div><div class="line">    &#123;</div><div class="line">        root = s.top().first;</div><div class="line">        visited = s.top().second;</div><div class="line">        s.pop();</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span>(visited)</div><div class="line">        &#123;</div><div class="line">            path.push_back(root-&gt;val);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            s.push(make_pair(root, <span class="literal">true</span>));</div><div class="line">            s.push(make_pair(root-&gt;right, <span class="literal">false</span>));</div><div class="line">            s.push(make_pair(root-&gt;left, <span class="literal">false</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PS: 有时间改写成Java版本的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2>]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;二叉树遍历那点事&quot;&gt;&lt;a href=&quot;#二叉树遍历那点事&quot; class=&quot;headerlink&quot; title=&quot;二叉树遍历那点事&quot;&gt;&lt;/a&gt;二叉树遍历那点事&lt;/h1
    
    </summary>
    
      <category term="开发笔记" scheme="http://lincentma.men/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="binary tree" scheme="http://lincentma.men/tags/binary-tree/"/>
    
      <category term="recursive" scheme="http://lincentma.men/tags/recursive/"/>
    
      <category term="iterate" scheme="http://lincentma.men/tags/iterate/"/>
    
  </entry>
  
  <entry>
    <title>Java、Python与PHP的虚拟机异同</title>
    <link href="http://lincentma.men/program_language_virtual_machine.html"/>
    <id>http://lincentma.men/program_language_virtual_machine.html</id>
    <published>2017-06-23T15:59:24.000Z</published>
    <updated>2017-06-23T16:07:27.662Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="Java-JVM"><a href="#Java-JVM" class="headerlink" title="Java-JVM"></a>Java-JVM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>JDK(Java Development Kit) 是 Java 语言的软件开发工具包（SDK）。JDK 物理存在，是 programming tools、JRE 和 JVM 的一个集合</li>
<li>JRE（Java Runtime Environment）Java 运行时环境，JRE 物理存在，主要由Java API 和 JVM 组成，提供了用于执行 java 应用程序最低要求的环境。</li>
<li>JVM(Java Virtual Machine) 是一种软件实现，执行像物理机程序的机器（即电脑）。JVM 通过执行 Java bytecode 可以使 java 代码在不改变的情况下运行在各种硬件之上。JVM是基于栈的。</li>
</ul>
<h3 id="JVM-执行"><a href="#JVM-执行" class="headerlink" title="JVM 执行"></a>JVM 执行</h3><ul>
<li>加载代码</li>
<li>验证代码</li>
<li>执行代码</li>
<li>提供运行环境</li>
</ul>
<h3 id="JVM-生命周期"><a href="#JVM-生命周期" class="headerlink" title="JVM 生命周期"></a>JVM 生命周期</h3><ul>
<li>启动：任何一个拥有main函数的class都可以作为JVM实例运行的起点</li>
<li>运行：main函数为起点，程序中的其他线程均有它启动，包括daemon守护线程和non-daemon普通线程。daemon是JVM自己使用的线程比如GC线程，main方法的初始线程是non-daemon。</li>
<li>消亡：所有线程终止时，JVM实例结束生命。</li>
</ul>
<h3 id="JVM结构及内存模型"><a href="#JVM结构及内存模型" class="headerlink" title="JVM结构及内存模型"></a>JVM结构及内存模型</h3><p><img src="http://upload-images.jianshu.io/upload_images/634730-089a64921220b40d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>名词解释：</p>
<ul>
<li>Class Loader：类加载器负责加载程序中的类型（类和接口），并赋予唯一的名字。为什么使用双亲委托模型——ClassLoader 隔离问题。</li>
<li>Execution Engine：执行引擎。执行引擎以指令为单位读取 Java 字节码。它就像一个 CPU 一样，一条一条地执行机器指令。</li>
<li>Runtime Data Areas:：运行时数据区。</li>
<li>PS：想起面试的时候被问到过这样的问题：你在使用java过程中是否遇到过OOM的情况？当时一阵懵比。现在总结下：<ul>
<li>PC寄存器（PC Register）是唯一一个在 Java 虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</li>
<li>JVM 栈（Java Virtual Machine Stack）：如果JVM Stack可以动态扩展，但是在尝试扩展时无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的虚拟机栈时抛出。</li>
<li>本地方法栈(Native method stack)：如果本地方法栈可以动态扩展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的本地方法栈，那Java虚拟机将会抛出一个OutOfMemoryError异常。</li>
<li>方法区(Method area)：如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。</li>
<li>运行时常量池(Runtime constant pool)：当创建类和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内存空间后就会抛出OutOfMemoryError</li>
<li>堆(Heap)：如果实际所需的堆超过了自动内存管理系统能提供的最大容量时抛出。</li>
<li>总结一下就是无法申请到足够的内存以及超出最大容量两方面原因</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p><img src="http://upload-images.jianshu.io/upload_images/2184951-327156d44f4f2446.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>新生代由 Eden 与 Survivor Space（S0，S1）构成，大小通过-Xmn参数指定，Eden 与 Survivor Space 的内存大小比例默认为8:1，可以通过-XX:SurvivorRatio 参数指定，比如新生代为10M 时，Eden分配8M，S0和S1各分配1M。</p>
<p>Eden：希腊语，意思为伊甸园，在圣经中，伊甸园含有乐园的意思，根据《旧约·创世纪》记载，上帝耶和华照自己的形像造了第一个男人亚当，再用亚当的一个肋骨创造了一个女人夏娃，并安置他们住在了伊甸园。</p>
<p>大多数情况下，对象在Eden中分配，当Eden没有足够空间时，会触发一次Minor GC，虚拟机提供了-XX:+PrintGCDetails参数，告诉虚拟机在发生垃圾回收时打印内存回收日志。</p>
<p>Survivor：意思为幸存者，是新生代和老年代的缓冲区域。<br>当新生代发生GC（Minor GC）时，会将存活的对象移动到S0内存区域，并清空Eden区域，当再次发生Minor GC时，将Eden和S0中存活的对象移动到S1内存区域。</p>
<p>存活对象会反复在S0和S1之间移动，当对象从Eden移动到Survivor或者在Survivor之间移动时，对象的GC年龄自动累加，当GC年龄超过默认阈值15时，会将该对象移动到老年代，可以通过参数-XX:MaxTenuringThreshold 对GC年龄的阈值进行设置。</p>
</li>
</ul>
<ul>
<li><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>老年代的空间大小即-Xmx 与-Xmn 两个参数之差，用于存放经过几次Minor GC之后依旧存活的对象。当老年代的空间不足时，会触发Major GC/Full GC，速度一般比Minor GC慢10倍以上。</p>
</li>
</ul>
<ul>
<li><h4 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h4><p>在JDK8之前的HotSpot实现中，类的元数据如方法数据、方法信息（字节码，栈和变量大小）、运行时常量池、已确定的符号引用和虚方法表等被保存在永久代中，32位默认永久代的大小为64M，64位默认为85M，可以通过参数-XX:MaxPermSize进行设置，一旦类的元数据超过了永久代大小，就会抛出OOM异常。</p>
<p>虚拟机团队在JDK8的HotSpot中，把永久代从Java堆中移除了，并把类的元数据直接保存在本地内存区域（堆外内存），称之为元空间。</p>
<p>这样做有什么好处？<br>有经验的同学会发现，对永久代的调优过程非常困难，永久代的大小很难确定，其中涉及到太多因素，如类的总数、常量池大小和方法数量等，而且永久代的数据可能会随着每一次Full GC而发生移动。</p>
<p>而在JDK8中，类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用内存空间，可以避免永久代的内存溢出问题，不过需要监控内存的消耗情况，一旦发生内存泄漏，会占用大量的本地内存。</p>
</li>
</ul>
<h4 id="判断垃圾回收"><a href="#判断垃圾回收" class="headerlink" title="判断垃圾回收"></a>判断垃圾回收</h4><ol>
<li><p>引用计数法：在对象上添加一个引用计数器，每当有一个对象引用它时，计数器加1，当使用完该对象时，计数器减1，计数器值为0的对象表示不可能再被使用。引用计数法实现简单，判定高效，但不能解决对象之间相互引用的问题。</p>
</li>
<li><p>可达性分析法：通过一系列称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，搜索路径称为 “引用链”，以下对象可作为GC Roots：</p>
<ul>
<li>本地变量表中引用的对象</li>
<li>方法区中静态变量引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>Native方法引用的对象</li>
</ul>
<p>当一个对象到 GC Roots 没有任何引用链时，意味着该对象可以被回收。</p>
</li>
</ol>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ol>
<li>标记-清除算法<br>对待回收的对象进行标记。<br>算法缺点：效率问题，标记和清除过程效率都很低；空间问题，收集之后会产生大量的内存碎片，不利于大对象的分配。</li>
<li>复制算法<br>复制算法将可用内存划分成大小相等的两块A和B，每次只使用其中一块，当A的内存用完了，就把存活的对象复制到B，并清空A的内存，不仅提高了标记的效率，因为只需要标记存活的对象，同时也避免了内存碎片的问题，代价是可用内存缩小为原来的一半。</li>
<li>标记-整理算法<br>在老年代中，对象存活率较高，复制算法的效率很低。在标记-整理算法中，标记出所有存活的对象，并移动到一端，然后直接清理边界以外的内存。</li>
</ol>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><p>[清蒸 JVM （一）]: <a href="http://www.importnew.com/23658.html" target="_blank" rel="external">http://www.importnew.com/23658.html</a></p>
</li>
<li><p>[Java GC的那些事（上）]: <a href="http://www.importnew.com/23633.html" target="_blank" rel="external">http://www.importnew.com/23633.html</a></p>
</li>
<li><p>[Java GC的那些事（下）]: <a href="http://www.importnew.com/23640.html" target="_blank" rel="external">http://www.importnew.com/23640.html</a></p>
</li>
</ol>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="PVM"><a href="#PVM" class="headerlink" title="PVM"></a>PVM</h3><p>PVM是Python的运行引擎。他通常表现为python系统的一部分。并且他是实际运行脚本的组件。</p>
<p>编译器：将源码编译成运行在虚拟机上执行的opcode(pyc文件)，pyc文件是在python虚拟机上执行的一种跨平台字节码。</p>
<p>运行时：虚拟机解释器把opcode(pyc文件)解释成具体机器的机器码，执行。</p>
<h3 id="JVM与PVM"><a href="#JVM与PVM" class="headerlink" title="JVM与PVM"></a>JVM与PVM</h3><ul>
<li>Java代码从源程序到执行，要经过的过程是：编译器(javac)把源代码转化为字节码，然后解释器（Java.exe）把字节码转换为计算机理解的机器码来执行。其中编译器和解释器都是Java虚拟机（JVM）的一部分，由于针对不同的硬件与OS，Java解释器有所不同，因此可以实现“一次编译、到处执行”。所以JVM是Java跨平台特性的关键所在。</li>
<li>对于Python，其源代码到执行也要经过如下过程：源代码—&gt;字节码—&gt;机器码。与Java不同的是，Python使用的虚拟机是基于其他语言实现的，比如我们一般使用的Python实际为Cpython，也就是其虚拟机由C实现，这个虚拟机负责把Python源码编译为字节码，再解释执行。另外，还有Jypython、Ironpython等。</li>
</ul>
<h2 id="PHP-Zend-amp-HHVM"><a href="#PHP-Zend-amp-HHVM" class="headerlink" title="PHP-Zend&amp;HHVM"></a>PHP-Zend&amp;HHVM</h2><p><img src="http://img.it-home.org/data/attachment/forum/2016pic3/20141226102950_924.jpg" alt=""></p>
<ul>
<li>Zend引擎默认做法，是先编译为opcode，然后再逐条执行，通常每条指令对应的是C语言级别的函数。如果我们产生大量重复的opcode（纯PHP写的代码和函数），对应的则是Zend多次逐条执行这些C代码。</li>
<li>HHVM生成和执行PHP的中间字节码（HHVM生成自己格式的中间字节码），执行时通过JIT（Just In Time，即时编译是种软件优化技术，指在运行时才会去编译字节码为机器码）转为机器码执行。JIT将大量重复执行的字节码在运行的时候编译为机器码，达到提高执行效率的目的。通常，触发JIT的条件是代码或者函数被多次重复调用。</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>时间匆忙，囫囵吞枣，努力完善。</p>
<p>后端开发离不开Java，python和php，深入学习原理，比较异同，最佳使用。</p>
<p>2017.06.23</p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Java-JVM&quot;&gt;&lt;a href=&quot;#Java-JVM&quot; class=&quot;headerlink&quot; title=&quot;Java-JVM&quot;&gt;&lt;/a&gt;Java-JVM&lt;/h2
    
    </summary>
    
      <category term="开发笔记" scheme="http://lincentma.men/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://lincentma.men/tags/java/"/>
    
      <category term="virtual machine" scheme="http://lincentma.men/tags/virtual-machine/"/>
    
      <category term="python" scheme="http://lincentma.men/tags/python/"/>
    
      <category term="php" scheme="http://lincentma.men/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>几个小问题的解答</title>
    <link href="http://lincentma.men/learn_for_some_questions.html"/>
    <id>http://lincentma.men/learn_for_some_questions.html</id>
    <published>2017-06-22T15:25:38.000Z</published>
    <updated>2017-06-22T15:43:43.699Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote>
<p>她给我提了一下几个问题，自己一眼看上去觉得简单，但是说不出来所以然，犯了眼高手低的毛病，记录自省。</p>
</blockquote>
<ul>
<li>[x] 一共10级楼梯，每次可以走一步或两步，求一共多少种走法。</li>
<li>[x] 一个细胞，一个小时分裂一次，生命周期是3小时，求n小时后容器内，有多少细胞。</li>
<li>[x] 斐波那契数列的实现。</li>
<li>[x] 递归算法的核心</li>
</ul>
<h1 id="Question1—走楼梯"><a href="#Question1—走楼梯" class="headerlink" title="Question1—走楼梯"></a>Question1—走楼梯</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>楼梯问题，一眼看上去，应该是一个递归问题跑不了了。</p>
<p>那么该如何递归，找到其中的规律呢？</p>
<p><strong><em>逆向思考。</em></strong></p>
<p>要想走到M(M=10)级,可以分为2种情况。 </p>
<ol>
<li>从m-2级迈两步 </li>
<li>从m-1级迈一步 </li>
</ol>
<p>那么对于m-2和m-1的情况也是各自分为两种，以此类推。</p>
<p>那么走法的和就是m-2的走法和m-1的走法之和。</p>
<p>那么递归到最基本的（当前人在第0阶台阶）</p>
<p>第0阶台阶：0</p>
<p>第1阶台阶：1</p>
<p>第2阶台阶：2（1+1或者2）</p>
<p>得到公式，也就是斐波那契数列。<br>$$<br>f(n)=f(n-1)+f(n-2)<br>$$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ml on 2017/6/21.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">taijie</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countNumber</span><span class="params">(<span class="keyword">int</span> stepsNum)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (stepsNum == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (stepsNum == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stepsNum == <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stepsNum &gt; <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span>  countNumber(stepsNum - <span class="number">2</span>) + countNumber(stepsNum - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startMili=System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</div><div class="line">            System.out.println(<span class="string">"楼梯台阶数:"</span> + i + <span class="string">", 走法有:"</span> + countNumber(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> endMili=System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"耗时:"</span> + String.valueOf(endMili - startMili) + <span class="string">"毫秒"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">楼梯台阶数:0, 走法有:0</div><div class="line">楼梯台阶数:1, 走法有:1</div><div class="line">楼梯台阶数:2, 走法有:2</div><div class="line">楼梯台阶数:3, 走法有:3</div><div class="line">楼梯台阶数:4, 走法有:5</div><div class="line">楼梯台阶数:5, 走法有:8</div><div class="line">楼梯台阶数:6, 走法有:13</div><div class="line">楼梯台阶数:7, 走法有:21</div><div class="line">楼梯台阶数:8, 走法有:34</div><div class="line">楼梯台阶数:9, 走法有:55</div><div class="line">楼梯台阶数:10, 走法有:89</div><div class="line">耗时:0毫秒</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure>
<h2 id="其他的方法"><a href="#其他的方法" class="headerlink" title="其他的方法"></a>其他的方法</h2><p>该算法的运算时间是指数级增长的，还有其他方法吗？</p>
<p>动态规划？</p>
<p>其实动态规划（dynamicprogramming）是通过组合子问题而解决整个问题的解。乍一看和递归的写法差不多，都是相加。但是递归式是包含了许多重复计算的步骤，对应台阶就是每一个台阶计算前面都是重复的。动态规划<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="external">算法</a>对每个子问题只求解一次，将其结果保存起来，从而避免每次遇到各个子问题时重新计算答案。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ml on 2017/6/21.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">taijie</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> n;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//注意坐标起始点的区别</span></div><div class="line">        <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">        r[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">        r[<span class="number">2</span>] = <span class="number">2</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</div><div class="line">            r[i] = r[i-<span class="number">1</span>] + r[i-<span class="number">2</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> r[n];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startMili=System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</div><div class="line">            System.out.println(<span class="string">"楼梯台阶数:"</span> + i + <span class="string">", 走法有:"</span> + climbStairs(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> endMili=System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"耗时:"</span> + String.valueOf(endMili - startMili) + <span class="string">"毫秒"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">楼梯台阶数:0, 走法有:0</div><div class="line">楼梯台阶数:1, 走法有:1</div><div class="line">楼梯台阶数:2, 走法有:2</div><div class="line">楼梯台阶数:3, 走法有:3</div><div class="line">楼梯台阶数:4, 走法有:5</div><div class="line">楼梯台阶数:5, 走法有:8</div><div class="line">楼梯台阶数:6, 走法有:13</div><div class="line">楼梯台阶数:7, 走法有:21</div><div class="line">楼梯台阶数:8, 走法有:34</div><div class="line">楼梯台阶数:9, 走法有:55</div><div class="line">楼梯台阶数:10, 走法有:89</div><div class="line">耗时:0毫秒</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure>
<p>之前数学课本上如何思考的？</p>
<ol>
<li>先求出走完台阶需要几步？</li>
<li>再求出总步数中，走一个台阶是几步，走两个台阶式几步，不同种类为排列组合计算</li>
</ol>
<h2 id="类似问题"><a href="#类似问题" class="headerlink" title="类似问题"></a>类似问题</h2><p>再看一个硬币的凑法：</p>
<blockquote>
<p>用1分、2分和5分的硬币凑成1元，共有多少种不同的凑法？（华为机试题）</p>
</blockquote>
<p>它和走楼梯的区别在于，楼梯不同顺序是不同的走法，硬币则与顺序无关，程序可用穷举法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">coin</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getKinds</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> num=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">21</span>; i++) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">100</span>-<span class="number">5</span>*i; j++) &#123;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">100</span>-<span class="number">5</span>*i-<span class="number">2</span>*j; k++) &#123;</div><div class="line">					<span class="keyword">if</span>(<span class="number">5</span>*i+<span class="number">2</span>*j+k==<span class="number">100</span>)&#123;</div><div class="line">						num++;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> num;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(getKinds());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么这个问题可以推广为一般性问题吗？M阶，一次走a阶或者b阶或者。。。，求不同走法。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><h1 id="Question2—细胞分裂"><a href="#Question2—细胞分裂" class="headerlink" title="Question2—细胞分裂"></a>Question2—细胞分裂</h1><h2 id="非递归思路"><a href="#非递归思路" class="headerlink" title="非递归思路"></a>非递归思路</h2><p>乍一看，关键是如何处理生命周期是3小时。如何在分裂的同时提出死亡的细胞。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ml on 2017/6/22.</div><div class="line"> * 思路：每个细胞定义为一维数组的元素，元素的值为细胞的生存时间，每分裂一次，在数组末尾添加新的元素，初始值为0，同时原来的元素值加1</div><div class="line"> * 当元素的值为3时，将该元素剔除</div><div class="line"> * 最后返回该数组的大小</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xibao</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cellNum2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; cell = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="comment">//定义cellnum</span></div><div class="line">        <span class="keyword">int</span> cellnum = <span class="number">0</span>;</div><div class="line">        <span class="comment">//加入初始细胞</span></div><div class="line">        cell.add(<span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="comment">//记录当前数组大小（剔除完成后的数组）</span></div><div class="line">            <span class="keyword">int</span> size = cell.size();</div><div class="line">            <span class="comment">//计算分裂后新的数组的大小</span></div><div class="line">            cellnum = <span class="number">2</span> * cell.size();</div><div class="line">            <span class="comment">//原有生存时间加1</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cell.size(); j++) &#123;</div><div class="line">                cell.set(j, cell.get(j) + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//遍历剔除元素值为3 PS：ArrayList中遍历可以删除的只有迭代器</span></div><div class="line">            Iterator&lt;Integer&gt; it = cell.iterator();</div><div class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">                <span class="keyword">if</span> (it.next().equals(<span class="number">3</span>))</div><div class="line">                    it.remove();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//在数组末尾添加新的元素</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = size; j &lt; cellnum; j++) &#123;</div><div class="line">                cell.add(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cell.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cellNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">        HashMap&lt;Integer, Integer&gt; cell = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> cellnum = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">            cellnum *= <span class="number">2</span>;</div><div class="line">            <span class="keyword">int</span> size = cell.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = size; j &lt; cellnum; j++) &#123;</div><div class="line">                cell.put(j, <span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">            Iterator&lt;HashMap.Entry&lt;Integer, Integer&gt;&gt; iter = cell.entrySet().iterator();</div><div class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">                Map.Entry entry = iter.next();</div><div class="line">                <span class="keyword">int</span> key = (<span class="keyword">int</span>) entry.getKey();</div><div class="line">                <span class="keyword">int</span> val = (<span class="keyword">int</span>) entry.getValue();</div><div class="line">                <span class="keyword">if</span> (key &lt; size) &#123;</div><div class="line">                    cell.put(key, val + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cell.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startMili = System.currentTimeMillis();</div><div class="line">        <span class="keyword">int</span> n = <span class="number">6</span>;</div><div class="line">        System.out.println(n + <span class="string">"小时后容器细胞:"</span> + cellNum2(n) + <span class="string">"个"</span>);</div><div class="line">        <span class="keyword">long</span> endMili = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"耗时:"</span> + String.valueOf(endMili - startMili) + <span class="string">"毫秒"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">3小时后容器细胞:7个</div><div class="line">耗时:0毫秒</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure>
<h3 id="关于ArrayList"><a href="#关于ArrayList" class="headerlink" title="关于ArrayList"></a>关于ArrayList</h3><ol>
<li>迭代器是作为当前集合的内部类实现的，当迭代器创建的时候保持了当前集合的引用；</li>
<li>集合内部维护一个字段叫modiCount，用来记录集合被修改的次数，比如add，remove，set等都会使该字段递增；</li>
<li>迭代器内部也维护着当前集合的修改次数的字段，迭代器创建时该字段初始化为集合的modiCount值</li>
<li>当每一次迭代时，迭代器会比较迭代器维护的字段和modiCount的值是否相等，如果不相等就抛ConcurrentModifiedException异常；</li>
<li>当然，如果用迭代器调用remove方法，那么集合和迭代器维护的修改字数都会递增，以保持两个状态的一致。</li>
</ol>
<p>这就是为什么你只可以用迭代器来删除，而不能用其他方式来修改集合。</p>
<h2 id="这类问题如何递归？"><a href="#这类问题如何递归？" class="headerlink" title="这类问题如何递归？"></a>这类问题如何递归？</h2><p>公式法：<br>$$<br>n=t/a<del>~</del><del>~</del>~~y=2^n<br>$$<br>但是这个只适用于最简单的没有任何附加状态条件的情况。</p>
<p>递归如何来分析？</p>
<p>细胞的生存周期是3个小时，那我们就可以把细胞在题目中状态分为以下几个状态：</p>
<ul>
<li>a：刚分裂态——1</li>
<li>b：分裂1小时态——a分裂出b和a</li>
<li>c：分裂2小时态——b分裂出c和a</li>
<li>d：分裂3小时态——死亡（停止分裂）</li>
</ul>
<p>那么，我们就可以根据细胞状态设定函数。分析每一个状态的来源是哪里即可。<br>$$<br>a(t)=a(t-1)+b(t-1)+c(t-1)\\b(t)=a(t-1)\\c(t)=b(t-1)\\d(t)=d(t-1)+c(t-1)<br>$$<br>容器中存活的细胞数目就是a、b、c三种状态数量的总和。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ml on 2017/6/22.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xibao</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aStatus</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (t == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> aStatus(t - <span class="number">1</span>) + bStatus(t - <span class="number">1</span>) + cStatus(t - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bStatus</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (t == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> aStatus(t-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cStatus</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (t == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bStatus(t-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dStatus</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (t == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (t == <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dStatus(t-<span class="number">1</span>) + cStatus(t-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startMili = System.currentTimeMillis();</div><div class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</div><div class="line">        <span class="keyword">int</span> res = aStatus(n) + bStatus(n) + cStatus(n);</div><div class="line">        System.out.println(n + <span class="string">"小时后容器细胞:"</span> + res + <span class="string">"个"</span>);</div><div class="line">        <span class="keyword">long</span> endMili = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"耗时:"</span> + String.valueOf(endMili - startMili) + <span class="string">"毫秒"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">3小时后容器细胞:7个</div><div class="line">耗时:0毫秒</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure>
<h2 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h2><h1 id="Question3—Fibonacci数列"><a href="#Question3—Fibonacci数列" class="headerlink" title="Question3—Fibonacci数列"></a>Question3—Fibonacci数列</h1><p>经典问题：求Fibonacci数列前n项。<br>$$<br>{an}：a1=1，a2=1，a_{n+2}=a_{n+1}+a_n（n≥1）。<br>$$</p>
<p>PS: Markdown 中公式书写规则</p>
<ul>
<li><code>\\</code>符号后接的字符为上标</li>
<li><code>^</code>符号后接的字符为上标 </li>
<li><code>_</code>符号后接的字符为下标 </li>
<li>如果同时有两个下标，则需要使用<code>{}</code>来将符号括起来</li>
</ul>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fab</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++)&#123;</div><div class="line">            System.out.print(recursion(i) + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++)&#123;</div><div class="line">            System.out.print(loop(i) + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 递归</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> recursion(n -<span class="number">1</span>) + recursion(n -<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 循环</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">loop</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> s1 = <span class="number">1</span>,s2 = <span class="number">1</span>, sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n - <span class="number">2</span>; i ++)&#123;</div><div class="line">            sum = s1 + s2;</div><div class="line">            s1 = s2;</div><div class="line">            s2 = sum;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1 1 2 3 5 8 13 21 34 </div><div class="line">1 1 2 3 5 8 13 21 34 </div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure>
<p>值得注意的是（递归方法有栈溢出的风险）。</p>
<h2 id="参考文章-2"><a href="#参考文章-2" class="headerlink" title="参考文章"></a>参考文章</h2><h1 id="Question4—递归核心"><a href="#Question4—递归核心" class="headerlink" title="Question4—递归核心"></a>Question4—递归核心</h1><p>那么总结一下，递归算法的核心是什么呢？</p>
<p>那就是：</p>
<ul>
<li><strong><em><u>在有限次可预见性结果中，找到结果与上一次结果之间的关系。</u></em></strong></li>
<li>f(n)与f(n-1)的关系有时候很简单，如同走楼梯，状态单一；又有时如同细胞分裂，多种状态组合影响结果。</li>
<li>关键在于梳理清楚本次结果和上一次结果的关系有哪些方面或是因素，刚开始看的时候可能会很乱。</li>
<li>在草稿纸上写出前几次的结果，或者画图，这样更容易找到规律，这种规律实际上就是递归方程。</li>
<li><strong>*在算法的分析中，当一个算法中包含递归调用时，其时间复杂度的分析会转化成为一个递归方程的求解。而对递归方程的求解，方法多种多样，不一而足。</strong></li>
</ul>
<p>动态规划就是在递归的基础上，保存每一步的数据，避免重复计算。<br>在递归计算调用次数过多时，可以考虑更换其他方法解答。</p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;她给我提了一下几个问题，自己一眼看上去觉得简单，但是说不出来所以然，犯了眼高手低的毛病，记录自省。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;
    
    </summary>
    
      <category term="开发笔记" scheme="http://lincentma.men/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://lincentma.men/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Rank小记</title>
    <link href="http://lincentma.men/learn_rank.html"/>
    <id>http://lincentma.men/learn_rank.html</id>
    <published>2017-06-21T04:13:27.000Z</published>
    <updated>2017-06-22T03:16:46.299Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><pre><code>搜索引擎，你每天用的，知其然，不知其所以然。
                                        ——读《搜索引擎 : 信息检索实践》
</code></pre><h2 id="信息检索的定义"><a href="#信息检索的定义" class="headerlink" title="信息检索的定义"></a>信息检索的定义</h2><p>信息检索是关于信息的结构、分析、组织、存储、搜索和检索的领域——Gerard Salton</p>
<h2 id="搜索引擎的指标"><a href="#搜索引擎的指标" class="headerlink" title="搜索引擎的指标"></a>搜索引擎的指标</h2><p>处理数十亿网页的商业化网络搜索引擎时代的今天，搜索引擎的指标体现在以下五个方面：</p>
<ol>
<li>全</li>
<li>新</li>
<li>准</li>
<li>快</li>
<li>稳</li>
</ol>
<p>其中Rank的目标就是准</p>
<h2 id="Rank"><a href="#Rank" class="headerlink" title="Rank"></a>Rank</h2><p>如何所搜即所得是Rank的目的。</p>
<ul>
<li>海量网页快速排序</li>
<li>相关性：搜索结果与用户需求的匹配程度 </li>
</ul>
<ol>
<li>多样性（Query对应多个结果，通过用户行为数据进行选择和匹配）</li>
<li>权威性（被引用次数，链接分析。类似于学术文章的因子。）</li>
<li>时效性（Query的频次随时间的变化趋势）</li>
<li>个性化（构建用户个人数据，计算结果与用户喜好匹配程度）</li>
<li>用户成本</li>
</ol>
<h3 id="如何排序"><a href="#如何排序" class="headerlink" title="如何排序"></a>如何排序</h3><p>自己的理解，排序就是算分，按照分数来进行排序，key是算分。</p>
<blockquote>
<p>经典IR模型:TF-IDF是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。<br>距离特征</p>
<p>Boolean Model：布尔（Boolean）模型是基于集合论和布尔代数的一种简单检索模型。它的特点是查找那些于某个查询词返回为“真”的文档。在该模型中，一个查询词就是一个布尔表达式，包括关键词以及逻辑运算符。通过布尔表达式，可以表达用户希望文档所具有的特征。</p>
<p>Vetor-Space:VSM概念简单，把对文本内容的处理简化为向量空间中的向量运算，并且它以空间上的相似度表达语义的相似度，直观易懂。当文档被表示为文档空间的向量，就可以通过计算向量之间的相似性来度量文档间的相似性。文本处理中最常用的相似性度量方式是余弦距离</p>
</blockquote>
<h3 id="Rank关键技术"><a href="#Rank关键技术" class="headerlink" title="Rank关键技术"></a>Rank关键技术</h3><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>在线计算转为离线计算<br>分布式计算系统</p>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>辣鸡信息：找出特征，计算分数，剔除。</p>
<h4 id="人工识别与机器学习。"><a href="#人工识别与机器学习。" class="headerlink" title="人工识别与机器学习。"></a>人工识别与机器学习。</h4><p>Learning to Rank</p>
<p>找了一些文档博客，慢慢学习~</p>
<p>Point-Wise：RankSVM<br>Pair-Wise：RankNet<br>List-Wise：RankForest</p>
<p><em>努力学算法一定可以搞懂的！</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;pre&gt;&lt;code&gt;搜索引擎，你每天用的，知其然，不知其所以然。
                                        ——读《搜索引擎 : 信息检索实
    
    </summary>
    
      <category term="intern" scheme="http://lincentma.men/categories/intern/"/>
    
    
      <category term="rank" scheme="http://lincentma.men/tags/rank/"/>
    
  </entry>
  
  <entry>
    <title>为找工作而准备着</title>
    <link href="http://lincentma.men/prepare_for_work.html"/>
    <id>http://lincentma.men/prepare_for_work.html</id>
    <published>2017-06-17T08:57:30.000Z</published>
    <updated>2017-06-22T03:15:06.575Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="为找工作而准备着"><a href="#为找工作而准备着" class="headerlink" title="为找工作而准备着"></a>为找工作而准备着</h1><h2 id="行业了解"><a href="#行业了解" class="headerlink" title="行业了解"></a>行业了解</h2><p>互联网+行业——改变传统行业</p>
<p>未来的行业是属于数据驱动的行业：</p>
<ul>
<li>物流行业（快递物流数据），物流成本仍有巨大空间优化</li>
<li>金融行业（金融数据），普惠金融有广阔的空间</li>
<li>电商行业（交易数据），定制化，差异化，个性化会随着物质条件的不断提高而不断重要</li>
<li>视频行业（视频数据），视频对于文件具有更有效地传播</li>
<li>农业（作物，天气等数据），高品质农业作物的需求不断上升，小作坊式模式对于行情波动的适应性有巨大的改善空间</li>
<li>云（云数据），理论上任何公司的数据都可以上云来进行弹性管理，提高效率</li>
<li>新兴科技（新兴技术），探索无止境，更多广阔的市场是由新兴技术所开创</li>
</ul>
<h2 id="公司了解"><a href="#公司了解" class="headerlink" title="公司了解"></a>公司了解</h2><ul>
<li>物流行业：菜鸟物流</li>
<li>金融行业：蚂蚁金融、支付宝、微信支付</li>
<li>电商行业：阿里巴巴、京东、美团点评、网易严选考拉</li>
<li>视频行业：今日头条、腾讯视频、B站</li>
<li>农业：网易未央、京东、联想农业</li>
<li>云：阿里云、腾讯云</li>
<li>新兴科技：大疆科技</li>
</ul>
<h2 id="部门了解"><a href="#部门了解" class="headerlink" title="部门了解"></a>部门了解</h2><ul>
<li>技术营销：通过基础数据分析，找到赋能新方法</li>
<li>基础研发：如何让数据更加适合的展现</li>
<li>产品研发：如何研发用用户不易察觉的方式解决用户痛点的产品</li>
<li>内部研发：研发如何提高开发效率的工具</li>
</ul>
<h2 id="技术栈了解"><a href="#技术栈了解" class="headerlink" title="技术栈了解"></a>技术栈了解</h2><p><strong>Unix/Linux</strong></p>
<p>后端必须掌握的操作系统。<br>建议的书籍：《Linux编程》《Unix环境高级编程》</p>
<p><strong>网络编程</strong></p>
<p>建议书籍：《Unix网络编程》《TCP/IP协议详解》</p>
<p><strong>脚本语言</strong><br>PHP、Python深入学习。</p>
<p><strong>数据库</strong></p>
<p>无论是关系型数据库还是非关系型数据库，都是必须要吃透牢牢掌握的东西</p>
<h2 id="工作使命感"><a href="#工作使命感" class="headerlink" title="工作使命感"></a>工作使命感</h2><p>互联网的技术日新月异的目标就是让人们更加方面的获取一切，享受科技带来的便利；</p>
<p>不可否认互联网技术同样是一把双刃剑，人们在低成本享受的同时，同时也会出现键盘侠、恶意抹黑、舆论控制等让社会阴暗面放大的趋势。</p>
<p>如同微博让人们无所不谈，同时也会有水军，造谣；大疆无人机让我们获得前所未有的影像视角，同时也被用于装备军队送上战场。</p>
<p>在致力于互联网技术和产品不断发展的同时，同时还需要致力于让技术和产品如何正确地服务于人，而避免用于歧途。</p>
<p><em>数据亦然，发掘数据蕴含的价值创造正能量价值，尽所能。</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;为找工作而准备着&quot;&gt;&lt;a href=&quot;#为找工作而准备着&quot; class=&quot;headerlink&quot; title=&quot;为找工作而准备着&quot;&gt;&lt;/a&gt;为找工作而准备着&lt;/h1
    
    </summary>
    
      <category term="job" scheme="http://lincentma.men/categories/job/"/>
    
    
      <category term="job" scheme="http://lincentma.men/tags/job/"/>
    
  </entry>
  
  <entry>
    <title>在百度实习的日子</title>
    <link href="http://lincentma.men/internship_in_baidu.html"/>
    <id>http://lincentma.men/internship_in_baidu.html</id>
    <published>2017-06-17T08:57:10.000Z</published>
    <updated>2017-06-22T03:16:19.535Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="在百度实习的日子"><a href="#在百度实习的日子" class="headerlink" title="在百度实习的日子"></a>在百度实习的日子</h1><blockquote>
<p>转眼从百度离开回到了在学校的日子。也应该记录下自己在帝都，在百度的255天。</p>
</blockquote>
<h2 id="在百度糯米"><a href="#在百度糯米" class="headerlink" title="在百度糯米"></a>在百度糯米</h2><p>在百度糯米第一次接触了规范的开发流程，公司庞大的知识储备库，让自己如同海绵一样广泛吸水般吸收知识。有非常nice团队来让我迅速适应这样的开发环境，让我熟悉开发流程，带我一起和产品交流、和运营交流、和测试交流。</p>
<h2 id="在百度搜索"><a href="#在百度搜索" class="headerlink" title="在百度搜索"></a>在百度搜索</h2><p>在百度搜索我接触到了搜索是如何运转，自己尝试接触Sug的海量数据进行数据分析监控，第一次理解亲身理解大数据所蕴含的价值。<br>一次次的技术分享，让我更加深刻理解百度搜索里面的核心技术的深度，自己仍有很长的路要走。</p>
<h2 id="在百度"><a href="#在百度" class="headerlink" title="在百度"></a>在百度</h2><p>目前为止我见过最好的办公环境，nice的伙食，健身设备，班车交通，让我每个周末也来公司给自己充电。<br>每天的问好，晚上的坐上班车返回住所，每一天任务的完成带给自己的充实感让自己不断向前。<br>体验过996，体验过封闭开发，体验过部门内分享，体验过酸甜苦辣。<br>感谢百度，感谢曾经的同事，感谢让自己不断成长。</p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;在百度实习的日子&quot;&gt;&lt;a href=&quot;#在百度实习的日子&quot; class=&quot;headerlink&quot; title=&quot;在百度实习的日子&quot;&gt;&lt;/a&gt;在百度实习的日子&lt;/h1
    
    </summary>
    
      <category term="intern" scheme="http://lincentma.men/categories/intern/"/>
    
    
      <category term="intern" scheme="http://lincentma.men/tags/intern/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之重新初始化</title>
    <link href="http://lincentma.men/hexo_init.html"/>
    <id>http://lincentma.men/hexo_init.html</id>
    <published>2017-06-15T07:04:32.000Z</published>
    <updated>2017-06-25T18:25:43.666Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>站在巨人的肩膀上，搭建Hexo，事半功倍。但是巨人太多，选择好的巨人很重要，不然就不得其法，回到原点。</p>
<h2 id="Hexo参考文档"><a href="#Hexo参考文档" class="headerlink" title="Hexo参考文档"></a>Hexo参考文档</h2><ul>
<li>[NexT]:  <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">http://theme-next.iissnan.com/getting-started.html</a>    “NexT”</li>
<li>[NexT优化]:  <a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="external">http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html</a></li>
</ul>
<h2 id="Hexo搭建问题记录"><a href="#Hexo搭建问题记录" class="headerlink" title="Hexo搭建问题记录"></a>Hexo搭建问题记录</h2><ul>
<li>多说评论替换</li>
<li>背景效果</li>
<li>腾讯云搭建Hexo</li>
</ul>
<h2 id="Hexo-性能优化"><a href="#Hexo-性能优化" class="headerlink" title="Hexo 性能优化"></a>Hexo 性能优化</h2><ul>
<li>[hexo博客进阶－性能优化]:  <a href="https://www.liuxinggang.com/2016-12-06-hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%8D%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" target="_blank" rel="external">https://www.liuxinggang.com/2016-12-06-hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%8D%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</a></li>
</ul>
<p>自己更换电脑，没有保存Hexo的源文件，借此机会重新部署学习，完善自己的博客。</p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;站在巨人的肩膀上，搭建Hexo，事半功倍。但是巨人太多，选择好的巨人很重要，不然就不得其法，回到原点。&lt;/p&gt;
&lt;h2 id=&quot;Hexo参考文档&quot;&gt;&lt;a href=&quot;#Hex
    
    </summary>
    
      <category term="教程" scheme="http://lincentma.men/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="http://lincentma.men/tags/hexo/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LincentMa&#39;s Blog</title>
  <subtitle>编程卖土豆</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lincentma.men/"/>
  <updated>2017-09-28T03:12:17.133Z</updated>
  <id>http://lincentma.men/</id>
  
  <author>
    <name>LicentMa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>海康威视一面记录</title>
    <link href="http://lincentma.men/hikvision_interview.html"/>
    <id>http://lincentma.men/hikvision_interview.html</id>
    <published>2017-09-28T03:10:49.000Z</published>
    <updated>2017-09-28T03:12:17.133Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><pre><code># 海康威视一面记录

&gt; 面试中记录显示了自己的深度的不足，敬佩面试官对于技术深度以及开源项目的态度。

## 1. 手撕SQL：两张表（薪水表、部门表）求每一个部门薪水前三的结果

该Employee表包含所有员工。每个员工都有一个ID，并且还有一个部门ID的列。

| Id | Name| salary| DepartmentId |
|--|--|--|--|
| 1 | 乔| 70000 | 1 |
| 2 | 亨利| 80000 | 2 |
| 3 | 山姆| 60000 | 2 |
| 4 | Max | 90000 | 1 |
| 5 | 珍妮特| 69000 | 1 |
| 6 | 兰迪| 85000 | 1 |
该Department表包含公司的所有部门。

| Id | Department|
|--|--|
| 1 | IT |
| 2 | 销售|
编写一个SQL查询来查找每个部门获得前三名薪水的员工。对于上述表，您的SQL查询应返回以下行。

| Department| employeeName| Salary|
|--|--|--|
| IT | Max | 90000 |
| IT | 兰迪| 85000 |
| IT | 乔| 70000 |
| 销售| 亨利| 80000 |
| 销售| 山姆| 60000 |

&gt; 解题思路：

&gt; 自己当时想法简单直接，直接大笔一挥inner join，group by，order by，limit全部堆上去，too样toosimple。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">d.name AS department ,e.name AS EmployeeName, e.salary AS Salary</div><div class="line">FROM</div><div class="line">employee as e</div><div class="line">INNER JOIN department as d</div><div class="line">ON e.dept_id = d.id</div><div class="line">GROUP BY d.name, e.name</div><div class="line">ORDER BY e.salary DESC</div><div class="line">LIMIT 3</div></pre></td></tr></table></figure>

&gt; 显然，ORDER BY 把GROUP BY分好组的结果打乱，LIMIT最终结果也只能取到3条数据，显然不符合题目要求。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">select d.name AS department ,e1.name AS EmployeeName, e1.salary AS Salary  </div><div class="line">    from employee e1 </div><div class="line">    left join department d on e1.dept_id=d.id    </div><div class="line">where      </div><div class="line">(  </div><div class="line">    select count(1)     </div><div class="line">    from employee e2     </div><div class="line">    where e2.dept_id=e1.dept_id and e2.salary&gt;=e1.salary  </div><div class="line">) &lt;=3 /*这里的数值表示你想取前几名*/</div><div class="line"></div><div class="line">order by d.name, e1.salary desc;</div></pre></td></tr></table></figure>

&gt; 看了才知道这样的思路很妙，employee表自身连接来实现取薪水前几的功能。

&gt; Oracle自带分组函数，row_number(),mysql可以模拟实现该函数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">select * from  </div><div class="line">    (select dept_id,name,salary,  </div><div class="line">            row_number() over(</div><div class="line">                            partition by dept_id</div><div class="line">                            order by salary desc) rn</div><div class="line">                            from employee</div><div class="line">    )</div><div class="line">    where rn&lt;=3;</div></pre></td></tr></table></figure>

## 2. 你了解的开源软件有哪些？你知道Dubbo？Dubbo的协议扩展？

&gt; 自己对于Github上面比较好的后端项目只是fork没有好好看，自己需要合理计划学习时间进度。

&gt; Dubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。

&gt; Dubbo的扩展点加载从JDK标准的SPI(Service Provider Interface)扩展点发现机制加强而来。

&gt; Dubbo改进了JDK标准的SPI的以下问题：

1. JDK标准的SPI会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。

2. 如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK标准的ScriptEngine，通过getName();获取脚本类型的名称，但如果RubyScriptEngine因为所依赖的jruby.jar不存在，导致RubyScriptEngine类加载失败，这个失败原因被吃掉了，和ruby对应不起来，当用户执行ruby脚本时，会报不支持ruby，而不是真正失败的原因。

3. 增加了对扩展点IoC和AOP的支持，一个扩展点可以直接setter注入其它扩展点。

&gt; 在扩展类的jar包内，放置扩展点配置文件：META-INF/dubbo/接口全限定名，内容为：配置名=扩展实现类全限定名，多个实现类用换行符分隔。 类似于key-value的形式。

&gt; com.alibaba.dubbo.common.extension

&gt; ExtensionLoader没有提供public的构造方法，但是提供了一个public static的getExtensionLoader，这个方法就是获取ExtensionLoader实例的工厂方法。其public成员方法中有三个比较重要的方法：
- getActivateExtension ：根据条件获取当前扩展可自动激活的实现
- getExtension ： 根据名称获取当前扩展的指定实现
- getAdaptiveExtension : 获取当前扩展的自适应实现

- 参考文章：[](http://blog.csdn.net/jdluojing/article/details/44947221)

## 3. java8新特性哪些是虚拟机层面的？

1. JDK8 HotSpot JVM 将移除永久区，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）

![](http://incdn1.b0.upaiyun.com/2015/02/a346dd9605bff60e7e7af9e8f3d82064.png)

2. java7引入了invokedynamic在JVM层面支持方法调用的动态化。通过引入新的指令集和新的常量，编译时不再需要确定方法引用，而是由invokedynamic指令在运行时调用bootstrap方法在运行时决定方法的定义。除了对动态语言的支持之外，invokedynamic还为Java8引入lambda语言特性提前做好了JVM层面的准备。


&gt; lambda就可以利用invokedynamic指令的动态调用特性实现lambda表达式的调用。

&gt; invokedynamic指令的工作原理通过调用bootstrap方法获得CallSite，然后执行这个CallSite中包含的方法句柄完成方法的调用，调用的结果会返回一个Function的实例。

3. 新的垃圾收集器: G1

&gt; Full GC主要会进行老年代的垃圾回收，主流的老年代垃圾回收器CMS虽然设计目标是获得最短的回收停顿时间，但是仍然会导致一定时间的停服务(Stop The World)，所以会影响到服务的正常响应。

![](http://warrentalk.site/img/5959b0413dfb5f1969000002.png)

&gt; CMS主要的问题在于：

- 垃圾回收过程依然会停用户服务，如果是大内存场景下发生Full GC，这个时间可能会比较长。
- 采用标记清除算法，会导致大量的碎片，影响大对象的空间分配。

&gt; 在G1中依然是分代回收的概念，但是每一代的空间不再是简单地连续分配，他们被分散成多个大小相等的存储块，每个块都可以进行独立的垃圾回收，他们被称作Region。因为可以独立进行垃圾回收，那就有能力将一次很长的GC分解成多个短GC，通过调整每一次需要回收的Region数量来控制停顿时间的长短。

&gt; G1的优势在于：

- 将垃圾回收化整为零，减少对用户服务的影响
- 垃圾回收时间可配置
- 避免内存碎片



- 参考文章：[从Java6到Java8: 你应该知道的JVM新特性](http://warrentalk.site/2017/07/13/%E4%BB%8EJava6%E5%88%B0Java8-%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84JVM%E6%96%B0%E7%89%B9%E6%80%A7/)

## 4. 如何保证流媒体的实时传输与高并发？

&gt; 内容分发网络（Content Delivery Network），是在现有 Internet 中增加的一层新的网络架构，由遍布全国的高性能加速节点构成。这些高性能的服务节点都会按照一定的缓存策略存储您的业务内容，当您的用户向您的某一业务内容发起请求时，请求会被调度至最接近用户的服务节点，直接由服务节点快速响应，有效降低用户访问延迟，提升可用性。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;pre&gt;&lt;code&gt;# 海康威视一面记录

&amp;gt; 面试中记录显示了自己的深度的不足，敬佩面试官对于技术深度以及开源项目的态度。

## 1. 手撕SQL：两张表（薪水表、部门
    
    </summary>
    
      <category term="面试记录" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
      <category term="hikvison" scheme="http://lincentma.men/tags/hikvison/"/>
    
  </entry>
  
  <entry>
    <title>HashMap三两事</title>
    <link href="http://lincentma.men/hashmap_note.html"/>
    <id>http://lincentma.men/hashmap_note.html</id>
    <published>2017-09-25T03:25:05.000Z</published>
    <updated>2017-09-25T03:26:21.810Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="HashMap链表转为红黑树的临界值为8的原因"><a href="#HashMap链表转为红黑树的临界值为8的原因" class="headerlink" title="HashMap链表转为红黑树的临界值为8的原因"></a>HashMap链表转为红黑树的临界值为8的原因</h1><ul>
<li>参考文章：<ul>
<li><a href="http://www.cnblogs.com/chinajava/p/5808416.html" target="_blank" rel="external">深入理解哈希表</a></li>
<li><a href="http://blog.csdn.net/richard_jason/article/details/53887222" target="_blank" rel="external">Jdk1.8中的HashMap实现原理</a></li>
<li><a href="http://www.importnew.com/20386.html" target="_blank" rel="external">Java8系列之重新认识HashMap</a></li>
</ul>
</li>
</ul>
<h2 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h2><p><img src="http://tech.meituan.com/img/java-hashmap/java.util.map%E7%B1%BB%E5%9B%BE.png" alt=""></p>
<blockquote>
<p>在JDK1.6中，HashMap采用位桶+链表实现，即使用链表处理冲突，同一hash值的Entity都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。</p>
<p>而JDK1.8(JDK版本号为：1.8.0_25)中，HashMap采用位桶+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间（查找时间复杂度由O(n)变为O(lgn)）。</p>
</blockquote>
<p><img src="http://static.oschina.net/uploads/space/2016/0222/184438_IA5n_2243330.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 这是一个阈值，当桶(bucket)上的链表数大于这个值时会转成红黑树，put方法的代码里有用到。put的时候如果两个值</div><div class="line">// 经过hash后都落在同一个bucket上这叫发生一次hash碰撞，往里不断put数据，当一个bucket发生8次碰撞就转成红黑树。</div><div class="line">static final int TREEIFY_THRESHOLD = 8;</div><div class="line"> </div><div class="line">// 也是阈值同上一个相反，当桶(bucket)上的链表数小于这个值时树转链表</div><div class="line">static final int UNTREEIFY_THRESHOLD = 6;</div></pre></td></tr></table></figure>
<h2 id="TREEIFY-THRESHOLD-8的原因"><a href="#TREEIFY-THRESHOLD-8的原因" class="headerlink" title="TREEIFY_THRESHOLD = 8的原因"></a>TREEIFY_THRESHOLD = 8的原因</h2><p>理想状态下哈希表的每个“箱子”中，元素的数量遵守泊松分布:</p>
<p><img src="https://o8ouygf5v.qnssl.com/1470319630.png?_=5808416" alt=""></p>
<p>泊松分布的参数λ是单位时间(或单位面积)内随机事件的平均发生率。 泊松分布适合于描述单位时间内随机事件发生的次数。（来自百度百科）</p>
<p>理想来说，在负载因子为0.75的条件下，bin中Node出现的频率满足参数为0.5的泊松分布。</p>
<p>当负载因子为 0.75 时，上述公式中 λ 约等于 0.5，因此箱子中元素个数和概率的关系如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">数量</th>
<th style="text-align:center">概率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0.60653066</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0.30326533</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0.07581633</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0.01263606</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0.00157952</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">0.00015795</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">0.00001316</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">0.00000094</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">0.00000006</td>
</tr>
</tbody>
</table>
<p>从概率来看，之所以链表长度超过 8 以后要变成红黑树，因为在正常情况下出现这种现象的几率小到忽略不计。一旦出现，几乎可以认为是哈希函数设计有问题导致的。</p>
<h2 id="HashMap的大小要设置为2的n次幂的原因"><a href="#HashMap的大小要设置为2的n次幂的原因" class="headerlink" title="HashMap的大小要设置为2的n次幂的原因"></a>HashMap的大小要设置为2的n次幂的原因</h2><blockquote>
<p>HashMap中的数据结构是数组+单链表的组合，我们希望的是元素存放的更均匀，最理想的效果是，Entry数组中每个位置都只有一个元素，这样，查询的时候效率最高，不需要遍历单链表，也不需要通过equals去比较K，而且空间利用率最大。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line"> * Returns index for hash code h. </div><div class="line"> */  </div><div class="line">static int indexFor(int h, int length) &#123;  </div><div class="line">    return h &amp; (length-1);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>h:为插入元素的hashcode<br>length:为map的容量大小<br>&amp;：与操作 比如 1101 &amp; 1011=1001</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//计算key的hash</div><div class="line">static final int hash(Object key) &#123;</div><div class="line">        int h;</div><div class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line"> &#125;</div><div class="line">// h = key.hashCode() 为第一步 取hashCode值</div><div class="line">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</div></pre></td></tr></table></figure>
<blockquote>
<p>当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。最终的bucketIndex是通过取余来运算,总是可以得到在bucket长度区间内的结果。</p>
<p>h的计算是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p>
</blockquote>
<h2 id="HashMap加载因子默认为0-75的原因"><a href="#HashMap加载因子默认为0-75的原因" class="headerlink" title="HashMap加载因子默认为0.75的原因"></a>HashMap加载因子默认为0.75的原因</h2><blockquote>
<p>HashMap的插入和搜索，复杂度都是O(1)，是非常快速的跟你的容量大小通常是没有直接关系的但是这是理想的情况。 这里说的理想，是在你所存储的对象的hashcode这个方法写的非常有效的情况下。根据hash的原理，存放一个对象是根据他的hashcode来计算的，如果没有哈希冲突，那么他的存储效率是最高，最完美的。</p>
<p>当通过HashCode计算地址存放，发现当前位置已经有元素，则称为元素的碰撞，需要重新计算或者其他方式放置该元素。</p>
<p>哈希表为了避免这种冲突，会有一点优化。简单的说，原本可以放100个数据的空间，当放到80个的时候，根据经验，接下去冲突的可能性会更加高，就好比一个靶子上80%都是箭的时候你再射一箭出去，射中箭的可能性很大。因此就自动增加空间来减小冲突可能性。</p>
<p>个数与碰撞几率服从柏松分布，发现在0.75处几率最小。</p>
<p>默认加载因子在时间和空间成本上寻求一种折衷,是对空间和时间效率的一个平衡选择。</p>
</blockquote>
<h2 id="解决hash冲突的办法"><a href="#解决hash冲突的办法" class="headerlink" title="解决hash冲突的办法"></a>解决hash冲突的办法</h2><ol>
<li>开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立一个公共溢出区</li>
</ol>
<h2 id="HashMap允许null值的原因"><a href="#HashMap允许null值的原因" class="headerlink" title="HashMap允许null值的原因"></a>HashMap允许null值的原因</h2><blockquote>
<p>ConcurrentHashmap和Hashtable都是支持并发的，这样会有一个问题，当你通过get(k)获取对应的value时，如果获取到的是null时，你无法判断，它是put（k,v）的时候value为null，还是这个key从来没有做过映射。HashMap是非并发的，可以通过contains(key)来做这个判断。</p>
</blockquote>
<h2 id="多线程下HashMap的resize-为什么会出现死循环"><a href="#多线程下HashMap的resize-为什么会出现死循环" class="headerlink" title="多线程下HashMap的resize()为什么会出现死循环?"></a>多线程下HashMap的resize()为什么会出现死循环?</h2><blockquote>
<p>存在的问题：HashMap为数组+链表结构，链表结构容易形成闭合的链路，这样在循环的时候只要有线程对这个HashMap进行get操作就会产生死循环。</p>
<p>只有在多线程并发的情况下才会出现这种情况，那就是在put操作的时候，如果size&gt;initialCapacity*loadFactor，那么这时候HashMap就会进行rehash操作，随之HashMap的结构就会发生翻天覆地的变化。很有可能就是在两个线程在这个时候同时触发了rehash操作，产生了闭合的回路。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">/* 初始化或者是将table大小加倍。如果为空，则按threshold分配空间，否则，加倍后，每个容器中的元素在新table中要么呆在原索引处，要么有一个2的次幂的位移</div><div class="line"> * @return the table</div><div class="line"> */</div><div class="line">final Node&lt;K, V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K, V&gt;[] oldTab = table;</div><div class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</div><div class="line">    int oldThr = threshold;</div><div class="line">    int newCap, newThr = 0;</div><div class="line">    if (oldCap &gt; 0) &#123;</div><div class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            return oldTab;</div><div class="line">        &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;         //容量加倍</div><div class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; 1;                                       // 阈值加倍</div><div class="line">    &#125; else if (oldThr &gt; 0) // 如果oldCap&lt;=0，初始容量为阈值threshold</div><div class="line">        newCap = oldThr;</div><div class="line">    else &#123;               // 零初始化阈值表明使用默认值</div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    if (newThr == 0) &#123;</div><div class="line">        float ft = (float)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</div><div class="line">                  (int)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</div><div class="line">    Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[])new Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    if (oldTab != null) &#123;</div><div class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K, V&gt; e;</div><div class="line">            if ((e = oldTab[j]) != null) &#123;</div><div class="line">                oldTab[j] = null;</div><div class="line">                if (e.next == null)</div><div class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</div><div class="line">                else if (e instanceof TreeNode)</div><div class="line">                    ((TreeNode&lt;K, V&gt;)e).split(this, newTab, j, oldCap); //红黑树分裂</div><div class="line">                else &#123;                              // 保持原有顺序</div><div class="line">                    Node&lt;K, V&gt; loHead = null, loTail = null;</div><div class="line">                    Node&lt;K, V&gt; hiHead = null, hiTail = null;</div><div class="line">                    Node&lt;K, V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</div><div class="line">                            if (loTail == null)</div><div class="line">                                loHead = e;</div><div class="line">                            else</div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            if (hiTail == null)</div><div class="line">                                hiHead = e;</div><div class="line">                            else</div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; while ((e = next) != null);</div><div class="line">                    //新表索引：hash &amp; (newCap - 1)---》低x位为Index</div><div class="line">                    //旧表索引：hash &amp; (oldCap - 1)---》低x-1位为Index</div><div class="line">                    //newCap = oldCap &lt;&lt; 1</div><div class="line">                    //举例说明：resize()之前为低x-1位为Index，resize()之后为低x位为Index</div><div class="line">                    //则所有Entry中，hash值第x位为0的，不需要哈希到新位置，只需要呆在当前索引下的新位置j</div><div class="line">                    //hash值第x位为1的，需要哈希到新位置，新位置为j+oldCap</div><div class="line">                    if (loTail != null) &#123;</div><div class="line">                        loTail.next = null;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    if (hiTail != null) &#123;</div><div class="line">                        hiTail.next = null;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Transfers all entries from current table to newTable.</div><div class="line"> */</div><div class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</div><div class="line">    int newCapacity = newTable.length;</div><div class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</div><div class="line">        while(null != e) &#123;</div><div class="line">            Entry&lt;K,V&gt; next = e.next;</div><div class="line">            if (rehash) &#123;</div><div class="line">                e.hash = null == e.key ? 0 : hash(e.key);</div><div class="line">            &#125;</div><div class="line">            int i = indexFor(e.hash, newCapacity);</div><div class="line">            e.next = newTable[i];</div><div class="line">            newTable[i] = e;</div><div class="line">            e = next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们会发现转移的时候是逆序的。假如转移前链表顺序是1-&gt;2-&gt;3，那么转移后就会变成3-&gt;2-&gt;1。</p>
</blockquote>
<p><img src="http://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE4.png" alt=""></p>
<blockquote>
<p>当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;HashMap链表转为红黑树的临界值为8的原因&quot;&gt;&lt;a href=&quot;#HashMap链表转为红黑树的临界值为8的原因&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="面试记录" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="hashmap" scheme="http://lincentma.men/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>中移物联网一面</title>
    <link href="http://lincentma.men/zhongyiwulianwang_interview.html"/>
    <id>http://lincentma.men/zhongyiwulianwang_interview.html</id>
    <published>2017-09-24T12:10:28.000Z</published>
    <updated>2017-09-24T12:11:42.127Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="中移物联网一面"><a href="#中移物联网一面" class="headerlink" title="中移物联网一面"></a>中移物联网一面</h1><blockquote>
<p>不断努力完善自己</p>
</blockquote>
<h2 id="1-MapReduce的启动类是什么？"><a href="#1-MapReduce的启动类是什么？" class="headerlink" title="1. MapReduce的启动类是什么？"></a>1. MapReduce的启动类是什么？</h2><blockquote>
<p>自己的理解是Java的MapReduce程序如何启动。</p>
<p>例如wordcount：</p>
<p>Job的初始化过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Job job = new Job(conf, &quot;word count&quot;); </div><div class="line">job.setJarByClass(WordCount.class);</div><div class="line">job.setMapperClass(TokenizerMapper.class);</div><div class="line">job.setCombinerClass(IntSumReducer.class);</div><div class="line">job.setReducerClass(IntSumReducer.class);</div><div class="line">job.setOutputKeyClass(Text.class);</div><div class="line">job.setOutputValueClass(IntWritable.class);</div><div class="line">FileInputFormat.addInputPath(job, new Path(otherArgs[0]));</div><div class="line">FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));</div><div class="line"></div><div class="line">System.exit(job.waitForCompletion(true) ? 0 : 1);</div></pre></td></tr></table></figure></p>
<p>Hadoop Streaming 运行方式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hadoop jar hadoop-streaming-2.4.1.jar \</div><div class="line">-files mapperPythonScript.py, reducerPythonScript.py</div><div class="line">-input myInputDirs \</div><div class="line">    -output myOutputDir \</div><div class="line">    -mapper mapperPythonScript.py \</div><div class="line">    -reducer reducerPythonScript.py</div></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>用-file分发文件</li>
<li>用-cacheFile分发文件</li>
<li>用-cacheArchive分发压缩包</li>
</ol>
</blockquote>
<h2 id="2-谈谈你对与Hive的理解？"><a href="#2-谈谈你对与Hive的理解？" class="headerlink" title="2. 谈谈你对与Hive的理解？"></a>2. 谈谈你对与Hive的理解？</h2><blockquote>
<p>Hive是一个基于Hadoop文件系统上的数据仓库架构。</p>
<p>它为数据仓库的管理提供了许多功能：数据ETL（抽取、转换、加载）工具、数据存储管理、大型数据集的查询与分析能力、类SQL语言（HQL，允许自定义mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作）。</p>
<p>Hive执行过程：</p>
<ol>
<li><p>操作符是Hive的最小处理单元</p>
</li>
<li><p>每个操作符处理代表HDFS操作或MR作业</p>
</li>
<li><p>编译器把HQL转换成一组操作符</p>
</li>
<li><p>Hive通过ExecMapper和ExecReducer来执行MapReduce任务 </p>
</li>
</ol>
</blockquote>
<p><img src="https://pic1.zhimg.com/50/47dbdb72838e5cefc4fc7fde465cfe58_hd.png" alt=""></p>
<h2 id="3-网站上网页版人工客服窗口后端的实现原理是什么？"><a href="#3-网站上网页版人工客服窗口后端的实现原理是什么？" class="headerlink" title="3. 网站上网页版人工客服窗口后端的实现原理是什么？"></a>3. 网站上网页版人工客服窗口后端的实现原理是什么？</h2><blockquote>
<p>ajax交互：使用ajax长轮询实现网页实时聊天。<br><img src="http://images2015.cnblogs.com/blog/819496/201511/819496-20151114110929165-1485612934.jpg" alt=""></p>
<p>websocket实现。WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。</p>
<p>　XMLHttpRequest 对象用于在后台与服务器交换数据。</p>
<ul>
<li>在不重新加载页面的情况下更新网页</li>
<li>在页面已加载后从服务器请求数据</li>
<li>在页面已加载后从服务器接收数据</li>
<li>在后台向服务器发送数据</li>
</ul>
</blockquote>
<h2 id="4-如何理解父类-new-子类这样的方式？（乱入下新华三的笔试选择题）"><a href="#4-如何理解父类-new-子类这样的方式？（乱入下新华三的笔试选择题）" class="headerlink" title="4. 如何理解父类 =  new 子类这样的方式？（乱入下新华三的笔试选择题）"></a>4. 如何理解父类 =  new 子类这样的方式？（乱入下新华三的笔试选择题）</h2><blockquote>
<p>父类 xx = new 子类（）的定义对象</p>
<p>这个问题体现了成员变量继承和方法继承的区别。</p>
<p>在实例化一个子类的同时，系统会给子类所有实例变量分配内存，也会给它的父类的实例变量分配内存，即使父子类中存在重名的实例变量，也会两个都分配内存的，这个时候子类只是隐藏了父类的这个变量，但还是会给它分配内存，然后可以用super来访问属于父类的变量。</p>
<p>父类 xx = new 子类（）定义的对象只能调用继承来的方法。父类 xx = new 子类（）定义的对象调用的是子类的方法，而不是父类的。</p>
<p>总结：访问变量看声明，访问方法看实际对象类型（new出来的类型）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Father a = new Father();</div><div class="line">        Chilren b = new Chilren();</div><div class="line">        Father c = new Chilren();</div><div class="line">        a.getAge();</div><div class="line">        System.out.println(a.age);</div><div class="line">        b.getAge();</div><div class="line">        System.out.println(b.age);</div><div class="line">        c.getAge();</div><div class="line">        System.out.println(c.age);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class Father &#123;</div><div class="line">    int age = 40;</div><div class="line"> </div><div class="line">    public void getAge() &#123;</div><div class="line">        System.out.println(age);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class Chilren extends Father &#123;</div><div class="line">    int age = 18;</div><div class="line"> </div><div class="line">    public void getAge() &#123;</div><div class="line">        System.out.println(age);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> 输出</div><div class="line"> </div><div class="line">40</div><div class="line">40</div><div class="line">18</div><div class="line">18</div><div class="line">18</div><div class="line">40</div></pre></td></tr></table></figure>
<h2 id="5-面对薪资的问题：你对于薪资要求是否有一个具体的数组？这种问题最好的回答是什么？"><a href="#5-面对薪资的问题：你对于薪资要求是否有一个具体的数组？这种问题最好的回答是什么？" class="headerlink" title="5. 面对薪资的问题：你对于薪资要求是否有一个具体的数组？这种问题最好的回答是什么？"></a>5. 面对薪资的问题：你对于薪资要求是否有一个具体的数组？这种问题最好的回答是什么？</h2><blockquote>
<p>态度：谦逊平和真诚。</p>
<p>做好内功，做一个真正的人才！这是谈薪资最强大的依仗。</p>
<p>当hr问我期望薪资时，我会在回答之前，先咨询公司的薪资结构。</p>
<p>了解一下市场上这个职位的薪酬范围。了解一下这家公司的薪酬情况。然后在一定范围内谈。</p>
<p>询问公司工作时间、加班频率、福利待遇等其他条件，让自己有更多的考虑时间。</p>
<p>掌握了公司的薪酬结构之后，你已经能够据此判断出公司工作的完善程度。那么你可以根据这些信息，结合自己的预期，做一个有利于自己的计算和判断。当然很多信息、预案是需要在面试之前去做收集、准备的。</p>
<p>您这个职位预算区间大概多少？</p>
<p>一定是让对方先说。薪资谈判中，千万别做先提数字的一方。</p>
<p>面试中薪资的问与答只是面试中展示你自身价值的15%而已，剩余的展示环节更要做足才对，毕竟最终的目的是把自己“卖出去”，顺便“卖个好价钱”。</p>
<p>你不必提具体数字；取而代之，你可以回答一个区间。比如说，“我期望的薪水是月薪7K～10K。”</p>
<p>站在HR的角度，只要期望薪资在岗位预算范围里，就差不多了。那种绕来绕去的面试者，我觉得很傻又很不坦诚。</p>
<p>多看知乎！！！</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/50/v2-7da5935e3bb423e2365171f4d2cc0558_hd.png" alt=""></p>
<ul>
<li>参考文章：<a href="https://www.zhihu.com/question/20890139" target="_blank" rel="external">面试谈工资的时候，对方问你的期望薪资，如果反问对方「根据自己的能力能给多少」，合适吗？</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;中移物联网一面&quot;&gt;&lt;a href=&quot;#中移物联网一面&quot; class=&quot;headerlink&quot; title=&quot;中移物联网一面&quot;&gt;&lt;/a&gt;中移物联网一面&lt;/h1&gt;&lt;bl
    
    </summary>
    
      <category term="面试记录" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
      <category term="中移物联网" scheme="http://lincentma.men/tags/%E4%B8%AD%E7%A7%BB%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>招银科技面试记录</title>
    <link href="http://lincentma.men/zhaoyinkeji_interview.html"/>
    <id>http://lincentma.men/zhaoyinkeji_interview.html</id>
    <published>2017-09-21T08:29:34.000Z</published>
    <updated>2017-09-21T08:32:02.230Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="招银科技面试"><a href="#招银科技面试" class="headerlink" title="招银科技面试"></a>招银科技面试</h1><blockquote>
<p>面试的过程是一个总能发现自己不足的机会，但是平时的不断积累才是避免面试发现不足的更重要的原因。</p>
</blockquote>
<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><ol>
<li>如何自定义一个异常？</li>
</ol>
<blockquote>
<ol>
<li>非运行时异常(Checked Exception) </li>
</ol>
<p>Java中凡是继承自Exception但不是继承自RuntimeException的类都是非运行时异常。</p>
<ol>
<li>运行时异常（Runtime Exception/Unchecked Exception） </li>
</ol>
<p>RuntimeException类直接继承自Exception类，称为运行时异常。Java中所有的运行时异常都直接或间接的继承自RuntimeException。</p>
<ol>
<li><p>Java中所有的异常类都直接或间接的继承自Exception。</p>
</li>
<li><p>Spring事务回滚机制只处理运行时异常，发生非运行时异常则不会回滚操作。</p>
</li>
</ol>
<p>使用自定义异常继承相关的异常来抛出处理后的异常信息可以隐藏底层的异常，这样更安全，异常信息也更加的直观。自定义异常可以抛出我们自己想要抛出的信息，可以通过抛出的信息区分异常发生的位置，根据异常名我们就可以知道哪里有异常，根据异常提示信息进行程序修改。比如空指针异常NullPointException，我们可以抛出信息为“xxx为空”定位异常位置，而不用输出堆栈信息。</p>
<p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p>
<ul>
<li>所有异常都必须是 Throwable 的子类。</li>
<li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li>
<li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 所有秒杀相关异常(运行期异常)</div><div class="line"> * spring事务，只接收运行期异常，执行回滚操作</div><div class="line"> */</div><div class="line">public class SeckillException extends RuntimeException&#123;</div><div class="line"></div><div class="line">    private static final long serialVersionUID = 1L;</div><div class="line"></div><div class="line">    //重载构造函数</div><div class="line">    public SeckillException(String message, Throwable cause) &#123;</div><div class="line">        super(message, cause);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //重载构造函数</div><div class="line">    public SeckillException(String message) &#123;</div><div class="line">        super(message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>通用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @Description:通用的UncheckedException异常，继承RuntimeException，为运行期异常</div><div class="line"> */</div><div class="line">public class UncheckedException extends RuntimeException &#123;</div><div class="line">    private static final long serialVersionUID = 1L;</div><div class="line">    /** 错误Key，用于唯一标识错误类型 */</div><div class="line">    private String errorCode = null;</div><div class="line">    /** 错误信息 */</div><div class="line">    private String errorMessage;</div><div class="line">    /** 传递给变量的错误值 */</div><div class="line">    private Object[] errorParam = null;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 构造函数</div><div class="line">     * @param errorCode 异常编码</div><div class="line">     */</div><div class="line">    public UncheckedException(String errorCode) &#123;</div><div class="line">        this.errorCode = errorCode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 构造函数</div><div class="line">     * @param errorCode 异常编码</div><div class="line">     * @param errorParam Object[] 异常信息用到的参数</div><div class="line">     */</div><div class="line">    public UncheckedException(String errorCode, Object[] errorParam) &#123;</div><div class="line">        this.errorCode = errorCode;</div><div class="line">        this.errorParam = errorParam;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 重载构造函数</div><div class="line">     * @param errorCode 异常编码</div><div class="line">     * @param errorParam 异常信息用到的参数</div><div class="line">     * @param t 异常实例</div><div class="line">     */</div><div class="line">    public UncheckedException(String errorCode, Object[] errorParam, Throwable t) &#123;</div><div class="line">        super(t);</div><div class="line">        this.errorCode = errorCode;</div><div class="line">        this.errorParam = errorParam;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 重载构造函数</div><div class="line">     * @param message 异常信息</div><div class="line">     * @param t 异常实例</div><div class="line">     */</div><div class="line">    public UncheckedException(String message, Throwable t) &#123;</div><div class="line">        super(message, t);</div><div class="line">        setErrorMessage(message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 异常编码</div><div class="line">     * @return String</div><div class="line">     */</div><div class="line">    public String getErrorCode() &#123;</div><div class="line">        return this.errorCode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 异常信息用到的参数</div><div class="line">     * @return Object[]</div><div class="line">     */</div><div class="line">    public Object[] getErrorParam() &#123;</div><div class="line">        return this.errorParam;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 错误信息</div><div class="line">     * </div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public String getErrorMessage() &#123;</div><div class="line">        return errorMessage;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 错误信息</div><div class="line">     * </div><div class="line">     * @param errorMessage</div><div class="line">     */</div><div class="line">    public void setErrorMessage(String errorMessage) &#123;</div><div class="line">        this.errorMessage = errorMessage;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 覆盖方法：getMessage</div><div class="line">     * @return String</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public String getMessage() &#123;</div><div class="line">        if (errorMessage != null) &#123;</div><div class="line">            return errorMessage;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //异常信息以资源文件的形式保存，并且支持国际化，此处通过errorCode去读取国际化异常信息</div><div class="line">        if (errorCode != null &amp;&amp; !errorCode.trim().equals(&quot;&quot;)) &#123;</div><div class="line">            setErrorMessage(AppLang.getLU().getMessage(errorCode, errorParam,Locale.SIMPLIFIED_CHINESE));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return getErrorMessage();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>参考文章：<ul>
<li><a href="http://blog.csdn.net/javaloveiphone/article/details/52607396" target="_blank" rel="external">实际springMVC项目中自定义异常、spring事务与异常的简单应用</a></li>
<li><a href="http://www.cnblogs.com/AlanLee/p/6104492.html" target="_blank" rel="external">Java异常之自定义异常</a></li>
</ul>
</li>
</ul>
<ol>
<li>如何定义一个服务是否具有高可用性？</li>
</ol>
<blockquote>
<p>计算机系统的可用性定义为：MTTF/(MTTF+MTTR) * 100%。由此可见，计算机系统的可用性定义为系统保持正常运行时间的百分比。</p>
<p>例如某个系统的可用性为4个9（99.99%），相当于系统一年停服务的时间不超过365<em>24</em>60/10000=52.56分钟。系统的可用性往往体现了系统的整体的代码质量和容错能力。</p>
</blockquote>
<ol>
<li>MySQL不同存储引擎的区别？</li>
</ol>
<blockquote>
<p>MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：<br>MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE</p>
</blockquote>
<p>MyISAM与InnoDB的区别是什么？</p>
<ol>
<li><p>存储结构<br>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。<br>InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p>
</li>
<li><p>存储空间<br>MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。<br>InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p>
</li>
<li><p>可移植性、备份及恢复<br>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。<br>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p>
</li>
<li><p>事务支持<br>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。<br>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p>
</li>
<li><p>AUTO_INCREMENT<br>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。<br>InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p>
</li>
<li><p>表锁差异<br>MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p>
</li>
<li><p>全文索引<br>MyISAM：支持 FULLTEXT类型的全文索引<br>InnoDB：不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。</p>
</li>
<li><p>表主键<br>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。<br>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</p>
</li>
<li><p>表的具体行数<br>MyISAM：保存有表的总行数，如果select count(<em>) from table;会直接取出出该值。<br>InnoDB：没有保存表的总行数，如果使用select count(</em>) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p>
</li>
<li><p>CURD操作<br>MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。<br>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p>
</li>
<li><p>外键<br>MyISAM：不支持<br>InnoDB：支持</p>
</li>
</ol>
<blockquote>
<p>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。</p>
</blockquote>
<ul>
<li>参考文章：<a href="http://www.jb51.net/article/62457.htm" target="_blank" rel="external">MySQL存储引擎中的MyISAM和InnoDB区别详解</a></li>
</ul>
<ol>
<li>存储过程使用场景？</li>
</ol>
<blockquote>
<p>存储过程有利有弊，最大的利处在于运算过程中不需要将数据取出数据库，会获得较高的性能，因为数据库IO通道效率一向很差，大量数据取出来很费时间。</p>
<p>开发规范中要求，所有牵涉到业务逻辑部分的数据库操作，必须在数据库层由存储过程实现（就所面向的金融行业而言，工商银行、中国银行、交通银行，都在开发规范中严格指定）</p>
<p>存储过程优点：</p>
<ol>
<li>执行速度快。因为存储过程不需要解析。预先编译了</li>
<li>安全性。避免了sql注入，避免了暴露表结构和字段</li>
</ol>
<p>存储过程缺点：</p>
<ol>
<li>调试困难。</li>
<li>迁移困难。</li>
</ol>
<p>针对于分布式数据库，如果业务逻辑封装在存储过程中。由于存储过程是依赖于某个具体的数据库的，这样实现起来难度较大。把计算层放到web层，那么web端的程序只是从多个数据库服务器聚合数据即可了。</p>
<p>敏捷开发在互联网公司业务开发中非常常见，而银行业，金融业不会频繁的修改功能。</p>
<p><strong>解决性能瓶颈，互联网大部分还是通过使用缓存来解决的，这跟银行类系统”花费大价钱提高硬件和数据库软件的承载能力”思路是不同的。</strong></p>
</blockquote>
<ul>
<li>参考文章：<ul>
<li><a href="https://www.zhihu.com/question/19749126" target="_blank" rel="external">大型系统必须得要存储过程和触发器吗？</a></li>
<li><a href="http://blog.csdn.net/u013814158/article/details/70171756" target="_blank" rel="external">在开发过程中为什么需要写存储过程</a> 非常好的文章！</li>
</ul>
</li>
</ul>
<ol>
<li>如何使用日志？</li>
</ol>
<blockquote>
<p>Java日志框架：</p>
<ul>
<li>JDK的java.util.logging包</li>
<li>第三方日志工具（commons-logging/slf4j，log4j/logback）</li>
</ul>
<p>通过Logger.getLogger(name)方法可以获取logger对象，logger对象有三个比较重要的概念：level、handler、formatter。level称为日志级别，在java.util.logging包中定义了java.util.logging.Level类，里面包含SEVERE/WARNING/INFO/CONFIG/FINE/FINER/FINEST（从高到低）7种日志级别。设置日志级别会过滤掉一部分日志，例如当日志级别设置为INFO级别时，CONFIG/FINE/FINER/FINEST级别的日志就会被忽略。handler解决的问题是日志输出到哪里，是到控制台（java.util.logging.ConsoleHandler），还是到文件（java.util.logging.FileHandler），或者是写到Socket中（java.util.logging.SocketHandler）。formatter定义了日志输出的格式，可以是XML（java.util.logging.XMLFormatter），也可以自己实现JSON格式的Fomatter。</p>
<p>log对象初始化过程</p>
</blockquote>
<p><img src="http://images0.cnblogs.com/blog2015/504484/201508/041735151423967.jpg" alt=""></p>
<blockquote>
<p>SL4J/COMMONS-LOGGING、LOG4J、LOGBACK、JUL都是常用的Java日志工具，基本思想都是通过Factory生成logger对象，然后由LogManager管理/缓存logger对象，同时维护一个父子结构方便复用配置。logger对象包含三要素：日志级别、输出到哪里、格式化。</p>
</blockquote>
<ul>
<li>参考文章：<a href="http://www.cnblogs.com/zhao1949/p/5952385.html" target="_blank" rel="external">Java日志 (zhuan)</a></li>
</ul>
<ol>
<li>为什么选择这个岗位？</li>
</ol>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><ol>
<li>针对于每日产出文件，由于数据不完整的重新产出，如何比较两个文件不一样的内容？</li>
</ol>
<ul>
<li>Linux方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">diff 123.txt 234.txt</div><div class="line"></div><div class="line">通常输出由下述形式的行组成：</div><div class="line">n1 a n3，n4</div><div class="line">n1，n2 d n3</div><div class="line">n1，n2 c n3，n4 这些行类似ed命令把filel转换成file2。字母(a、d和c)之前的行号(n1，n2)是针对file1的，其后面的行号(n3，n4)是针对file2的。字母a、d和c分别表示附加、删除和修改操作。</div><div class="line"></div><div class="line">在上述形式的每一行的后面跟随受到影响的若干行，以”&lt;”打头的行属于第一个文件，以”&gt;”打头的行属于第二个文件。</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注意：在使用diff命令时候，也需要预先对文件进行sort排序，不然输出可能出错。</p>
</blockquote>
<ul>
<li><p>linux下MD5计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:~/maling/test$ md5sum 234.txt </div><div class="line">8fb63e502ae6ad0c6268c128f559e7fd  234.txt</div></pre></td></tr></table></figure>
</li>
<li><p>Java方式：<br>1) 先比较两个文件内容的长度；<br>2) 在长度相同的情况下，再比较两个文件的MD5值。</p>
</li>
</ul>
<blockquote>
<p>MD5，Message Digest Algorithm 5，是一种被广泛使用的信息摘要算法，可以将给定的任意长度数据通过一定的算法计算得出一个 128 位固定长度的散列值。 </p>
</blockquote>
<h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><ol>
<li>为什么你的定位是业务偏数据？</li>
</ol>
<blockquote>
<p>其实这样的感觉是自己技术深度不够造成的，需要完善自己的技术深度。</p>
<p>未来的时代是数据的时代，目前的自己还需要从业务做起熟悉流程。</p>
<p>题外话：金融型IT人才这类的复合型人才，职业生涯周期会更长。</p>
<p>认同这个观点，懂金融的不懂IT正常，做金融IT的不仅懂金融，还必须更懂金融（偏业务的金融），相对于专业的金融人才，还需要补充自己的专业性。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;招银科技面试&quot;&gt;&lt;a href=&quot;#招银科技面试&quot; class=&quot;headerlink&quot; title=&quot;招银科技面试&quot;&gt;&lt;/a&gt;招银科技面试&lt;/h1&gt;&lt;blockq
    
    </summary>
    
      <category term="面试记录" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
      <category term="zhaoyinkeji" scheme="http://lincentma.men/tags/zhaoyinkeji/"/>
    
  </entry>
  
  <entry>
    <title>滴滴现场面试记录</title>
    <link href="http://lincentma.men/didi_interview.html"/>
    <id>http://lincentma.men/didi_interview.html</id>
    <published>2017-09-19T18:23:57.000Z</published>
    <updated>2017-09-19T18:25:14.136Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="滴滴现场面试记录"><a href="#滴滴现场面试记录" class="headerlink" title="滴滴现场面试记录"></a>滴滴现场面试记录</h1><blockquote>
<p>现在写下的感受：完成了一场酣畅淋漓的运动之后的感觉，累然而爽。</p>
</blockquote>
<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><ol>
<li>操作系统进程的状态，注意不是线程！</li>
</ol>
<blockquote>
<p>进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。在三态模型中，进程状态分为三个基本状态，即运行态，就绪态，阻塞态。在五态模型中，进程分为新建态、终止态，运行态，就绪态，阻塞态。</p>
<ol>
<li><p>运行状态：获得CPU的进程处于此状态，对应的程序在CPU上运行着</p>
</li>
<li><p>阻塞状态：为了等待某个外部事件的发生（如等待I/O操作的完成，等待另一个进程发来消息），暂时无法运行。也称为等待状态。</p>
</li>
<li><p>就绪状态：具备了一切运行需要的条件，由于其他进程占用CPU而暂时无法运行</p>
</li>
</ol>
</blockquote>
<p><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=6803c224f2edab64607f4592965fc4a6/b7003af33a87e950f9264f8319385343fbf2b428.jpg" alt=""></p>
<blockquote>
<p>五态模型：对于一个实际的系统，进程的状态及其转换更为复杂。引入新建态和终止态构成了进程的五态模型。<br><img src="http://s8.sinaimg.cn/middle/7c03bb1fh78d58c467517&amp;690" alt=""></p>
<p>致使进程阻塞的典型事件有：请求I/O，申请缓冲空间等。通常将这种处于阻塞状态的进程也排成一个队列。有的系统则根据阻塞原因的不同而把处于阻塞状态的进程排成多个队列。</p>
</blockquote>
<ol>
<li>TCP三次握手详细画图，为什么每一次要加一？最后一次需不需要加一？</li>
</ol>
<blockquote>
<p>TCP 头部格式：</p>
</blockquote>
<p><img src="http://picture.jellythink.com/jellythinkTCP3.jpg" alt=""></p>
<ul>
<li><p>Source Port和Destination Port:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；</p>
</li>
<li><p>Sequence Number:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题；</p>
</li>
<li><p>Acknowledgment Number:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题；</p>
</li>
<li><p>Offset:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；</p>
</li>
<li><p>TCP Flags:TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：</p>
<ul>
<li>URG：此标志表示TCP包的紧急指针域（后面马上就要说到）有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；</li>
<li>ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0；</li>
<li>PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；</li>
<li>RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；</li>
<li>SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；</li>
<li>FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</li>
</ul>
</li>
<li><p>Window:窗口大小，也就是有名的滑动窗口，用来进行流量控制；</p>
</li>
</ul>
<p><img src="http://picture.jellythink.com/jellythinkTCP4.jpg" alt=""></p>
<blockquote>
<p>第二次和第三次握手有：Acknowledgment Number为x+1(Sequence Number+1)</p>
<p>第二次：服务端响应客户端的请求，响应中附带序列号0（由于这是服务端在该次TCP会话中发送的第一个包，所以序列号为0）和相对确认号1（表明服务端收到了客户端发送的包1中的SYN）</p>
<p>需要注意的是，尽管客户端没有发送任何有效数据，确认号还是被加1，这是因为接收的包中包含SYN或FIN标志位（并不会对有效数据的计数产生影响，因为含有SYN或FIN标志位的包并不携带有效数据）</p>
<p>第三次：和包2中一样，客户端使用确认号1响应服务端的序列号0，同时响应中也包含了客户端自己的序列号（由于服务端发送的包中确认收到了客户端发送的SYN，故客户端的序列号由0变为1）<br>此时，通信的两端的序列号都为1，通信两端的序列号增1发生在所有TCP会话的建立过程中。</p>
<p>这张图说明了一切：<br><img src="http://img.blog.csdn.net/20140725104320005?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
</blockquote>
<ul>
<li>参考文章：<a href="http://blog.csdn.net/a19881029/article/details/38091243" target="_blank" rel="external">理解TCP序列号（Sequence Number）和确认号（Acknowledgment Number）</a></li>
</ul>
<ol>
<li><p>排序算法</p>
</li>
<li><p>概率题</p>
</li>
<li><p>划重点：详细介绍运维所做的事情，草稿纸找不到了，非常感谢一面面试官！</p>
</li>
</ol>
<blockquote>
<p>首先是服务层的稳定性，运维是作为服务上线最后一道把关人，确保服务的高可用性。</p>
<p>再是系统资源层面的稳定性，包括机器的CPU占用，I/O读取等稳定。</p>
<p>然后是系统的高效性。利用docker等虚拟化等技术来节约资源。</p>
<p>…</p>
</blockquote>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><ol>
<li>针对实习项目，展开优化策略：</li>
</ol>
<ul>
<li>后端请求打到相同机器如何进行优化？</li>
</ul>
<blockquote>
<p>网上找到这样的图，描绘的很形象：将请求放入队列中的，采用FIFO（First Input First Output，先进先出）</p>
</blockquote>
<p><img src="http://cms.csdnimg.cn/article/201411/28/547823786991a_middle.jpg?_=10168" alt=""></p>
<blockquote>
<p>系统处理完一个队列内请求的速度根本无法和疯狂涌入队列中的数目相比。也就是说，队列内的请求会越积累越多，最终Web系统平均响应时候还是会大幅下降，系统还是陷入异常。</p>
<p>乐观锁</p>
</blockquote>
<ul>
<li>如何Hash分散请求？</li>
</ul>
<blockquote>
<p>一致性哈希。</p>
<p>一致性哈希，其实就是把哈希函数可映射的空间(相当于普通哈希中桶的数目是固定的)固定下来了，比如固定为: 2^n - 1，并组织成环的形状。每个机器对应着一个n位的ID，并且映射到环中。每个查询键，也是一个 n 位的ID，节点的ID和查询键对应着相同的映射空间。</p>
<p>一致性哈希的好处就是：当添加新机器或者删除机器时，不会影响到全部数据的存储，而只是影响到这台机器上所存储的数据(落在这台机器所负责的环上的数据)。</p>
<p>步骤：</p>
<ol>
<li>将整个哈希值空间组织成一个虚拟圆环，假设某哈希函数H的值空间为0-(2^32-1)，即32位无符号整数</li>
<li>将各节点用H函数哈希，可以将服务器的IP或主机名作为关键字哈希，这样每个节点就能确定其在哈希环上的位置</li>
<li>将id用H函数映射到哈希空间的一个值，沿该值向后，将遇到的第一个节点做为处理节点</li>
</ol>
</blockquote>
<p><img src="http://s9.sinaimg.cn/middle/3fde8252hc784bc9cd088&amp;690" alt=""> </p>
<blockquote>
<p>引入虚拟节点，可以有效地防止物理节点(机器)映射到哈希环中出现不均匀的情况。</p>
</blockquote>
<ol>
<li>划重点：普及AIOPs概念，详细介绍Google，百度在AIOPs的尝试以及最近运维大会讨论的主题，非常感谢二面面试官！</li>
</ol>
<blockquote>
<p>目前是自动化运维：DevOps<br>AIOps应用场景较少，主要在于异常检测<br>运维的稳定性是最重要的，但是AIOps的模型训练的试错成本很高，这是一个矛盾。<br>Google:SRE；百度运维；阿里运维。国内做的比较好的~</p>
<p>SRE是Site Reliability Engineer的简称，从名字可以看出Google的SRE不只是做Operation方面的工作，更多是保障整个Google服务的稳定性。SRE需要负责可用性、时延、性能、效率、变更管理、监控、应急响应和容量管理等相关的工作。</p>
</blockquote>
<h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><blockquote>
<p>三面面试官在深度细节方面让自己更加了解自己的不足</p>
</blockquote>
<ol>
<li>给定数组，乱序，重复，如何找到重复次数超过数组长度一半的数字？</li>
</ol>
<blockquote>
<p>参考文章：<a href="https://www.nowcoder.com/questionTerminal/e8a1b01a2df14cb2b228b30ee6a92163?source=relative" target="_blank" rel="external">数组中出现次数超过一半的数字</a></p>
<p>数组排序后，如果符合条件的数存在，则一定是数组中间那个数。</p>
<p>采用阵地攻守的思想：<br>第一个数字作为第一个士兵，守阵地；count = 1；<br>遇到相同元素，count++;<br>遇到不相同元素，即为敌人，同归于尽,count–；<br>当遇到count为0的情况，又以新的i值作为守阵地的士兵，继续下去，到最后还留在阵地上的士兵，有可能是主元素。<br>再加一次循环，记录这个士兵的个数看是否大于数组一半即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int MoreThanHalfNum_Solution(int [] array) &#123;</div><div class="line">        int length=array.length;</div><div class="line">        if(array==null||length&lt;=0)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        int result=array[0];</div><div class="line">        int times=1;</div><div class="line">        for(int i=1;i&lt;length;i++)&#123;</div><div class="line">            if(times==0)&#123;</div><div class="line">                result=array[i];</div><div class="line">                times=1;</div><div class="line">            &#125;else&#123;</div><div class="line">                if(array[i]==result)&#123;</div><div class="line">                    times++;</div><div class="line">                &#125;else&#123;</div><div class="line">                    times--;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        times=0;</div><div class="line">        for(int i=0;i&lt;length;i++)&#123;</div><div class="line">            if(result==array[i])&#123;</div><div class="line">                times++;</div><div class="line">            &#125;</div><div class="line">       &#125;</div><div class="line">            </div><div class="line">       if(times*2&lt;length)&#123;</div><div class="line">           result=0;</div><div class="line">       &#125;</div><div class="line">       return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>map方法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line">/*</div><div class="line"> * 利用map存值，找出存在最多的数字，若大于长度一半，返回此数，否则返回0</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public int MoreThanHalfNum_Solution(int [] array) &#123;</div><div class="line">        if(array.length==0||array==null)</div><div class="line">            return 0;</div><div class="line">        Map&lt;Integer,Integer&gt; map=new HashMap&lt;Integer,Integer&gt;();</div><div class="line">        for(int i=0;i&lt;array.length;i++)&#123;</div><div class="line">            if(map.containsKey(array[i]))&#123;</div><div class="line">                map.put(array[i], map.get(array[i])+1);</div><div class="line">            &#125;else&#123;</div><div class="line">                map.put(array[i], 1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; </div><div class="line">            if(entry.getValue()&gt;array.length/2)</div><div class="line">                return entry.getKey();</div><div class="line">        &#125; </div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>为什么要这样设计？时间复杂度是多少？还有没有别的方法？</li>
</ol>
<blockquote>
<p>最优O(n)</p>
</blockquote>
<ol>
<li>8个球其中一个质量轻，给一个天平，如何2次称出质量轻的球？</li>
</ol>
<ul>
<li><p>第一次,天平两边各放三个球：</p>
<p>  1.1 如果两边重量一致,则有质量缺陷的球在剩余的两个中—转至“2.2”</p>
<p>  1.2 如果两边重量不一致,则有质量缺陷的球在较轻重量的三个中—-转至“2.1”</p>
</li>
<li><p>第二次：</p>
<p>  2.1 在较轻的三个中取两个放在天平两边,如天平平衡,那么第三个球是有质量缺陷的球；如果不平衡,那么,较轻的是有质量缺陷的球.</p>
<p>  2.2 将剩余的两个球放在天平两边,较轻的是有质量缺陷的.</p>
</li>
</ul>
<ol>
<li>你眼中的运维？</li>
</ol>
<blockquote>
<p>运维服务于整个产品，保证架构合理，系统稳定。运维只对业务稳定负责，所有的工作都是奔着这个去的。</p>
</blockquote>
<ul>
<li>参考文章：<a href="https://segmentfault.com/a/1190000000348370" target="_blank" rel="external">一个开发眼中的运维</a></li>
</ul>
<ol>
<li>你认为自己的优势是什么？</li>
</ol>
<blockquote>
<p>自信。</p>
</blockquote>
<h4 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h4><blockquote>
<p>“自己缺乏的是对于对方表达意思的深刻理解”，非常高兴能够从HR面试中发现自己的不足，虽然这会影响到HR对于自己的评价，但是自己还是明白了。</p>
</blockquote>
<ol>
<li>如何沟通？</li>
</ol>
<blockquote>
<p>首先是换位思考，明白提问者想要的结果；其次是确认，确认自己的理解正确；最后总结自己的回答。</p>
</blockquote>
<ol>
<li>如何克服困难？</li>
</ol>
<blockquote>
<p>问题在于克服的方式。通过工具？通过合作？等待，具体事例辅佐。</p>
</blockquote>
<ol>
<li>什么时候压力大？来源是什么？</li>
</ol>
<blockquote>
<p>问题不在克服问题的流程，在于压力来源原因的分析，最后辅以客服的案例。</p>
</blockquote>
<ol>
<li>为什么选择运维？然而你的经历是后端？</li>
</ol>
<blockquote>
<p>今天的经历告诉自己，缘分。哈哈~</p>
</blockquote>
<ol>
<li>自己的问的问题。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;滴滴现场面试记录&quot;&gt;&lt;a href=&quot;#滴滴现场面试记录&quot; class=&quot;headerlink&quot; title=&quot;滴滴现场面试记录&quot;&gt;&lt;/a&gt;滴滴现场面试记录&lt;/h1
    
    </summary>
    
      <category term="面试记录" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
      <category term="didi" scheme="http://lincentma.men/tags/didi/"/>
    
  </entry>
  
  <entry>
    <title>网易游戏笔试记录</title>
    <link href="http://lincentma.men/neteasegame_writeexam.html"/>
    <id>http://lincentma.men/neteasegame_writeexam.html</id>
    <published>2017-09-18T18:25:45.000Z</published>
    <updated>2017-09-18T18:26:53.465Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="网易游戏笔试记录"><a href="#网易游戏笔试记录" class="headerlink" title="网易游戏笔试记录"></a>网易游戏笔试记录</h1><blockquote>
<p>看到试卷要求，有句话，基础部分达不到及格线直接淘汰，基础细节最重要，太多细节没有掌握。</p>
</blockquote>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="1-线程1执行n-n-线程2执行n-2-在没有锁的保证下，最后n的结果可能是几？"><a href="#1-线程1执行n-n-线程2执行n-2-在没有锁的保证下，最后n的结果可能是几？" class="headerlink" title="1. 线程1执行n++;n++; 线程2执行n+=2; 在没有锁的保证下，最后n的结果可能是几？"></a>1. 线程1执行n++;n++; 线程2执行n+=2; 在没有锁的保证下，最后n的结果可能是几？</h3><blockquote>
<p>i++的线程安全性可以总结如下：<br>1) 如果i是局部变量，那么是可重入的，也就是线程安全的。<br>2) 如果i是全局变量，则同一进程的不同线程都可能访问到该变量，因而是线程不安全的。 </p>
<p>i++不是原子操作，原因是：</p>
<p>i++操作分为三个阶段(读、改、写)：</p>
<p>1) 内存到寄存器<br>2) 寄存器自增<br>3) 写回内存</p>
<p>这三个阶段可以被中断分离。</p>
<ol>
<li>情况1：两个线程串行执行，无交叉，结果为4。</li>
<li>情况2：线程1执行n++后被打断，线程2开始执行，于是线程开始执行n+2，再将结果3写回内存前被打断，执行线程1的第二个n++，这个时候内存中的n为2，然后线程2开始执行写回3，结果是3。</li>
<li>情况3：线程2先执行取得n为0后开始运算加2操作，之后在将结果写回内存前被打断，执行线程1，线程1执行结束n的内存为2，这个时候线程2被恢复，将运算结果2再次写回内存，最后结果是2。</li>
</ol>
</blockquote>
<ul>
<li>参考文章：<a href="http://blog.csdn.net/myblog_dwh/article/details/12837089" target="_blank" rel="external"></a></li>
</ul>
<h3 id="2-数据库ACID"><a href="#2-数据库ACID" class="headerlink" title="2. 数据库ACID"></a>2. 数据库ACID</h3><blockquote>
<p>事务(transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p>
<ol>
<li>原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。</li>
<li>一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</li>
<li>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</li>
<li>持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</li>
</ol>
</blockquote>
<h3 id="3-哪一种数据结构是删除最小元素和添加新元素的时间复杂度是O-logn-？"><a href="#3-哪一种数据结构是删除最小元素和添加新元素的时间复杂度是O-logn-？" class="headerlink" title="3. 哪一种数据结构是删除最小元素和添加新元素的时间复杂度是O(logn)？"></a>3. 哪一种数据结构是删除最小元素和添加新元素的时间复杂度是O(logn)？</h3><blockquote>
<p>小根堆数据结构。删除和添加本身是O（1），调整是整个树的深度，为O（logN） </p>
</blockquote>
<h3 id="4-关于分页和分段？"><a href="#4-关于分页和分段？" class="headerlink" title="4. 关于分页和分段？"></a>4. 关于分页和分段？</h3><blockquote>
<p>分页就是将进程的逻辑地址空间分成若干大小相等的片（即页），然后装入内存。</p>
<p>分段就是用户可以把自己的作业按逻辑关系划分为若干个段,每个段都是从0开始编址,并有自己的名字和长度。这就相当于程序里边的主函数段、各个子函数段、数据段、栈段等等。</p>
<p>页是信息的物理单位，段是信息的逻辑单位。</p>
<p>分页的作业地址空间是一维的,线性的,程序员只需利用一个记忆符表示一个地址；而分段的作业地址空间是二维的,程序员在表示一个地址的时候既要给出段名,又需要给出段内地址.其中,段名可以理解为函数名等，段内地址可以理解程变量等的地址。</p>
</blockquote>
<h3 id="5-采取LRU策略，缺页次数？"><a href="#5-采取LRU策略，缺页次数？" class="headerlink" title="5. 采取LRU策略，缺页次数？"></a>5. 采取LRU策略，缺页次数？</h3><blockquote>
<p>在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。 </p>
<p>LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面上次被访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中其t值最大的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">以下用x表示缺页的情况</div><div class="line">1.S=3</div><div class="line">3,4,2,1,4,5,3,4,5,1,2</div><div class="line">---------------------</div><div class="line">3 4 2 1 4 5 3 4 5 1 2</div><div class="line">  3 4 2 1 4 5 3 3 5 1</div><div class="line">    3 4 2 1 4 5 4 3 5</div><div class="line">x x x x   x x     x x</div><div class="line">所以F=8</div><div class="line">2.S=4</div><div class="line">3,4,2,1,4,5,3,4,5,1,2</div><div class="line">---------------------</div><div class="line">3 4 2 1 4 5 3 4 5 1 2</div><div class="line">  3 4 2 1 4 5 3 3 3 1</div><div class="line">    3 4 2 1 4 5 4 5 3</div><div class="line">      3 3 2 1 1 1 4 5</div><div class="line">x x x x   x x       x</div><div class="line">所以F=7</div></pre></td></tr></table></figure>
<h3 id="6-如何统计指定目录下只包含小写字母的后缀为c的文件的个数？"><a href="#6-如何统计指定目录下只包含小写字母的后缀为c的文件的个数？" class="headerlink" title="6. 如何统计指定目录下只包含小写字母的后缀为c的文件的个数？"></a>6. 如何统计指定目录下只包含小写字母的后缀为c的文件的个数？</h3><blockquote>
<p>没有子目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ls *.txt | wc -l</div><div class="line"></div><div class="line">find . -name &quot;*.txt&quot; | wc -l</div></pre></td></tr></table></figure></p>
<p>子目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -type f -name &quot;*.txt&quot; | wc -l</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="7-如何更改指定目录以及其子文件的拥有者名字？"><a href="#7-如何更改指定目录以及其子文件的拥有者名字？" class="headerlink" title="7. 如何更改指定目录以及其子文件的拥有者名字？"></a>7. 如何更改指定目录以及其子文件的拥有者名字？</h3><blockquote>
<p>对Document/ 目录下的所有文件与子目录执行相同的所有者变更，修改所有者为users用户组的username用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chown -R users Document/</div><div class="line">PS: 必须是R不是r</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="8-echo-‘2’-print-2-3-的输出结果是什么？"><a href="#8-echo-‘2’-print-2-3-的输出结果是什么？" class="headerlink" title="8. echo ‘2’.print(2)+3; 的输出结果是什么？"></a>8. echo ‘2’.print(2)+3; 的输出结果是什么？</h3><blockquote>
<ol>
<li>首先计算的是 右边print(2)+3，这个你可以直接理解成print(2+3),得到的结果是5。而print是一个函数，它的返回值总是1。</li>
<li>第二步就是echo ‘2’.print(‘结果’)(返回值是1)，因此会得到21的结果。</li>
<li>第三步就是将之前计算的结果进行连接，并最终进行输出，得到的结果就是521了。</li>
</ol>
</blockquote>
<ul>
<li>参考文章：<a href="http://blog.csdn.net/whq19890827/article/details/52791799" target="_blank" rel="external">echo ‘1’.print(2)+3; 的输出结果为什么是511</a></li>
</ul>
<h3 id="9-Dajano查询优化函数？"><a href="#9-Dajano查询优化函数？" class="headerlink" title="9. Dajano查询优化函数？"></a>9. Dajano查询优化函数？</h3><blockquote>
<p>在数据库有外键的时候，使用 select_related() 和 prefetch_related() 可以很好的减少数据库请求的次数，从而提高性能。</p>
<p>对于一对一字段（OneToOneField）和外键字段（ForeignKey），可以使用select_related 来对QuerySet进行优化。</p>
<p>select_related使用SQL的JOIN语句进行优化，通过减少SQL查询的次数来进行优化、提高性能。</p>
<p>prefetch_related()的解决方法是，分别查询每个表，然后用Python处理他们之间的关系。</p>
</blockquote>
<h3 id="10-nginx查询日志每秒IP访问次数"><a href="#10-nginx查询日志每秒IP访问次数" class="headerlink" title="10. nginx查询日志每秒IP访问次数"></a>10. nginx查询日志每秒IP访问次数</h3><blockquote>
<p>nginx access.log 日志格式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">100.109.195.91 - - [17/Feb/2017:00:08:11 +0800] &quot;GET /data/upload/shop/common/loading.gif HTTP/1.0&quot; 200 134 &quot;http://www.mall121.com/&quot; &quot;Mozilla/4.0 (compatible; MSIE 8.0; Trident/4.0; Windows NT 6.1; SLCC2 2.5.5231; .NET CLR 2.0.50727; .NET CLR 4.1.23457; .NET CLR 4.0.23457; Media Center PC 6.0; MS-WK 8)&quot; &quot;140.205.201.12&quot; </div><div class="line"></div><div class="line">1.客户端（用户）IP地址。</div><div class="line">2.访问时间。</div><div class="line">3.访问端口。</div><div class="line">4.响应时间。</div><div class="line">5.请求时间。</div><div class="line">6.用户地理位置代码（国家代码）。</div><div class="line">7.请求的url地址（目标url地址）的host。</div><div class="line">8.请求方式（GET或者POST等）。</div><div class="line">9.请求url地址（去除host部分）。</div><div class="line">10.请求状态（状态码，200表示成功)。</div><div class="line">11.请求页面大小，默认为B（byte）。</div><div class="line">12.来源页面，即从哪个页面转到本页，专业名称叫做“referer”。</div><div class="line">13.用户浏览器语言。如：上例中的 &quot;es-ES,es;q=0.8&quot;</div><div class="line">14.用户浏览器其他信息，浏览器版本、浏览器类型等。</div></pre></td></tr></table></figure>
<blockquote>
<p>根据访问IP统计UV<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk &apos;&#123;print $1&#125;&apos;  access.log|sort | uniq -c |wc -l</div></pre></td></tr></table></figure></p>
<p>统计访问URL统计PV<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk &apos;&#123;print $7&#125;&apos; access.log|wc -l</div></pre></td></tr></table></figure></p>
<p>查询访问最频繁的URL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk &apos;&#123;print $7&#125;&apos; access.log|sort | uniq -c |sort -n -k 1 -r|more</div></pre></td></tr></table></figure></p>
<p>查询访问最频繁的IP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk &apos;&#123;print $1&#125;&apos; access.log|sort | uniq -c |sort -n -k 1 -r|more</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="11-POST对于Get的5个优点？"><a href="#11-POST对于Get的5个优点？" class="headerlink" title="11. POST对于Get的5个优点？"></a>11. POST对于Get的5个优点？</h3><blockquote>
<ol>
<li>Post编码类型：application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</li>
<li>Post对数据长度无限制。</li>
<li>Post对对数据类型无限制，也允许二进制数据。</li>
<li>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</li>
<li>Post数据不会显示在 URL 中。</li>
</ol>
</blockquote>
<h3 id="12-Java实现tail-f？"><a href="#12-Java实现tail-f？" class="headerlink" title="12. Java实现tail -f？"></a>12. Java实现tail -f？</h3><blockquote>
<p>设计思路：</p>
<ol>
<li>利用FileInputStream的skip方法，可以跳过文件的部分内容，实现tail命令的读取最后几行的功能。利用while(true)循环，实现tail命令的-f功能，读取后续写入的内容。</li>
<li>利用RandomAccessFile，在代码中记录文件先前的大小，定时查看文件大小是否发生变化，如果是，则读取新的内容部分（利用RandomAccessFile的seek方法跳过之前已经读取的内容）。</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">String srcFilename = &quot;E:\\tmp2\\1.txt&quot;;  </div><div class="line">String charset = &quot;GBK&quot;;  </div><div class="line">File file = new File(srcFilename);  </div><div class="line">InputStream fileInputStream = new FileInputStream(srcFilename);  </div><div class="line">fileInputStream.skip(1); // skip n bytes if needed, filesystem may position to the offset directly but not read really.  </div><div class="line">BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(fileInputStream, charset));  </div><div class="line">String singleLine;  </div><div class="line">long fileSize = file.length();  </div><div class="line">while (true) &#123;  </div><div class="line">    try &#123;  </div><div class="line">        if ((singleLine = bufferedReader.readLine()) != null) &#123;  </div><div class="line">            System.out.println(singleLine);  </div><div class="line">            fileSize = Math.max(file.length(), fileSize);  </div><div class="line">            continue;  </div><div class="line">        &#125;  </div><div class="line">    &#125; catch (IOException e) &#123; // 文件被清空的时候FileInputStream会被close  </div><div class="line">        bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(srcFilename), charset));  </div><div class="line">        fileSize = file.length();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">    try &#123;  </div><div class="line">        if (file.length() &lt; fileSize) &#123; // 文件被清空了  </div><div class="line">            bufferedReader.close();  </div><div class="line">            bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(srcFilename), charset));  </div><div class="line">            fileSize = file.length();  </div><div class="line">        &#125;  </div><div class="line">        Thread.sleep(1000L);  </div><div class="line">    &#125; catch (InterruptedException e) &#123;  </div><div class="line">        Thread.currentThread().interrupt();  </div><div class="line">        bufferedReader.close();  </div><div class="line">        break;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>参考文章：</li>
</ul>
<ol>
<li><a href="http://blog.csdn.net/xxgwo/article/details/51198113" target="_blank" rel="external">Java实现linux的“tail -f”命令</a></li>
<li><a href="http://blog.csdn.net/youling_lh/article/details/9414117" target="_blank" rel="external">用RandomAccessFile实现linux tail命令效果</a></li>
</ol>
<h3 id="13-数据库索引查询速度快的原因？"><a href="#13-数据库索引查询速度快的原因？" class="headerlink" title="13. 数据库索引查询速度快的原因？"></a>13. 数据库索引查询速度快的原因？</h3><blockquote>
<p>索引就是通过事先排好序，从而在查找时可以应用二分查找等高效率的算法。</p>
<p>索引B+树，顺序存储，查询时间复杂度O(logn)</p>
<p>等于查一个比较小的表。</p>
</blockquote>
<h3 id="14-Java中浮点数0-1-0-2-！-0-3。如何比较浮点数大小"><a href="#14-Java中浮点数0-1-0-2-！-0-3。如何比较浮点数大小" class="headerlink" title="14. Java中浮点数0.1 + 0.2 ！= 0.3。如何比较浮点数大小"></a>14. Java中浮点数0.1 + 0.2 ！= 0.3。如何比较浮点数大小</h3><blockquote>
<p>根据IEEE 754，单精度的float是32位，双精度的double为64位。</p>
<p>1) 第一部分(s)为符号位，第二部分(exponent)为指数位，第三部分(mantissa)为基数部分。 这是科学计数法的二进制表示。<br>那么，既然位数是固定的，要表示像 1/3=0.3333333333333…或者pi=3.1415926….. 这样的无限循环小数，就变得不可能了。<br>根据规范，则需要将不能标识的部分舍掉。</p>
<p>2) 还与10进制不同的是，二进制对于一些有限的小数，也不能精确的标示。比如像0.1这样的小数，用二进制也无法精确表示。所以，也需要舍掉。<br>关于0.1无法用二进制精确表示</p>
<p>在进行浮点数比较的时候，主要需要考虑3个因素</p>
<ol>
<li>NaN</li>
<li>无穷大/无穷小</li>
<li>舍入误差</li>
</ol>
<p>排除NaN和无穷、在精度范围内进行比较</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public boolean isEqual(double a, double b) &#123;  </div><div class="line">    if (Double.isNaN(a) || Double.isNaN(b) || Double.isInfinite(a) || Double.isInfinite(b)) &#123;  </div><div class="line">        return false;  </div><div class="line">    &#125;  </div><div class="line">    return (a - b) &lt; 0.001d;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>BigDecimal的解决方案就是，不使用二进制，而是使用十进制（BigInteger）+小数点位置(scale)来表示小数。<br>BigDecimal这个类。它什么都好，就是效率略低。<br>使用BigDecimal的时候，要么使用newBigDecimal(String value)，要么使用BigDecimal.valueof(doublevalue)。</p>
</blockquote>
<ul>
<li>参考文章：<a href="http://blog.csdn.net/dodott/article/details/53410756" target="_blank" rel="external">Java中的浮点数比较</a></li>
</ul>
<h3 id="15-如何设计一个抢红包系统，高可用，高并发，容灾机制"><a href="#15-如何设计一个抢红包系统，高可用，高并发，容灾机制" class="headerlink" title="15. 如何设计一个抢红包系统，高可用，高并发，容灾机制"></a>15. 如何设计一个抢红包系统，高可用，高并发，容灾机制</h3><ul>
<li>参考文章：<a href="http://blog.csdn.net/neo_liu0000/article/details/55653424" target="_blank" rel="external">百亿级微信红包的高并发资金交易系统设计方案</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;网易游戏笔试记录&quot;&gt;&lt;a href=&quot;#网易游戏笔试记录&quot; class=&quot;headerlink&quot; title=&quot;网易游戏笔试记录&quot;&gt;&lt;/a&gt;网易游戏笔试记录&lt;/h1
    
    </summary>
    
      <category term="笔试记录" scheme="http://lincentma.men/categories/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="netease" scheme="http://lincentma.men/tags/netease/"/>
    
      <category term="exam" scheme="http://lincentma.men/tags/exam/"/>
    
  </entry>
  
  <entry>
    <title>猎豹移动二面</title>
    <link href="http://lincentma.men/cheetah_mobile_interview_2.html"/>
    <id>http://lincentma.men/cheetah_mobile_interview_2.html</id>
    <published>2017-09-16T16:32:10.000Z</published>
    <updated>2017-09-16T16:34:41.283Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="猎豹移动二面"><a href="#猎豹移动二面" class="headerlink" title="猎豹移动二面"></a>猎豹移动二面</h1><blockquote>
<p>问题回答只会回答基本面，细节不充分是自己的弱项</p>
</blockquote>
<h2 id="前面的有些忘记了，，，-zzz"><a href="#前面的有些忘记了，，，-zzz" class="headerlink" title="前面的有些忘记了，，，{[(-_-)(-_-)]}zzz"></a>前面的有些忘记了，，，{[(-_-)(-_-)]}zzz</h2><h3 id="1-Tornado框架介绍"><a href="#1-Tornado框架介绍" class="headerlink" title="1. Tornado框架介绍"></a>1. Tornado框架介绍</h3><blockquote>
<p>Tornado是使用Python编写的一个强大的、可扩展的Web服务器。它在处理严峻的网络流量时表现得足够强健，但却在创建和编写时有着足够的轻量级，并能够被用在大量的应用和工具中。</p>
<p>基本流程：</p>
<ol>
<li>执行脚本，监听 8888 端口</li>
<li>浏览器客户端访问 /index  –&gt;  <a href="http://127.0.0.1:8888/index" target="_blank" rel="external">http://127.0.0.1:8888/index</a></li>
<li>服务器接受请求，并交由对应的类处理该请求</li>
<li>类接受到请求之后，根据请求方式（post(请求) / get（获取） / delete（删除） / pot（设置））的不同调用并执行相应的方法</li>
<li>方法返回值的字符串内容发送浏览器</li>
</ol>
<p>example<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># -*- coding:utf-8 -*-</div><div class="line">   </div><div class="line">import tornado.ioloop</div><div class="line">import tornado.web</div><div class="line">   </div><div class="line">   </div><div class="line">class MainHandler(tornado.web.RequestHandler):</div><div class="line">    def get(self):</div><div class="line">        self.write(&quot;Hello, world&quot;)</div><div class="line">   </div><div class="line">application = tornado.web.Application([</div><div class="line">    (r&quot;/index&quot;, MainHandler),</div><div class="line">])</div><div class="line">   </div><div class="line">   </div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    application.listen(8888)</div><div class="line">    tornado.ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="2-Supervisor功能作用"><a href="#2-Supervisor功能作用" class="headerlink" title="2. Supervisor功能作用"></a>2. Supervisor功能作用</h3><blockquote>
<p>supervisor是用python开发的进程管理程序，可以将普通的命令变成后台的守护进程，并监控进程状态。</p>
<p>使用流程：</p>
<ol>
<li>安装supervisor</li>
<li><p>编写应用程序配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[program:app]</div><div class="line">command=/usr/bin/gunicorn -w 1 wsgiapp:application</div><div class="line">directory=/srv/www</div><div class="line">user=www-data</div></pre></td></tr></table></figure>
</li>
<li><p>重启supervisor，让配置文件生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># supervisorctl start app</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h3 id="3-nginx如何实现请求转发"><a href="#3-nginx如何实现请求转发" class="headerlink" title="3. nginx如何实现请求转发"></a>3. nginx如何实现请求转发</h3><blockquote>
<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。  </p>
<p>nginx 配置文件：vim /etc/nginx/nginx.conf</p>
<p>例如tornado会启动三个进程，分别侦听8001, 8002, 8003三个端口。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream tornado.server &#123;</div><div class="line">   server 127.0.0.1:8001;</div><div class="line">   server 127.0.0.1:8002;</div><div class="line">   server 127.0.0.1:8003;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 反向代理配置</div><div class="line">    location / &#123;</div><div class="line">    proxy_pass_header Server;</div><div class="line">    proxy_set_header Host $http_host;</div><div class="line">    proxy_set_header X-Real-IP $remote_addr;</div><div class="line">    proxy_set_header X-Scheme $scheme;</div><div class="line">    proxy_pass http://tornado.server;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>upstream指令主要用于负载均衡，设置一系列的后端服务器。nginx 的 upstream默认是以轮询的方式实现负载均衡，这种方式中，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。此外还有ip_hash、weight、url_hash、fair等负载均衡策略。</p>
</blockquote>
<h3 id="4-Hadoop的MapReduce运行过程中，如果存在某些key过于集中，是否会使得MapReduce任务执行失败？为什么？"><a href="#4-Hadoop的MapReduce运行过程中，如果存在某些key过于集中，是否会使得MapReduce任务执行失败？为什么？" class="headerlink" title="4. Hadoop的MapReduce运行过程中，如果存在某些key过于集中，是否会使得MapReduce任务执行失败？为什么？"></a>4. Hadoop的MapReduce运行过程中，如果存在某些key过于集中，是否会使得MapReduce任务执行失败？为什么？</h3><blockquote>
<p>mapreduce处理过程有一个特点，相同的key，只能是发给同一个reduce进行处理。</p>
<p>原因：hadoop源码中有一行代码，(key.hashcode())%numReduce，先把key进行hash然后除以reduce的个数取余，相同的key的hashcode肯定一样，而且reduce数也确认，那肯定是相同的key都发给了同一个reduce了。</p>
<p>而对于提交的作业(job)什么时候才算运行结束呢?是要等到最后一个reduce执行完，才算结束。所以执行量小的reduce先执行完了，也得等着，等着量最大的、最慢的执行完，才能够算结束。</p>
</blockquote>
<h3 id="5-你对于NoSQL的了解？"><a href="#5-你对于NoSQL的了解？" class="headerlink" title="5. 你对于NoSQL的了解？"></a>5. 你对于NoSQL的了解？</h3><blockquote>
<p>NoSQL(NoSQL = Not Only SQL )，意即”不仅仅是SQL”。</p>
<p>CAP理论。</p>
</blockquote>
<p><img src="http://www.runoob.com/wp-content/uploads/2013/10/cap-theoram-image.png" alt=""></p>
<blockquote>
<p>NoSQL数据库分类</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>部分代表</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>列存储</td>
<td>Hbase</td>
<td>顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。</td>
</tr>
<tr>
<td></td>
<td>Cassandra</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Hypertable</td>
<td></td>
</tr>
<tr>
<td>文档存储</td>
<td>MongoDB</td>
<td>文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有有机会对某些字段建立索引，实现关系数据库的某些功能。</td>
</tr>
<tr>
<td></td>
<td>CouchDB</td>
<td></td>
</tr>
<tr>
<td>key-value存储</td>
<td>Tokyo Cabinet / Tyrant</td>
<td>可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能）</td>
</tr>
<tr>
<td></td>
<td>Berkeley DB</td>
<td></td>
</tr>
<tr>
<td></td>
<td>MemcacheDB</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Redis</td>
<td></td>
</tr>
<tr>
<td>图存储</td>
<td>Neo4J</td>
<td>图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。</td>
</tr>
<tr>
<td></td>
<td>FlockDB</td>
<td></td>
</tr>
<tr>
<td>对象存储</td>
<td>db4o</td>
<td>通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。</td>
</tr>
<tr>
<td></td>
<td>Versant</td>
<td></td>
</tr>
<tr>
<td>xml数据库</td>
<td>Berkeley DB XML</td>
<td>高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。</td>
</tr>
<tr>
<td></td>
<td>BaseX</td>
</tr>
</tbody>
</table>
<h3 id="6-Redis-key过期如何设置？"><a href="#6-Redis-key过期如何设置？" class="headerlink" title="6. Redis key过期如何设置？"></a>6. Redis key过期如何设置？</h3><blockquote>
<p>EXPIRE key seconds</p>
<p>为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。 </p>
<p>可以对一个已经带有生存时间的  key  执行 EXPIRE 命令，新指定的生存时间会取代旧的生存时间。</p>
<p>TTL key    # 查看剩余生存时间</p>
<p>如果没有设置时间，那缓存就是永不过期。</p>
<p>PERSIST key</p>
<p>移除给定 key 的生存时间，将这个 key 从『易失的』(带生存时间 key )转换成『持久的』(一个不带生存时间、永不过期的 key )。</p>
</blockquote>
<h3 id="7-Redis-key过期有哪几种？"><a href="#7-Redis-key过期有哪几种？" class="headerlink" title="7. Redis key过期有哪几种？"></a>7. Redis key过期有哪几种？</h3><blockquote>
<ol>
<li>被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key</li>
<li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key</li>
<li><p>当前已用内存超过maxmemory限定时，触发主动清理策略</p>
</li>
<li><p>定时删除</p>
</li>
</ol>
<p>含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除</p>
<p>优点：保证内存被尽快释放</p>
<p>缺点：若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key<br>定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重</p>
<ol>
<li>惰性删除</li>
</ol>
<p>含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。</p>
<p>优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）</p>
<p>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</p>
<ol>
<li>定期删除</li>
</ol>
<p>含义：每隔一段时间执行一次删除过期key操作</p>
<p>优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点。定期删除过期key–处理”惰性删除”的缺点</p>
<p>缺点:在内存友好方面，不如”定时删除”;在CPU时间友好方面，不如”惰性删除”</p>
</blockquote>
<h3 id="8-Shell常用命令你用过哪些？"><a href="#8-Shell常用命令你用过哪些？" class="headerlink" title="8. Shell常用命令你用过哪些？"></a>8. Shell常用命令你用过哪些？</h3><blockquote>
<p>ls: 类似于dos下的dir命令;</p>
<p>cd: 用于切换用户当前工作目录;</p>
<p>pwd：用于显示用户当前工作目录;</p>
<p>midir：创建目录;rmdir：删除目录;</p>
<p>cp：复制命令;</p>
<p>mv：移动命令;</p>
<p>rm：用于删除文件;</p>
<p>du：显示目前的目录所占用的磁盘空间;df：显示目前磁盘剩余空间;</p>
<p>cat：显示或连接一般的ascii文本文件;</p>
<p>head：显示文件的头n行;tail：显示文件的尾n行，缺省情况n都为10行;</p>
<p>wc：统计指定文件中的字节数(-c)、字数(-w)、行数(-l);</p>
<p>grep：用于从文件面搜索包含指定模式的行并打印出来，它是一种强大的文本搜索工具，支持使用正则表达式搜索文本;</p>
<p>管道：利用Linux所提供的管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入;</p>
<p>awk：awk比sed强的地方在于不仅能以行为单位还能以列为单位处理文件。awk ‘{pattern + action}’ {filenames}</p>
<p>sed：(关键字: 编辑) 以行为单位的文本编辑工具。基本工作方式: sed [-nef] ‘[动作]’ [输入文本]</p>
<p>ln -sf  a  b：b链向a;</p>
</blockquote>
<h3 id="1-文本，每一行五个列，根据第二列排重，统计之后，倒序输出，取前100个。"><a href="#1-文本，每一行五个列，根据第二列排重，统计之后，倒序输出，取前100个。" class="headerlink" title="1. 文本，每一行五个列，根据第二列排重，统计之后，倒序输出，取前100个。"></a>1. 文本，每一行五个列，根据第二列排重，统计之后，倒序输出，取前100个。</h3><blockquote>
<p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat 0916.txt | awk &apos;&#123;print $2&#125;&apos;| uniq -c | sort -r | awk &apos;&#123;print $2,$1&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1       1       1       1       1</div><div class="line">2       2       2       2       2</div><div class="line">3       3       3       3       3</div><div class="line">4       4       4       4       4</div><div class="line">4       4       4       4       4</div><div class="line">4       4       4       4       4</div><div class="line">4       4       4       4       4</div><div class="line">5       5       5       5       5</div><div class="line">5       5       5       5       5</div><div class="line">5       5       5       5       5</div><div class="line">5       5       5       5       5</div><div class="line">5       5       5       5       5</div><div class="line">5       5       5       5       5</div><div class="line">5       5       5       5       5</div><div class="line">5       5       5       5       5</div><div class="line">5       5       5       5       5</div><div class="line">5       5       5       5       5</div><div class="line">6       6       6       6       6</div><div class="line">6       6       6       6       6</div><div class="line">6       6       6       6       6</div><div class="line">6       6       6       6       6</div><div class="line">6       6       6       6       6</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ cat 0916.txt | awk &apos;&#123;print $2&#125;&apos;| uniq -c | sort -r | awk &apos;&#123;print $2,$1&#125;&apos;</div><div class="line">6 5</div><div class="line">4 4</div><div class="line">3 1</div><div class="line">2 1</div><div class="line">1 1</div><div class="line">5 10</div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;猎豹移动二面&quot;&gt;&lt;a href=&quot;#猎豹移动二面&quot; class=&quot;headerlink&quot; title=&quot;猎豹移动二面&quot;&gt;&lt;/a&gt;猎豹移动二面&lt;/h1&gt;&lt;blockq
    
    </summary>
    
      <category term="面试记录" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
      <category term="Cheetah-Mobile" scheme="http://lincentma.men/tags/Cheetah-Mobile/"/>
    
  </entry>
  
  <entry>
    <title>招银科技一面</title>
    <link href="http://lincentma.men/%E2%80%9Czhaoyinkeji_interview%E2%80%9D.html"/>
    <id>http://lincentma.men/“zhaoyinkeji_interview”.html</id>
    <published>2017-09-14T15:57:57.000Z</published>
    <updated>2017-09-14T16:00:06.411Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="招银科技一面"><a href="#招银科技一面" class="headerlink" title="招银科技一面"></a>招银科技一面</h1><blockquote>
<p>主要是基础知识，有些细节自己没有掌握牢固，温故知新</p>
</blockquote>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h3 id="1-你了解过Java的序列化吗？"><a href="#1-你了解过Java的序列化吗？" class="headerlink" title="1. 你了解过Java的序列化吗？"></a>1. 你了解过Java的序列化吗？</h3><blockquote>
<p>Java 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后，仍可以将字节数组转换回 Java 对象原有的状态。实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。</p>
</blockquote>
<h3 id="2-Java序列化的用途以及使用场景？"><a href="#2-Java序列化的用途以及使用场景？" class="headerlink" title="2. Java序列化的用途以及使用场景？"></a>2. Java序列化的用途以及使用场景？</h3><blockquote>
<p>1.当对象需要被网络传输时<br>2.对象状态需要被持久化时</p>
<p>围绕根本，就有很多实际的拓展应用，例如：</p>
<p>tomcat服务器会在服务器关闭时把session序列化存储到tomcat目录一个名为session.ser的文件中，这个过程成为session的钝化，因为有些时候当我们要重新部署项目的时候，有的用户可能在访问，这样做的目的是服务器重启之后tomcat可以反序列化这个session.ser文件，将session对象重新生成出来，用户可以使用部署之前的session进行操作，这个反序列化的过程成为session的活化。</p>
<p>分布式应用。</p>
</blockquote>
<h3 id="3-类序列化需要实现什么接口？"><a href="#3-类序列化需要实现什么接口？" class="headerlink" title="3. 类序列化需要实现什么接口？"></a>3. 类序列化需要实现什么接口？</h3><blockquote>
<p>Serializable接口。</p>
</blockquote>
<h3 id="4-该类实现了这个接口，那么子类可以序列化吗？"><a href="#4-该类实现了这个接口，那么子类可以序列化吗？" class="headerlink" title="4. 该类实现了这个接口，那么子类可以序列化吗？"></a>4. 该类实现了这个接口，那么子类可以序列化吗？</h3><blockquote>
<p>父类实现了Serializable，子类不需要实现Serializable接口。</p>
</blockquote>
<h3 id="5-当序列化后修改serialVersionUID，还可以反序列化回来吗"><a href="#5-当序列化后修改serialVersionUID，还可以反序列化回来吗" class="headerlink" title="5. 当序列化后修改serialVersionUID，还可以反序列化回来吗?"></a>5. 当序列化后修改serialVersionUID，还可以反序列化回来吗?</h3><blockquote>
<p>序列化的时候系统会把当前类的serialVersionUID 写入序列化的文件中（也可能是其他中介），当反序列化的时候系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化，否则就说明当前类和序列化的类相比发生了某些变换，比如成员变量的数量，类型可能发生了改变，这个时候就会抛异常，反序列化失败。</p>
<p>默认情况下，也就是不声明serialVersionUID属性情况下，系统会按当前类的成员变量计算hash值并赋值给serialVersionUID。声明serialVersionUID，可以很大程度上避免反序列化过程的失败。比如当版本升级后，我们可能删除了某个成员变量，也可能增加了一些新的成员变量，这个时候我们的反序列化依然能够成功，程序依然能够最大程度地恢复数据，相反，如果不指定serialVersionUID，程序就会挂掉。当然我们还要考虑另外一种情况，如果类结构发生了非常规性改变，比如修改了类名，类型等，这个时候尽管serialVersionUID验证通过了，但是反序列化过程还是会失败，因为类结构有了毁灭性的改变。</p>
<p>serialVersionUID一般默认设置为固定的 1L。</p>
<p>Java序列化允许java类中的一些变化，如果他们可以被忽略的话。一些不会影响到反序列化处理的变化有：</p>
<ol>
<li>在类中添加一些新的变量。</li>
<li>将变量从transient转变为非tansient，对于序列化来说，就像是新加入了一个变量而已。</li>
<li>将变量从静态的转变为非静态的，对于序列化来说，就也像是新加入了一个变量而已。</li>
</ol>
<p>总结，serialVersionUID不一致，反序列化报错。对象序列化后更改值同样也可以读取到，序列化并不保存静态变量，可以接受一些类变量的增加操作不影响反序列化。</p>
</blockquote>
<h3 id="6-Java序列化相对于其他数据交换的方式有哪些缺点？"><a href="#6-Java序列化相对于其他数据交换的方式有哪些缺点？" class="headerlink" title="6. Java序列化相对于其他数据交换的方式有哪些缺点？"></a>6. Java序列化相对于其他数据交换的方式有哪些缺点？</h3><blockquote>
<p>Java序列化写入不仅是完整的类名，也包含整个类的定义，包含所有被引用的类。一旦类定义较多，空间占用大。<br>同时Java序列化为二进制对文件，序列化后内容都是不可读的，这会对系统的排错造成一定的影响。<br>优点是转换效率高。</p>
<p>JSON以固定的格式，稳定简单的数据结构大大简化了序列化过程。<br>缺点是转换效率低。</p>
</blockquote>
<h3 id="7-classloader加载类的机制是什么？"><a href="#7-classloader加载类的机制是什么？" class="headerlink" title="7. classloader加载类的机制是什么？"></a>7. classloader加载类的机制是什么？</h3><blockquote>
<p>遵循委派双亲加载。通过调用loadClass方法逐级往上传递委派加载请求，当找不到父ClassLoader时调用其findClass方法尝试进行查找和加载，如果当前ClassLoader找不所需的Class,则由其孩子尝试进行查找和加载，如果当前ClassLoader找了所需的Class则将该Class按请求路径逐级返回孩子。</p>
</blockquote>
<h3 id="8-你的意思是jar包中的类不一定会全部加载？系统提供-例如JDK、String-的类是由哪一个加载器加载的？EXT加载哪些类？如果我自定义一个类加载区，它的父加载区是哪一个？"><a href="#8-你的意思是jar包中的类不一定会全部加载？系统提供-例如JDK、String-的类是由哪一个加载器加载的？EXT加载哪些类？如果我自定义一个类加载区，它的父加载区是哪一个？" class="headerlink" title="8. 你的意思是jar包中的类不一定会全部加载？系统提供(例如JDK、String)的类是由哪一个加载器加载的？EXT加载哪些类？如果我自定义一个类加载区，它的父加载区是哪一个？"></a>8. 你的意思是jar包中的类不一定会全部加载？系统提供(例如JDK、String)的类是由哪一个加载器加载的？EXT加载哪些类？如果我自定义一个类加载区，它的父加载区是哪一个？</h3><blockquote>
<p>Java动态加载。Bootstrap ClassLoader。EXT加载JRE\lib\ext*.jar。拥堵自定义的类加载器的父类为系统加载器。</p>
<p><img src="http://images.cnitblog.com/blog/347002/201502/110912451518649.gif" alt=""></p>
<p>JVM本身包含了一个ClassLoader称为Bootstrap ClassLoader，和JVM一样，BootstrapClassLoader是用本地代码实现的，它负责加载核心JavaClass(即所有java.*开头的类)。——Load JRE\lib\rt.jar</p>
<p>另外JVM还会提供两个ClassLoader，它们都是用Java语言编写的，由BootstrapClassLoader加载;其中Extension ClassLoader负责加载扩展的Javaclass(例如所有javax.*开头的类和存放在JRE的ext目录下的类)</p>
<p>ApplicationClassLoader负责加载应用程序自身的类。</p>
</blockquote>
<h3 id="9-classLoad加载class文件一般分为哪几个阶段？"><a href="#9-classLoad加载class文件一般分为哪几个阶段？" class="headerlink" title="9. classLoad加载class文件一般分为哪几个阶段？"></a>9. classLoad加载class文件一般分为哪几个阶段？</h3><blockquote>
<p>当使用到某个类，但该类还未初始化，未加载到内存中时会经历类加载、链接、初始化三个步骤完成类的初始化。</p>
<p>类加载：</p>
<ul>
<li>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器。<br>只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。</li>
</ul>
<p>类的链接：</p>
<ul>
<li>当类加载完成后，系统会给为之生成一个对象；随后进入链接阶段，链接阶段负责把类的二进制数据添加到JRE中。三个阶段：</li>
<li>验证：检验被加载的类是否有正确的内部结构，并和其他类协调一致</li>
<li>准备：负责为类的类变量分配内存。并设置默认初始值</li>
<li>解析：将类的二进制数据中的符号引用替换成直接引用</li>
</ul>
<p>类的初始化：JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
</blockquote>
<ul>
<li>声明类变量是指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
<li>JVM初始化步骤</li>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
<h3 id="10-数据库试图的作用？视图中的数据是存在视图中的吗？"><a href="#10-数据库试图的作用？视图中的数据是存在视图中的吗？" class="headerlink" title="10. 数据库试图的作用？视图中的数据是存在视图中的吗？"></a>10. 数据库试图的作用？视图中的数据是存在视图中的吗？</h3><blockquote>
<p>这个回答的不好。</p>
<p>视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。</p>
<ol>
<li>视图能简化用户操作</li>
<li>视图使用户能以多种角度看待同一数据</li>
<li>视图对重构数据库提供了一定程度的逻辑独立性</li>
<li>视图能够对机密数据提供安全保护</li>
</ol>
</blockquote>
<h3 id="11-视图的更新有没有一些限制？"><a href="#11-视图的更新有没有一些限制？" class="headerlink" title="11. 视图的更新有没有一些限制？"></a>11. 视图的更新有没有一些限制？</h3><blockquote>
<p>没有回答上来</p>
<p>利用数据库视图进行更新实质上就是对数据库的基本表进行更新。所以视图的更新update命令有很多限制。</p>
</blockquote>
<ol>
<li>若视图是由两个以上基本表导出的，则此视图不允许更新</li>
<li>若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE</li>
<li>若视图字段来自聚集函数，则此视图不允许更新</li>
<li>若视图定义中含有GROUP BY 子句，则此视图不允许更新</li>
<li>若视图中含有DISTINCT语句，则此视图不允许更新</li>
<li>若视图定义中含有嵌套查询，并且内层查询的FROM子句涉及的表也是导出该视图的基本表，则此视图不允许更新</li>
<li>一个不允许更新的视图上定义的视图也不允许更新</li>
</ol>
<h3 id="12-内联结和外联结的区别？"><a href="#12-内联结和外联结的区别？" class="headerlink" title="12. 内联结和外联结的区别？"></a>12. 内联结和外联结的区别？</h3><blockquote>
<p>内连接查询操作列出与连接条件匹配的数据行，它使用比较运算符比较被连接列的<br>列值。</p>
<p>外连接，返回到查询结果集合中的不仅包含符合连接条件的行，而且还包括左表(左<br>外连接或左连接))、右表(右外连接或右连接)或两个边接表(全外连接)中的所有数据行。 </p>
<ul>
<li>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录； </li>
<li>right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录。</li>
</ul>
</blockquote>
<h3 id="13-索引的作用"><a href="#13-索引的作用" class="headerlink" title="13. 索引的作用"></a>13. 索引的作用</h3><blockquote>
<p>优点：</p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 </li>
<li>可以大大加快 数据的检索速度，这也是创建索引的最主要的原因。 </li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 </li>
<li>在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 </li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ol>
<p>缺点：</p>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据 量的增加而增加。 </li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 </li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
</blockquote>
<h3 id="14-索引一定会加快检索速度吗？"><a href="#14-索引一定会加快检索速度吗？" class="headerlink" title="14. 索引一定会加快检索速度吗？"></a>14. 索引一定会加快检索速度吗？</h3><blockquote>
<ol>
<li>对于那些在查询中很少使用或者参考的列不应该创建索引。这是因 为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 </li>
<li>对于那 些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比 例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 </li>
<li>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 </li>
<li>当修改性能远远大于检索性能时，不应该创建索 引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因 此，当修改性能远远大于检索性能时，不应该创建索引。</li>
</ol>
</blockquote>
<h3 id="15-数据库的锁分为哪几种？"><a href="#15-数据库的锁分为哪几种？" class="headerlink" title="15. 数据库的锁分为哪几种？"></a>15. 数据库的锁分为哪几种？</h3><blockquote>
<p>锁的类型有三种： </p>
<p>共享（S)锁：多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S锁立即被释放。 </p>
<p>排它（X)锁：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。 </p>
<p>更新（U)锁：用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。</p>
</blockquote>
<h3 id="16-幻读产生场景？一般出现在什么样的事务中？"><a href="#16-幻读产生场景？一般出现在什么样的事务中？" class="headerlink" title="16. 幻读产生场景？一般出现在什么样的事务中？"></a>16. 幻读产生场景？一般出现在什么样的事务中？</h3><blockquote>
<p>不可重复读取(Non-Repeatable Reads):  A 事务两次读取同一数据，B事务也读取这同一数据，但是 A 事务在第二次读取前B事务已经更新了这一数据。所以对于A事务来说，它第一次和第二次读取到的这一数据可能就不一致了。</p>
<p>幻读(Phantom Reads): 与不可重复读有点类似，都是两次读取，不同的是 A 事务第一次操作的比如说是全表的数据，此时 B 事务并不是只修改某一具体数据而是插入了一条新数据，而后 A 事务第二次读取这全表的时候就发现比上一次多了一条数据，发生幻觉了。</p>
<p>数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 读未提交 、Read committed 读提交 、Repeatable read 重复读 、Serializable 序列化 ，这四个级别可以逐个解决脏读 、不可重复读 、幻读 这几类问题。</p>
<p>幻读出现在前三个级别中。不可重复读出现在前两个级别中。脏读出现在第一个级别中。</p>
</blockquote>
<h3 id="17-TCP如何保证重传？"><a href="#17-TCP如何保证重传？" class="headerlink" title="17. TCP如何保证重传？"></a>17. TCP如何保证重传？</h3><blockquote>
<p>每一次发送一个片段，就开启一个重传计时器。计时器有一个初始值并随时间递减。如果在片段接收到确认之前计时器超时，就重传片段。</p>
<ol>
<li><p>放置于重传队列中，计时器开始 包含数据的片段一经发送，片段的一份复制就放在名为重传队列的数据结构中，此时启动重传计时器。因此，在某些时间点，每一个片段都会放在队列里。队列按照重传计时器的剩余时间来排列，因此TCP软件可追踪那几个计时器在最短时间内超时。</p>
</li>
<li><p>确认处理 如果在计时器超时之前收到了确认信息，则该片段从重传队列中移除。</p>
</li>
<li><p>重传超时 如果在计时器超时之前没有收到确认信息，则发生重传超时，片段自动重传。当然，相比于原片段，对于重传片段并没有更多的保障机制。因此，重传之后该片段还是保留在重传队列里。重传计时器被重启，重新开始倒计时。如果重传之后没有收到确认，则片段会再次重传并重复这一过程。在某些情况下重传也会失败。我们不想要TCP永远重传下去，因此TCP只会重传一定数量的次数，并判断出现故障终止连接。</p>
</li>
</ol>
</blockquote>
<h3 id="18-域名解析过程？"><a href="#18-域名解析过程？" class="headerlink" title="18. 域名解析过程？"></a>18. 域名解析过程？</h3><blockquote>
<ol>
<li>在浏览器中输入www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 </li>
<li>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 </li>
<li>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 </li>
<li>如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 </li>
<li>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。 </li>
<li>如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 </li>
</ol>
<p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;招银科技一面&quot;&gt;&lt;a href=&quot;#招银科技一面&quot; class=&quot;headerlink&quot; title=&quot;招银科技一面&quot;&gt;&lt;/a&gt;招银科技一面&lt;/h1&gt;&lt;blockq
    
    </summary>
    
      <category term="面试记录" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
      <category term="zhaoyinkeji" scheme="http://lincentma.men/tags/zhaoyinkeji/"/>
    
  </entry>
  
  <entry>
    <title>猎豹移动一面</title>
    <link href="http://lincentma.men/cheetah_mobile_interview.html"/>
    <id>http://lincentma.men/cheetah_mobile_interview.html</id>
    <published>2017-09-14T14:08:51.000Z</published>
    <updated>2017-09-14T14:10:15.144Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="猎豹移动一面"><a href="#猎豹移动一面" class="headerlink" title="猎豹移动一面"></a>猎豹移动一面</h1><h2 id="Python项目"><a href="#Python项目" class="headerlink" title="Python项目"></a>Python项目</h2><ul>
<li>详细介绍项目流程</li>
</ul>
<h2 id="Java项目"><a href="#Java项目" class="headerlink" title="Java项目"></a>Java项目</h2><ul>
<li>详细介绍后台管理系统的设计流程</li>
</ul>
<h2 id="MySQL数据库开放性问题"><a href="#MySQL数据库开放性问题" class="headerlink" title="MySQL数据库开放性问题"></a>MySQL数据库开放性问题</h2><ol>
<li>谈谈你对于MySQL设计的理解</li>
</ol>
<blockquote>
<p>自己主要根据项目经历和实习经历中使用MySQL的经验，从数据库表建立和索引建立这两方面来回答。</p>
<p>在网上找到了数据库的发展历史。</p>
<p><img src="http://images2015.cnblogs.com/blog/63651/201703/63651-20170308091123641-636480917.jpg" alt=""></p>
<p>MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。<br>MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。</p>
<p>数据库设计原则</p>
<ol>
<li>基本表及其字段之间的关系, 应尽量满足第三范式。但是，满足第三范式的数据库设计，往往不是最好的设计。为了提高数据库的运行效率，常常需要降低范式标准：适当增加冗余，达到以空间换时间的目的。</li>
<li>数据库范式 </li>
</ol>
<ul>
<li><p>第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解</p>
</li>
<li><p>第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性； </p>
</li>
<li><p>第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。 </p>
</li>
</ul>
<ol>
<li><p>冗余的目的是为了提高处理速度。只有低级冗余才会增加数据的不一致性，因为同一数据，可 能从不同时间、地点、角色上多次录入。因此，我们提倡高级冗余(派生性冗余)，反对低级冗余(重复性冗余)。 </p>
</li>
<li><p>视图是一种虚表，它依赖数据源的实表而存在。视图是供程序员使用数据库的一个窗口，是基表数据综合的一种形式, 是数据处理的一种方法，是用户数据保密的一种手段。为了进行复杂处理、提高运算速度和节省存储空间, 视图的定义深度一般不得超过三层。 若三层视图仍不够用, 则应在视图上定义临时表, 在临时表上再定义视图。这样反复交迭定义, 视图的深度就不受限制了。 </p>
</li>
<li><p>中间表是存放统计数据的表，它是为数据仓库、输出报表或查询结果而设计的，有时它没有主键与外键(数据仓库除外)。临时表是程序员个人设计的，存放临时记录，为个人所用。基表和中间表由DBA维护，临时表由程序员自己用程序自动维护。 </p>
</li>
</ol>
<p>数据库设计的实用原则是：在数据冗余和处理速度之间找到合适的平衡点。</p>
<p>提高数据库运行效率的办法。在给定的系统硬件和系统软件条件下，提高数据库系统的运行效率的办法是： </p>
<ol>
<li>在数据库物理设计时，降低范式，增加冗余, 少用触发器, 多用存储过程。 </li>
<li>当计算非常复杂、而且记录条数非常巨大时(例如一千万条)，复杂计算要先在数据库外面，以文件系统方式用C++语言计算处理完成之后，最后才入库追加到表中去。这是电信计费系统设计的经验。 </li>
<li>发现某个表的记录太多，例如超过一千万条，则要对该表进行水平分割。水平分割的做法是，以该表主键PK的某个值为界线，将该表的记录水平分割为两个表。若发现某个表的字段太多，例如超过八十个，则垂直分割该表，将原来的一个表分解为两个表。 </li>
<li>对数据库管理系统DBMS进行系统优化，即优化各种系统参数，如缓冲区个数。 </li>
<li>在使用面向数据的SQL语言进行程序设计时，尽量采取优化算法。</li>
</ol>
</blockquote>
<ul>
<li>参考文章：<a href="http://www.php.cn/mysql-tutorials-362535.html" target="_blank" rel="external">总结数据库设计的原则</a></li>
</ul>
<ol>
<li>MySQL如何面对高并发用户的访问</li>
</ol>
<blockquote>
<p>自己的回答主要是从主从分离以及Redis结果缓存这两方面回答。</p>
<ol>
<li>查询SQL优化</li>
</ol>
<p>使用SQL时，尽量把使用的索引放在选择的首列；</p>
<p>在查询时，不要过多地使用通配符;</p>
<p>在可能的情况下尽量限制尽量结果集行数;</p>
<p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描;</p>
<p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描;</p>
<p>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描;</p>
<p>in 和 not in 也要慎用，因为IN会使系统无法使用索引,而只能直接搜索表中的数据;</p>
<p>尽量避免在索引过的字符数据中，使用非打头字母搜索。这也使得引擎无法利用索引;</p>
<p>必要时强制查询优化器使用某个索引;</p>
<p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描;</p>
<p>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描;</p>
<p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致;</p>
<p>使用视图加速查询</p>
<p>能用UNION ALL就不要用UNION, UNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源</p>
</blockquote>
<ul>
<li>参考文章：<a href="http://blog.csdn.net/feihuadao/article/details/20916489" target="_blank" rel="external">MySQL大数据高并发处理之-查询的优化</a></li>
</ul>
<blockquote>
<ol>
<li>分库分表</li>
</ol>
<p>分表：例如user表按照user_id%256的策略进行分表。分表能够解决单表数据量过大带来的查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库Master服务器无法承载写操作压力 时，不管如何扩展Slave服务器，此时都没有意义了。</p>
<p>分库: 对数据库进行拆分，从而提高数据库写入能力，这就是所谓的分库。假设user_id字段的值为257,将原有的单库分为256个库，那么应用程序对数据库的访问请求将被路由到第1个库（257%256=1)。</p>
<p><img src="http://www.itmmd.com/html/kindeditor/pic/20141123/2014112313161872719980.jpg" alt=""></p>
<p>有时数据库可能既面临着高并发访问的压力，又需要面对海量数据的存储问题，这时需要对数据库即采用分库策略，又采用分表策略，以便同时扩展系统的并发处理能力，以及提升单 表的查询性能，这就是所谓的分库分表。</p>
<ul>
<li>中间变量=user_id% (库数量X每个库的表数量）</li>
<li>库=取整（中间变量/每个库的表数量）</li>
<li>表=中间变量％每个库的表数量。</li>
</ul>
<p>假设将原来的单库单表order拆分成256个库，每个库包含1024个表，那么按照前面所提到的路由策略，对于user_id=262145的访问，路由的计算过程如下：中间变量=262145% (256X1024) =1;库=取整（1/1024) =0;表=1%1024=1。<br>这意味着，对于user_id=262145的订单记录的查询和修改，将被路由到第0个库的第1个表中执行。</p>
</blockquote>
<ul>
<li>参考文章：<a href="http://www.itmmd.com/201411/208.html" target="_blank" rel="external">大型网站架构设计-mysql分表与分库</a></li>
</ul>
<blockquote>
<p>使用队列：使用队列写入等方法来降低并发读写:Redis队列</p>
<ol>
<li>缓存设计</li>
</ol>
<p>采用redis数据库，前置到mysql。</p>
<p>例如秒杀场景：必须使用缓存，将需要秒杀的商品放入缓存中，并使用锁来处理其并发情况。当接到用户秒杀提交订单的情况下，先将商品数量递减（加锁/解锁）后再进行其他方面的处理，处理失败在将数据递增1（加锁/解锁），否则表示交易成功。当商品数量递减到0时，表示商品秒杀完毕，拒绝其他用户的请求。</p>
<p>多用户并发修改同一条记录。</p>
<p>乐观锁，就是在数据库设计一个版本号的字段，每次修改都使其+1，这样在提交时比对提交前的版本号就知道是不是并发提交了，但是有个缺点就是只能是应用中控制，如果有跨应用修改同一条数据乐观锁就没办法了，这个时候可以考虑悲观锁。</p>
<p>悲观锁，就是直接在数据库层面将数据锁死，类似于oralce中使用select xxxxx from xxxx where xx=xx for update，这样其他线程将无法提交数据。</p>
<p>除了加锁的方式也可以使用接收锁定的方式，思路是在数据库中设计一个状态标识位，用户在对数据进行修改前，将状态标识位标识为正在编辑的状态，这样其他用户要编辑此条记录时系统将发现有其他用户正在编辑，则拒绝其编辑的请求，类似于你在操作系统中某文件正在执行，然后你要修改该文件时，系统会提醒你该文件不可编辑或删除。</p>
</blockquote>
<ul>
<li>参考文章：<a href="https://segmentfault.com/a/1190000007703843" target="_blank" rel="external">mysql处理高并发，防止库存超卖</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;猎豹移动一面&quot;&gt;&lt;a href=&quot;#猎豹移动一面&quot; class=&quot;headerlink&quot; title=&quot;猎豹移动一面&quot;&gt;&lt;/a&gt;猎豹移动一面&lt;/h1&gt;&lt;h2 id=
    
    </summary>
    
      <category term="面试记录" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
      <category term="Cheetah Mobile" scheme="http://lincentma.men/tags/Cheetah-Mobile/"/>
    
  </entry>
  
  <entry>
    <title>OJ基本技巧记录</title>
    <link href="http://lincentma.men/OJ_skill.html"/>
    <id>http://lincentma.men/OJ_skill.html</id>
    <published>2017-09-12T07:58:15.000Z</published>
    <updated>2017-09-12T08:00:19.958Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="OJ基本技巧记录"><a href="#OJ基本技巧记录" class="headerlink" title="OJ基本技巧记录"></a>OJ基本技巧记录</h1><h1 id="OJ平台代码基本格式"><a href="#OJ平台代码基本格式" class="headerlink" title="OJ平台代码基本格式"></a>OJ平台代码基本格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import java.util.Scanner;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by ml on 2017/9/11.</div><div class="line"> */</div><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Scanner in = new Scanner(System.in);</div><div class="line">        while (in.hasNext()) &#123;</div><div class="line">            String n = in.nextLine();//读一个字符串</div><div class="line">            int m = in.nextInt();//读一个整数</div><div class="line">            long l = in.nextLong();//读一个长整数</div><div class="line">            double t = in.nextDouble();//读一个浮点数</div><div class="line">            System.out.println(cal(n));//具体处理逻辑</div><div class="line">        &#125;</div><div class="line">        in.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="OJ输入输出技巧"><a href="#OJ输入输出技巧" class="headerlink" title="OJ输入输出技巧"></a>OJ输入输出技巧</h1><ol>
<li><p>输入数据有多行，第一行是一个整数n，表示测试实例的个数，后面跟着n行，每行包括一个由字母和数字组成的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Scanner in = new Scanner(System.in);</div><div class="line">int n = in.nextInt();</div><div class="line">//可以创建数组</div><div class="line">int[] n = new int[n];</div><div class="line">String[] str = new String[n];</div><div class="line">for(int i=0;i&lt;n;i++) &#123;</div><div class="line">    n[i] = in.nextInt();</div><div class="line">    String str = in.nextLine();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>读入字符串的分割</p>
</li>
</ol>
<p>例如：Input输入数据有多组，每组占一行，数据格式为YYYY/MM/DD组成 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Scanner in = new Scanner(System.in);</div><div class="line">while (in.hasNext()) &#123;</div><div class="line">    String str =in.nextLine();</div><div class="line">    String[] date = str.split(&quot;/&quot;);</div><div class="line">    int y = Integer.parseInt(date[0]);</div><div class="line">    int m = Integer.parseInt(date[1]);</div><div class="line">    int d = Integer.parseInt(date[2]);</div><div class="line">&#125;</div><div class="line">in.close();</div></pre></td></tr></table></figure>
<ol>
<li>不同类型相互转换</li>
</ol>
<ul>
<li><p>int转为String：</p>
<ul>
<li>String s = Integer.toString(i);</li>
<li>String s = String.valueOf(i);</li>
<li>String s = “” + i;</li>
<li>三种效率排序：Integer.toString(int i)   &gt;   String.valueOf(int i)   &gt;  i+””;    </li>
</ul>
</li>
<li><p>String转为int</p>
<ul>
<li>int i = Integer.parseInt(s);</li>
<li>int i = Integer.valueOf(s).intValue()</li>
<li>这两种都会抛出异常（NumberFormatException）</li>
</ul>
</li>
</ul>
<ol>
<li>Java输出</li>
</ol>
<ul>
<li><p>System.out.print(); //输出不换行</p>
</li>
<li><p>System.out.println(); //输出换行 </p>
</li>
<li><p>System.out.format(); </p>
<ul>
<li>double d = 345.678;</li>
<li>System.out.printf(“%9.2f”, d);// “9.2”中的9表示输出的长度，2表示小数点后的位数。</li>
<li>System.out.printf(“%+-9.3f”, d);// “+-“表示输出的数带正负号且左对齐。</li>
</ul>
</li>
<li><p>System.out.printf(); //与上相同</p>
</li>
<li><p>DecimalFormat。DecimalFormat 类主要靠 # 和 0 两种占位符号来指定数字长度。0 表示如果位数不足则以 0 填充，# 表示只要有可能就把数字拉上这个位置。</p>
<ul>
<li>NumberFormat formatter = new DecimalFormat( “0.00”);   </li>
<li>String s = formatter.format(-.567);              //   -0.57   </li>
<li>System.out.println(s);  </li>
</ul>
</li>
</ul>
<ol>
<li>矩阵如何按行输出</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//输出int[n][m]，判断是否是每一行的最后一个，输出换行。</div><div class="line">for(int i = 0; i &lt; n ; i++) &#123;</div><div class="line">    for(int j = 0; j &lt; m; j++&gt;) &#123;</div><div class="line">        if(j == m - 1)&#123;</div><div class="line">            system.out.println(i);</div><div class="line">        &#125; else &#123;</div><div class="line">            system.out.print(i + &quot; &quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>不定长度类型</li>
</ol>
<ul>
<li>对于整形等数据在处理中不能确定长度的情况，使用ArrayList<integer>等形式来存储数据。</integer></li>
<li>对于char或者String类型可以使用StingBuffer等形式来存储。</li>
</ul>
<ol>
<li>集合遍历</li>
</ol>
<ul>
<li><p>数组以及List：遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</div><div class="line">    System.out.println(list.get(i));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Map类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</div><div class="line"></div><div class="line">//1</div><div class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</div><div class="line">while (it.hasNext()) &#123;</div><div class="line">    Map.Entry&lt;String, String&gt; entry = it.next();</div><div class="line">    System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue());</div><div class="line">&#125;</div><div class="line">//2</div><div class="line">for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</div><div class="line">    entry.getKey();</div><div class="line">&#125;</div><div class="line">//3</div><div class="line">for (String key : map.keySet()) &#123;</div><div class="line">    String value = (String) map.get(key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>传统的for循环遍历，基于计数器。遍历整个集合的平均时间复杂度为O(n^2)。</p>
</li>
<li>迭代器遍历，Iterator。</li>
<li>foreach循环遍历。实现原理同Iterator。</li>
</ul>
<ol>
<li>排序</li>
</ol>
<ul>
<li><p>如果要对数组排序，请使用java.util.Arrays.sort()方法。</p>
</li>
<li><p>如果对list排序，请使用java.util.Collections.sort()方法。</p>
</li>
<li><p>自定义排序：对于要排序的类实现Comparable接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class S1 implements Comparable&#123;  </div><div class="line">    int x;  </div><div class="line">    int y;  </div><div class="line">    S1(int x, int y)&#123;  </div><div class="line">        this.x = x;  </div><div class="line">        this.y = y;  </div><div class="line">    &#125;  </div><div class="line">    //实现排序方法。先比较x，如果相同比较y  </div><div class="line">    @Override  </div><div class="line">    public int compareTo(Object o) &#123;  </div><div class="line">        S1 obj = (S1) o;  </div><div class="line">        if(x != obj.x)  </div><div class="line">        &#123;  </div><div class="line">            return x - obj.x;  </div><div class="line">        &#125;  </div><div class="line">        return y - obj.y;  </div><div class="line">    &#125;  </div><div class="line">    //重写toStirng方法，改变println时的显示效果  </div><div class="line">    public String toString()&#123;  </div><div class="line">        return &quot;(&quot;+x+&quot;, &quot;+y+&quot;)&quot;;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="OJ常用函数"><a href="#OJ常用函数" class="headerlink" title="OJ常用函数"></a>OJ常用函数</h1><ol>
<li><p>不同类型长度：</p>
<ul>
<li><p>数组：int len = n.length;//int[] n = new int[10];</p>
</li>
<li><p>字符串：int len = s.length();//String s = “hello”;</p>
</li>
<li><p>List：int len = list.size();//List<string> list = new ArrayList<string>();</string></string></p>
</li>
</ul>
</li>
<li><p>String类：</p>
<ul>
<li><p>字符串某一位置字符,charAt。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String str = new String(&quot;asdfzxc&quot;);</div><div class="line">char ch = str.charAt(4);//ch = z</div></pre></td></tr></table></figure>
</li>
<li><p>转化为char数组。toCharArray方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String str1 = new String(&quot;abc&quot;);</div><div class="line">char[] c = str1.toCharArray();</div></pre></td></tr></table></figure>
</li>
<li><p>判断相等。equals方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str1 = new String(&quot;abc&quot;);</div><div class="line">String str2 = new String(&quot;ABC&quot;);</div><div class="line">boolean c = str1.equals(str2);//c=false</div></pre></td></tr></table></figure>
</li>
<li><p>提取子串。substring方法：一个参数：该方法从beginIndex位置起，出剩余的字符作为一个新的字符串返回。两个参数：左闭右开原则[beginIndex,endIndex)，即[beginIndex,endIndex - 1]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str1 = new String(&quot;asdfzxc&quot;);</div><div class="line">String str2 = str1.substring(2);//str2 = &quot;dfzxc&quot;</div><div class="line">String str3 = str1.substring(2,5);//str3 = &quot;dfz&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>字符串比较。compareTo方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String str1 = new String(&quot;abc&quot;);</div><div class="line">String str2 = new String(&quot;ABC&quot;);</div><div class="line">int a = str1.compareTo(str2);//a&gt;0</div><div class="line">int b = str1.compareTo(str2);//b=0</div></pre></td></tr></table></figure>
</li>
<li><p>是否包含字符。contains方法判断参数s是否被包含在字符串中，并返回一个布尔类型的值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str = &quot;student&quot;;</div><div class="line">str.contains(&quot;stu&quot;);//true</div><div class="line">str.contains(&quot;ok&quot;);//false</div></pre></td></tr></table></figure>
</li>
<li><p>字符串字符替换。replace、replaceFirst、replaceAll方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String str = &quot;asdzxcasd&quot;;</div><div class="line">String str1 = str.replace(&apos;a&apos;,&apos;g&apos;);//str1 = &quot;gsdzxcgsd&quot;</div><div class="line">String str2 = str.replace(&quot;asd&quot;,&quot;fgh&quot;);//str2 = &quot;fghzxcfgh&quot;</div><div class="line">String str3 = str.replaceFirst(&quot;asd&quot;,&quot;fgh&quot;);//str3 = &quot;fghzxcasd&quot;</div><div class="line">String str4 = str.replaceAll(&quot;asd&quot;,&quot;fgh&quot;);//str4 = &quot;fghzxcfgh&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>字符查找。indexOf、lastIndexOf方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String str = &quot;I am a good student&quot;;</div><div class="line">int a = str.indexOf(&apos;a&apos;);//a = 2</div><div class="line">int b = str.indexOf(&quot;good&quot;);//b = 7</div><div class="line">int c = str.indexOf(&quot;w&quot;,2);//c = -1</div><div class="line">int d = str.lastIndexOf(&quot;a&quot;);//d = 5</div><div class="line">int e = str.lastIndexOf(&quot;a&quot;,3);//e = 2</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>StringBuffer类</p>
<ul>
<li><p>添加。append方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer sb = new StringBuffer(“abc”);</div><div class="line">sb.append(true);//&quot;abctrue&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>插入。insert方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer sb = new StringBuffer(“TestString”);</div><div class="line">sb.insert(4,false);//&quot;TestfalseString&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>删除。deleteCharAt方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer sb = new StringBuffer(“Test”);</div><div class="line">sb. deleteCharAt(1);//&quot;Tst&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>转换为字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer sb = new StringBuffer(“Test”);</div><div class="line">String s1 = sb.toString(); //StringBuffer转换为String</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>ArrayList类</p>
<ul>
<li>添加：add方法</li>
<li>插入：insert方法</li>
<li>删除：remove方法</li>
<li>清空：clear方法</li>
<li>包含：contains方法</li>
</ul>
</li>
</ol>
<h1 id="OJ常用算法"><a href="#OJ常用算法" class="headerlink" title="OJ常用算法"></a>OJ常用算法</h1><ul>
<li>自己的初步阶段：理清思路，暴力求解，再逐步改进！</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;OJ基本技巧记录&quot;&gt;&lt;a href=&quot;#OJ基本技巧记录&quot; class=&quot;headerlink&quot; title=&quot;OJ基本技巧记录&quot;&gt;&lt;/a&gt;OJ基本技巧记录&lt;/h1
    
    </summary>
    
      <category term="面试" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="OJ" scheme="http://lincentma.men/tags/OJ/"/>
    
      <category term="skill" scheme="http://lincentma.men/tags/skill/"/>
    
  </entry>
  
  <entry>
    <title>美团二面记录</title>
    <link href="http://lincentma.men/meituan_interview_2.html"/>
    <id>http://lincentma.men/meituan_interview_2.html</id>
    <published>2017-09-07T09:13:37.000Z</published>
    <updated>2017-09-07T09:15:37.195Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="美团二面记录"><a href="#美团二面记录" class="headerlink" title="美团二面记录"></a>美团二面记录</h1><blockquote>
<p>第一次遇见女面试官进行面试。自己学到更多的东西。</p>
</blockquote>
<h2 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h2><blockquote>
<p>面试官听了我的项目，差异公司没有这样的解决方案，需要自己再去造轮子吗？这也是自己的当时最晚的感受，也就是自己理解的常说的CRUD接口操作，但是这个项目给自己最大的感受是在于自己熟悉了整套开发上线流程，明白各个部门之间的分工协作过程。</p>
<p>自己的目标就是希望可以自己在后端写出属于自己的通用轮子。</p>
<p>如何考虑故障？单台提供数据查询有没有更好的方案？</p>
</blockquote>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li>Redis的基本数据结构</li>
</ol>
<blockquote>
<ol>
<li>String类型：将String类型作为元素值；</li>
<li>Lists类型：根据插入顺序的String类型为元素的集合，基于LinkedList实现，非Array型；</li>
<li>Sets类型：无重复且无序的String类型为元素的集合；</li>
<li>Sorted Set类型：无重复且有序的String类型为元素的集合；</li>
<li>Hashes类型：映射域到值类型的数据结构，其中域和值都是String类型；</li>
</ol>
</blockquote>
<ol>
<li>Redis使用场景？</li>
</ol>
<blockquote>
<ol>
<li>会话缓存（Session Cache）:用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。用户的购物车信息。</li>
<li>全页缓存（FPC）:Redis有磁盘的持久化，用户也不会看到页面加载速度的下降。</li>
<li>队列：Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。</li>
<li>排行榜/计数器。Redis在内存中对数字进行递增或递减的操作实现的非常好。“ZRANGE user_scores 0 10 WITHSCORES”</li>
<li>发布/订阅。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统。</li>
</ol>
<p>参考文章：<a href="http://blog.jobbole.com/88383/" target="_blank" rel="external">Redis 的 5 个常见使用场景</a></p>
</blockquote>
<ol>
<li>如何设计多级缓存结构？考虑哪些方面？</li>
</ol>
<blockquote>
<p>多级缓存，即在整个系统架构的不同系统层级进行数据缓存，以提升访问效率，这也是应用最广的方案之一。</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0115/8558/b09fd58d-5d45-3742-8548-5726b0b79076.png" alt=""></p>
<p>整体流程如上图所示：</p>
<ol>
<li><p>首先接入Nginx将请求负载均衡到应用Nginx，此处常用的负载均衡算法是轮询或者一致性哈希，轮询可以使服务器的请求更加均衡，而一致性哈希可以提升应用Nginx的缓存命中率；后续负载均衡和缓存算法部分我们再细聊；</p>
</li>
<li><p>接着应用Nginx读取本地缓存（本地缓存可以使用Lua Shared Dict、Nginx Proxy Cache（磁盘/内存）、Local Redis实现），如果本地缓存命中则直接返回，使用应用Nginx本地缓存可以提升整体的吞吐量，降低后端的压力，尤其应对热点问题非常有效；为什么要使用应用Nginx本地缓存我们将在热点数据与缓存失效部分细聊；</p>
</li>
<li><p>如果Nginx本地缓存没命中，则会读取相应的分布式缓存（如Redis缓存，另外可以考虑使用主从架构来提升性能和吞吐量），如果分布式缓存命中则直接返回相应数据（并回写到Nginx本地缓存）；</p>
</li>
<li><p>如果分布式缓存也没有命中，则会回源到Tomcat集群，在回源到Tomcat集群时也可以使用轮询和一致性哈希作为负载均衡算法；</p>
</li>
<li><p>在Tomcat应用中，首先读取本地堆缓存，如果有则直接返回（并会写到主Redis集群），为什么要加一层本地堆缓存将在缓存崩溃与快速修复部分细聊；</p>
</li>
<li><p>作为可选部分，如果步骤4没有命中可以再尝试一次读主Redis集群操作，目的是防止当从有问题时的流量冲击；</p>
</li>
<li><p>如果所有缓存都没有命中只能查询DB或相关服务获取相关数据并返回；</p>
</li>
<li><p>步骤7返回的数据异步写到主Redis集群，此处可能多个Tomcat实例同时写主Redis集群，可能造成数据错乱，如何解决该问题将在更新缓存与原子性部分细聊。</p>
</li>
</ol>
<p>整体分了三部分缓存：应用Nginx本地缓存、分布式缓存、Tomcat堆缓存，每一层缓存都用来解决相关的问题，如应用Nginx本地缓存用来解决热点缓存问题，分布式缓存用来减少访问回源率、Tomcat堆缓存用于防止相关缓存失效/崩溃之后的冲击。</p>
<p>使用消息机制同步缓存</p>
<ol>
<li>把写缓存改成写消息，通过消息通知数据变更；</li>
<li>同步缓存系统会订阅消息，并根据消息进行更新缓存；</li>
<li>数据一致性可以采用：消息体只包括ID、然后查库获取最新版本数据；通过时间戳和内容摘要机制(MD5)进行缓存更新；</li>
<li>如上方法也不能保证消息不丢失，可以采用：应用在本地记录更新日志，当消息丢失了回放更新日志；或者采用数据库binlog，采用如canal订阅binlog进行缓存更新。</li>
</ol>
<p>对于长尾访问的数据、大多数数据访问频率都很高的场景、缓存空间足够都可以考虑不过期缓存，比如用户、分类、商品、价格、订单等，当缓存满了可以考虑LRU机制驱逐老的缓存数据。</p>
<p>维度化缓存与增量缓存</p>
<p>将数据进行维度化并增量更新（只更新变的部分）。尤其如上下架这种只是一个状态变更，但是每天频繁调用的，维度化后能减少服务很大的压力。</p>
<p>轮询的优点：到应用Nginx的请求更加均匀，使得每个服务器的负载基本均衡；轮询的缺点：随着应用Nginx服务器的增加，缓存的命中率会下降，比如原来10台服务器命中率为90%，再加10台服务器将可能降低到45%；而这种方式不会因为热点问题导致其中某一台服务器负载过重。</p>
<p>一致性哈希的优点：相同请求都会转发到同一台服务器，命中率不会因为增加服务器而降低；一致性哈希的缺点：因为相同的请求会转发到同一台服务器，因此可能造成某台服务器负载过重，甚至因为请求太多导致服务出现问题。</p>
<p>正常情况采用一致性哈希，如果某个请求类型访问量突破了一定的阀值，则自动降级为轮询机制。另外对于一些秒杀活动之类的热点我们是可以提前知道的，可以把相关数据预先推送到应用Nginx并将负载均衡机制降级为轮询。</p>
<p>参考文章：<a href="http://www.importnew.com/18983.html" target="_blank" rel="external">应用多级缓存模式支撑海量读服务</a></p>
<p>这是一篇非常好的文章！</p>
</blockquote>
<ol>
<li>主键和唯一键的区别？</li>
</ol>
<blockquote>
<p>索引是存储在数据库中的一个物理结构，键纯粹是一个逻辑概念。键代表创建来实施业务规则的完整性约束。索引和键的混淆通常是由于数据库使用索引来实施完整性约束。</p>
<p>（1）主键约束和唯一键约束均会隐式创建同名的唯一索引，当主键约束或者唯一键约束失效时，隐式创建的唯一索引会被删除；</p>
<p>（2）主键约束要求列值非空，而唯一键约束和唯一索引不要求列值非空；</p>
<p>（3）相同字段序列不允许重复创建索引。</p>
</blockquote>
<ol>
<li>生产者消费者实现需要考虑哪几方面？如何考虑存储？</li>
</ol>
<blockquote>
<p>生产者仅仅在仓储未满时候生产，仓满则停止生产。</p>
<p>消费者仅仅在仓储有产品时候才能消费，仓空则等待。</p>
<p>当消费者发现仓库没产品可消费时候会通知生产者生产。</p>
<p>生产者在生产出可消费产品时候，应该通知等待的消费者去消费。</p>
<p>对于存储中介，它肯定是一块具有额定大小的存储空间，而这个存储空间一般来说具有FIFO的数据结构，比如JDK内置了具有阻塞作用的有界队列：ArrayBlockingQueue、LinkedBlockingQueue。</p>
</blockquote>
<p><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/consumer1.jpg" alt=""></p>
<p><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/consumer3.jpg" alt=""></p>
<blockquote>
<p>参考文章：<a href="http://blog.csdn.net/gsg8709/article/details/77868039" target="_blank" rel="external">生产者/消费者模式</a></p>
</blockquote>
<ol>
<li>如何实现O(1)时间复杂度求栈的最小值？</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">package com;</div><div class="line"></div><div class="line">import java.util.Stack;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by ml on 2017/9/7.</div><div class="line"> * 原栈中，每次添加一个新元素时，就和辅助栈的栈顶元素相比较，如果新元素小，就把新元素的值放到辅助栈和原栈中，如果新元素大，就把元素放到原栈中；出栈时，如果原栈跟辅助栈元素相同，都弹出，否则只弹出原栈栈顶元素.</div><div class="line"> */</div><div class="line">public class Stackmin &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        AdvancedStack&lt;Integer&gt; stack = new AdvancedStack&lt;Integer&gt;();</div><div class="line">        stack.push(5);</div><div class="line">        System.out.println(stack.getMin());</div><div class="line">        stack.push(7);</div><div class="line">        System.out.println(stack.getMin());</div><div class="line">        stack.push(3);</div><div class="line">        System.out.println(stack.getMin());</div><div class="line">        stack.push(9);</div><div class="line">        System.out.println(stack.getMin());</div><div class="line">        stack.push(3);</div><div class="line">        System.out.println(stack.getMin());</div><div class="line">        stack.pop();</div><div class="line">        System.out.println(stack.getMin());</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    static class AdvancedStack&lt;T extends Comparable&gt; &#123;</div><div class="line">        Stack&lt;T&gt; stackNormal = new Stack&lt;T&gt;();</div><div class="line">        Stack&lt;T&gt; stackMin = new Stack&lt;T&gt;();</div><div class="line">        Stack&lt;T&gt; stackMax = new Stack&lt;T&gt;();</div><div class="line"></div><div class="line">        public void push(T e) &#123;</div><div class="line">            stackNormal.push(e);</div><div class="line"></div><div class="line">            //最小栈为空或者push的值小于最小栈的栈顶元素</div><div class="line">            if (stackMin.isEmpty() || e.compareTo(stackMin.peek()) &lt; 0) &#123;</div><div class="line">                stackMin.push(e);</div><div class="line">            &#125; else if (e.compareTo(stackMin.peek()) &gt; 0) &#123;</div><div class="line">                stackMin.push(stackMin.peek());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (stackMax.isEmpty() || e.compareTo(stackMin.peek()) &gt; 0) &#123;</div><div class="line">                stackMax.push(e);</div><div class="line">            &#125; else if (e.compareTo(stackMax.peek()) &lt; 0) &#123;</div><div class="line">                stackMax.push(stackMax.peek());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        public T pop() &#123;</div><div class="line">            if (!stackNormal.isEmpty() &amp;&amp; !stackMin.isEmpty() &amp;&amp; !stackMax.isEmpty()) &#123;</div><div class="line">                T e = stackNormal.pop();</div><div class="line">                stackMin.pop();</div><div class="line">                stackMax.pop();</div><div class="line">                return e;</div><div class="line">            &#125; else &#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public T getMin() &#123;</div><div class="line">            return stackMin.peek();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public T getMax() &#123;</div><div class="line">            return stackMax.peek();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>如何设计即时通信系统，采用TCP还是UDP？</li>
</ol>
<p><img src="https://pic1.zhimg.com/v2-983c2fd4784a5f7d1a7504fd6435871c_b.png" alt=""></p>
<blockquote>
<p>现在的移动端IM、推送系统，既面对移动互联网的不确定性，又面对智能终端频繁的系统休眠、网络切换，还要考虑服务端的承载成本，对于在线服务而言UDP是比TCP更适合的方式。但是由于数据完整性、安全性的需要，又不应完全放弃TCP的可靠与安全。</p>
<p>两种通信协议同时使用，各有侧重。UDP用于保持大量终端的在线与控制，应用与业务则通过TCP去实现。这个和FTP服务控制与数据分离，采取不同的连接，有异曲同工之处。</p>
<p>参考文章:<a href="http://www.52im.net/thread-33-1-1.html" target="_blank" rel="external">移动端IM/推送系统的协议选型：UDP还是TCP？</a></p>
</blockquote>
<ol>
<li>抽象类的作用？</li>
</ol>
<blockquote>
<ol>
<li>通过继承它实现多态。设计抽象类是为了继承它，实现代码的重用性，可以使得由它所派生的所有类具有相同的接口，使用更加灵活抽象，可以使多态的作用发挥的更好，还有一点就是程序的结构更易于更改和扩充。</li>
<li>接口就是更纯粹的抽象类。</li>
</ol>
</blockquote>
<ol>
<li>kafka有了解过吗？</li>
</ol>
<blockquote>
<p><a href="http://www.cnblogs.com/cyfonly/p/5954614.html" target="_blank" rel="external">kafka学习笔记：知识点整理</a></p>
</blockquote>
<h2 id="开放问题"><a href="#开放问题" class="headerlink" title="开放问题"></a>开放问题</h2><ol>
<li>对你最大作用的项目？</li>
</ol>
<blockquote>
<p>OK</p>
</blockquote>
<ol>
<li>学校期间最有挑战性的项目？</li>
</ol>
<blockquote>
<p>应该侧重于技术方面的挑战</p>
</blockquote>
<ol>
<li>除了项目和实习，你是如何学习新的技术？</li>
</ol>
<blockquote>
<p>OK</p>
</blockquote>
<ol>
<li>除了以上技术，你最喜欢的技术是什么？</li>
</ol>
<blockquote>
<p>前沿技术？？</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;美团二面记录&quot;&gt;&lt;a href=&quot;#美团二面记录&quot; class=&quot;headerlink&quot; title=&quot;美团二面记录&quot;&gt;&lt;/a&gt;美团二面记录&lt;/h1&gt;&lt;blockq
    
    </summary>
    
      <category term="面试记录" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
      <category term="meituan" scheme="http://lincentma.men/tags/meituan/"/>
    
  </entry>
  
  <entry>
    <title>美团点评一面</title>
    <link href="http://lincentma.men/meituan_interview.html"/>
    <id>http://lincentma.men/meituan_interview.html</id>
    <published>2017-09-01T14:19:46.000Z</published>
    <updated>2017-09-01T14:21:31.584Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="美团点评一面"><a href="#美团点评一面" class="headerlink" title="美团点评一面"></a>美团点评一面</h1><blockquote>
<p>强大的基础面试让我亚历山大<br>半个小时多的面试，很多问题自己没有扎实的理解没有深入，导致问的越多自己越慌张<br>基础是深度的基础，深度是基础的升华</p>
</blockquote>
<h2 id="1-介绍Sug项目"><a href="#1-介绍Sug项目" class="headerlink" title="1. 介绍Sug项目"></a>1. 介绍Sug项目</h2><h3 id="1-1-项目之间的关联？"><a href="#1-1-项目之间的关联？" class="headerlink" title="1.1 项目之间的关联？"></a>1.1 项目之间的关联？</h3><blockquote>
<p>项目背景需求讲述。</p>
</blockquote>
<h3 id="1-2-项目中最有挑战性？"><a href="#1-2-项目中最有挑战性？" class="headerlink" title="1.2 项目中最有挑战性？"></a>1.2 项目中最有挑战性？</h3><blockquote>
<p>项目难点说明。</p>
</blockquote>
<h3 id="1-3-数据量是多少？"><a href="#1-3-数据量是多少？" class="headerlink" title="1.3 数据量是多少？"></a>1.3 数据量是多少？</h3><blockquote>
<p>感觉考察对于项目细节的总结。</p>
</blockquote>
<h3 id="1-4-map-reduce配置多少？"><a href="#1-4-map-reduce配置多少？" class="headerlink" title="1.4 map reduce配置多少？"></a>1.4 map reduce配置多少？</h3><blockquote>
<p>Map的数量经常是由输入数据中的DFS块的数量来决定的。<br>正确的reduce任务的个数应该是0.95或者1.75 ×（节点数 ×mapred.tasktracker.tasks.maximum参数值）。</p>
</blockquote>
<h3 id="1-5-调整的container数量是多少？"><a href="#1-5-调整的container数量是多少？" class="headerlink" title="1.5 调整的container数量是多少？"></a>1.5 调整的container数量是多少？</h3><blockquote>
<p>步骤1：用户将应用程序提交到ResourceManager上；</p>
<p>步骤2：ResourceManager为应用程序ApplicationMaster申请资源，并与某个NodeManager通信，以启动ApplicationMaster；</p>
<p>步骤3：ApplicationMaster与ResourceManager通信，为内部要执行的任务申请资源，一旦得到资源后，将于NodeManager通信，以启动对应的任务。</p>
<p>步骤4：所有任务运行完成后，ApplicationMaster向ResourceManager注销，整个应用程序运行结束。<br>上述步骤中，步骤2~3涉及到资源申请与使用，而这正是Container出现的地方。</p>
<p><img src="http://www.aboutyun.com/data/attachment/forum/201609/27/175653yl1ojjxvfx4axaxv.png" alt=""></p>
<p>（1）  Container是YARN中资源的抽象，它封装了某个节点上一定量的资源（CPU和内存两类资源）。它跟Linux Container没有任何关系，仅仅是YARN提出的一个概念（从实现上看，可看做一个可序列化/反序列化的Java类）。<br>（2）  Container由ApplicationMaster向ResourceManager申请的，由ResouceManager中的资源调度器异步分配给ApplicationMaster；<br>（3） Container的运行是由ApplicationMaster向资源所在的NodeManager发起的，Container运行时需提供内部执行的任务命令（可以使任何命令，比如java、Python、C++进程启动命令均可）以及该命令执行所需的环境变量和外部资源（比如词典文件、可执行文件、jar包等）。</p>
<p>Container数量=min (2<em>CORES, 1.8</em>DISKS, (可用内存)/最低Container的大小)</p>
<p>每个Container的内存大小 = max(最小Container内存大小, (总可用内存) /Container数))</p>
<p>例如：<br>集群的节点有 12 CPU cores, 48 GB RAM, and 12 磁盘.<br>预留内存= 6 GB 系统预留 + 8 GB HBase预留<br>最小Container内存大小 = 2 GB</p>
<p>Container数 = min (2<em>12, 1.8</em> 12, (48-6)/2) = min (24, 21.6, 21) = 21</p>
<p>每个Container的内存大小 = max (2, (48-6)/21) = max (2, 2) = 2</p>
</blockquote>
<h3 id="1-6-定时crontab挂掉有其他方式保证吗？"><a href="#1-6-定时crontab挂掉有其他方式保证吗？" class="headerlink" title="1.6 定时crontab挂掉有其他方式保证吗？"></a>1.6 定时crontab挂掉有其他方式保证吗？</h3><blockquote>
<p>百度了下，有crontab误删的解决方案：获取完整日志和cmd日志，获取所有crontab指令，从crontab.txt 中找出每一条指令，然后在cmd_temp 中匹配运行次数，重新编辑crontab添加恢复。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># 每天对crontab 进行备份 ，同时删除最近15天的数据</div><div class="line">DATE=$(date +%Y%m%d)</div><div class="line"></div><div class="line">crontab -l &gt; /home/work/bak/crontab_$DATE.bak</div><div class="line">find /home/work/bak/ -mtime +15 -name &apos;*.bak&apos; -exec rm -rf &#123;&#125; \;</div></pre></td></tr></table></figure>
<blockquote>
<p>自己第二个理解是，crontab在单台布置任务，如果该台机器发生故障的解决方案？</p>
<p>多台备份，一主多从，故障切换。多台机器上的定时任务——cronsun。<br>cronsun 支持：多机单任务(防止单机挂掉任务不按时执行)。</p>
</blockquote>
<h3 id="1-7-Hadoop-Streaming相对于传统的优点？"><a href="#1-7-Hadoop-Streaming相对于传统的优点？" class="headerlink" title="1.7 Hadoop Streaming相对于传统的优点？"></a>1.7 Hadoop Streaming相对于传统的优点？</h3><blockquote>
<p>Hadoop Streaming是Hadoop提供的一个编程工具，它允许用户使用任何可执行文件或者脚本文件作为Mapper和Reducer。</p>
<p>mapper和reducer会从标准输入中读取用户数据，一行一行处理后发送给标准输出。Streaming工具会创建MapReduce作业，发送给各个tasktracker，同时监控整个作业的执行过程。<br>如果一个文件（可执行或者脚本）作为mapper，mapper初始化时，每一个mapper任务会把该文件作为一个单独进程启动，mapper任务运行时，它把输入切分成行并把每一行提供给可执行文件进程的标准输入。 同时，mapper收集可执行文件进程标准输出的内容，并把收到的每一行内容转化成key/value对，作为mapper的输出。 默认情况下，一行中第一个tab之前的部分作为key，之后的（不包括tab）作为value。如果没有tab，整行作为key值，value值为null。<br>对于reducer，类似。以上是Map/Reduce框架和streaming mapper/reducer之间的基本通信协议。</p>
<p>优点：只要是支持stdin stdout的语言都可以用来实现MapReduce算法，这对于非Java程序员来编写MapReduce程序非常友好。</p>
<p>缺点：慢；无法避免的数据类型转换；archive，file分发对于I/O的压力。</p>
</blockquote>
<h3 id="1-8-关于Hadoop本身的架构你有哪些了解？Yarn？（这个地方反复听还是没有听清）"><a href="#1-8-关于Hadoop本身的架构你有哪些了解？Yarn？（这个地方反复听还是没有听清）" class="headerlink" title="1.8 关于Hadoop本身的架构你有哪些了解？Yarn？（这个地方反复听还是没有听清）?"></a>1.8 关于Hadoop本身的架构你有哪些了解？Yarn？（这个地方反复听还是没有听清）?</h3><blockquote>
<p>自己了解的不多，需要积累。</p>
<p>推荐<a href="http://dongxicheng.org/" target="_blank" rel="external">董的博客</a>。</p>
</blockquote>
<h3 id="1-9-MapReduce执行过程？"><a href="#1-9-MapReduce执行过程？" class="headerlink" title="1.9 MapReduce执行过程？"></a>1.9 MapReduce执行过程？</h3><blockquote>
<p><img src="http://img.blog.csdn.net/20170507203540147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpamlhbnBlbmcyMDEzXzIwMTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><img src="http://img.blog.csdn.net/20170507205932758?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpamlhbnBlbmcyMDEzXzIwMTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>1.预先加载本地的输入文件<br>2.经过MAP处理产生中间结果<br>3.经过shuffle将key相同的中间结果分配到同一个节点去处理<br>4.Reduce处理产生结果输出<br>5.将结果保存在hdfs上 </p>
</blockquote>
<h3 id="1-10-你了解多少MapRedce？"><a href="#1-10-你了解多少MapRedce？" class="headerlink" title="1.10 你了解多少MapRedce？"></a>1.10 你了解多少MapRedce？</h3><blockquote>
<p>自己了解的不多，需要积累。</p>
<p>推荐<a href="http://dongxicheng.org/" target="_blank" rel="external">董的博客</a>。</p>
</blockquote>
<h2 id="2-智能快递箱项目——Java的SSH框架"><a href="#2-智能快递箱项目——Java的SSH框架" class="headerlink" title="2. 智能快递箱项目——Java的SSH框架"></a>2. 智能快递箱项目——Java的SSH框架</h2><blockquote>
<p>本科项目，细节遗忘比较多，但是写在简历上，就必须完全掌握。<br>面试官很好，他采用一站到底的形式，让我明白技术深度的重要性。</p>
</blockquote>
<h3 id="2-1-SSH框架对于传统的JSP、Servlet这些的优势？"><a href="#2-1-SSH框架对于传统的JSP、Servlet这些的优势？" class="headerlink" title="2.1 SSH框架对于传统的JSP、Servlet这些的优势？"></a>2.1 SSH框架对于传统的JSP、Servlet这些的优势？</h3><blockquote>
<p>传统J2EE开发模式：Jsp+Servlet+Javabean</p>
<p>其实传统J2EE的缺点就是SSH框架中的优点，框架是为了解决一个又一个在Web开发中所遇到的问题而诞生的。不同的框架，都是为了解决不同的问题。</p>
<p>从最开始的JSP，在Html中嵌入Java逻辑，但是功能复杂后，Html混乱的结构，数据库事务以及日志，功能逻辑固化，遇到需求更改，往往需要重写一个JSP文件。</p>
<p>所以有了使用servlet来处理那些业务逻辑，把JSP中的Java业务逻辑剥离抽象出来。这样的好处在于流程更加清晰，虽然只是代码从JSP移动到了Servlet。。然而，为了这么点干净，付出的是为每个servlet都在web.xml里面去做一个url的请求配置。</p>
<p> 最终，我们需要的是：1. 数据 2. 页面展示 3. 处理具体业务的场所，任何形式实现的功能内部的核心元素都是这三种。</p>
<p>那么这就是MVC的概念：数据 ———— Model 页面展示 ———— View 处理具体业务的场所 ———— Control</p>
<p><img src="http://pic002.cnblogs.com/images/2011/286093/2011082208262390.jpg" alt=""></p>
<p>框架的典型的三层构架体现MVC（模型Model,视图View和控制）思想、良好的可扩展性、良好的可维护性和优秀的解耦性。</p>
<p>框架将实现功能的流程清晰化、分离化、独立化之后，各个模块之间的通信、异常等问题就是新的问题，就是SSH框架需要解决的问题。</p>
<p>Struts的优点：</p>
<ol>
<li>Struts2 Action对象为每一个请求产生一个实例，因此没有线程安全问题。</li>
<li>Struts2强大的标签库提高开发效率。</li>
<li>页面脉络清晰，通过查看配置文件把握整个系统的关系，方便开发人员岗位流动时的维护。</li>
</ol>
<p>Spring的优点：</p>
<ol>
<li>spring提高了一种对象管理方法，有效的组织系统中间层对象。是框架的完美“粘合剂”。</li>
<li>IOC和AOP</li>
</ol>
<p>Hibernate的优点：</p>
<ol>
<li>hibernate是JDBC轻量级的封装，占用内存较少，性能比较高。</li>
<li>优秀的ORM框架。</li>
<li>Hibernate兼容JDBC。</li>
</ol>
<p>参考文章：<a href="http://www.cnblogs.com/itao/archive/2011/08/22/2148844.html" target="_blank" rel="external">深入浅出的理解框架（Struts2、Hibernate、Spring）与 MVC 设计模式</a></p>
</blockquote>
<h3 id="2-2-你的意思是Strtus框架是在JSP上做了一层封装？"><a href="#2-2-你的意思是Strtus框架是在JSP上做了一层封装？" class="headerlink" title="2.2 你的意思是Strtus框架是在JSP上做了一层封装？"></a>2.2 你的意思是Strtus框架是在JSP上做了一层封装？</h3><blockquote>
<p>Struts是对Servlet控制页面跳转、类型转换等做了进一步封装，解决了Servlet开发带来的诸多问题，有利于维护。</p>
</blockquote>
<h3 id="2-3-JSP中有一些内置的对象？"><a href="#2-3-JSP中有一些内置的对象？" class="headerlink" title="2.3 JSP中有一些内置的对象？"></a>2.3 JSP中有一些内置的对象？</h3><blockquote>
<table>
<thead>
<tr>
<th>NO.</th>
<th style="text-align:center">内置对象</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">pageContext</td>
<td style="text-align:left">javax.servlet.jsp.PageContext</td>
<td style="text-align:left">使用它可以访问到本页面中所有其他对象，例如前面已经描述的request、response以及application对象等。</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">request</td>
<td style="text-align:left">javax.servlet.http.HttpServletRequest</td>
<td style="text-align:left">request内置对象中包含了有关浏览器请求的信息，并提供了多个用于获取cookie、header以及session内数据的方法。</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">response</td>
<td style="text-align:left">javax.servlet.http.HttpServletResponse</td>
<td style="text-align:left">response对象与request对象相对应，它是用于响应客户请求，向客户端输出信息。response对象提供了多个方法用来处理HTTP响应。</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">session</td>
<td style="text-align:left">javax.servlet.http.HttpSession</td>
<td style="text-align:left">session是与请求有关的会话期，用来表示和存储当前页面的请求信息。</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center">application</td>
<td style="text-align:left">javax.servlet.ServletContext</td>
<td style="text-align:left">用于实现用户之间的数据共享（多使用于网络聊天系统）。一般来说，一个用户对应着一个session，并且随着用户的离开session中的信息也会消失，所以不同客户之间的会话必须要确保某一时刻至少有一个客户没有终止会话；而applicat则不同，它会一直存在，类似于系统的“全局变量”，而且只有一个实例。</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:center">config</td>
<td style="text-align:left">javax.servlet.ServletConfig</td>
<td style="text-align:left">在Servlet初始化的时候，JSP引擎通过config向它传递信息。这种信息可以是属性名/值匹配的参数，也可以是通过ServletContext对象传递的服务器的有关信息。</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:center">out</td>
<td style="text-align:left">javax.servlet.jsp.JspWriter</td>
<td style="text-align:left">out对象用于向客户端发送文本数据。</td>
</tr>
<tr>
<td>8</td>
<td style="text-align:center">page</td>
<td style="text-align:left">java.lang.Object</td>
<td style="text-align:left">page对象有点类似于Java编程中的this指针，就是指当前JSP页面本身。</td>
</tr>
<tr>
<td>9</td>
<td style="text-align:center">exception</td>
<td style="text-align:left">java.lang.Throwable</td>
<td style="text-align:left">exception内置对象是用来处理页面出现的异常错误。</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="2-4-JSP是如何在web容器中跑起来的？经历那几个阶段？如何传输？"><a href="#2-4-JSP是如何在web容器中跑起来的？经历那几个阶段？如何传输？" class="headerlink" title="2.4 JSP是如何在web容器中跑起来的？经历那几个阶段？如何传输？"></a>2.4 JSP是如何在web容器中跑起来的？经历那几个阶段？如何传输？</h3><blockquote>
<ol>
<li>当客户端第一次请求一个jsp资源的时候，jsp引擎会查找这个jsp文件并且将它转换成为一个java文件，然后编译成为一个servlet类。</li>
<li>Web容器实例化这个servlet。</li>
<li>Web容器调用init()方法。在这个init方法中，调用针对jsp的JspInit()方法。 </li>
<li>Web容器调用service()方法。在service()方法中，调用_jspService()方法。</li>
</ol>
<p><img src="http://img.blog.csdn.net/20170323213037774?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmFja19fRnJvc3Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>JSP和Servlet的本质是一样的，因为JSP最终需要编译成Servlet才能运行，换句话说JSP是生成Servler的草稿文件。</p>
<p>参考文章:<a href="https://www.zhihu.com/question/27700526/answer/37792762" target="_blank" rel="external">jsp是如何被容器调用和执行的？</a></p>
</blockquote>
<h3 id="2-5-Servlet的生命周期？"><a href="#2-5-Servlet的生命周期？" class="headerlink" title="2.5 Servlet的生命周期？"></a>2.5 Servlet的生命周期？</h3><blockquote>
<p><img src="http://img.blog.csdn.net/20170323161259123?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmFja19fRnJvc3Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<ol>
<li>初始化阶段：调用init()方法</li>
<li>响应客户请求阶段：调用service()方法</li>
<li>终止阶段：调用destroy()方法</li>
</ol>
<p>JSP的优点是擅长于网页制作，生成动态页面比较直观，缺点是不容易跟踪与排错。<br>Servlet是纯Java语言，擅长于处理流程和业务逻辑，缺点是生成动态网页不直观。</p>
</blockquote>
<h3 id="2-7-SSH中Spring、Hibernate各自负责的角色？"><a href="#2-7-SSH中Spring、Hibernate各自负责的角色？" class="headerlink" title="2.7 SSH中Spring、Hibernate各自负责的角色？"></a>2.7 SSH中Spring、Hibernate各自负责的角色？</h3><blockquote>
<ol>
<li>Spring充当了管理容器的角色，起到的主要作用是解耦，创建对象处理对象的依赖关系以及框架整合。IOC、AOP。</li>
<li>Struts主要控制逻辑关系的处理。</li>
<li>hibernate 是数据持久化层。</li>
</ol>
</blockquote>
<h3 id="2-8-SSH中的ORM？"><a href="#2-8-SSH中的ORM？" class="headerlink" title="2.8 SSH中的ORM？"></a>2.8 SSH中的ORM？</h3><blockquote>
<p>ORM框架可作为面向对象程序语言和数据库之间的桥梁。ORM框架是面向对象程序设计语言与关系数据库发展不同步时的中间解决方案。</p>
<p>ORM的基本映射方式：</p>
<ol>
<li>数据类型映射模式</li>
<li>类映射模型</li>
<li>关联映射模式</li>
<li>引用映射模式</li>
</ol>
<p>Employee.hbm.xml 对象的映射 (映射文件)<br>hibernate.cfg.xml 数据库连接配置、加载所用的映射(*.hbm.xml)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">package sram.hello;</div><div class="line"></div><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">import org.hibernate.Session;</div><div class="line">import org.hibernate.SessionFactory;</div><div class="line">import org.hibernate.Transaction;</div><div class="line">import org.hibernate.cfg.Configuration;</div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">public class App &#123;</div><div class="line">    @Test</div><div class="line">    public void testHello() throws Exception&#123;</div><div class="line">        //对象</div><div class="line">        Employee emp = new Employee();</div><div class="line">        emp.setEmpName(&quot;Alice&quot;);</div><div class="line">        emp.setWorkDate(new Date());</div><div class="line"></div><div class="line">        //获取加载配置文件的管理类对象</div><div class="line">        Configuration config = new Configuration();</div><div class="line">        config.configure();//默认加载src/hibernate.cfg.xml文件</div><div class="line">        //创建session工厂</div><div class="line">        SessionFactory sf = config.buildSessionFactory();</div><div class="line">        //创建session(代表一个会话，与数据库连接的会话)</div><div class="line">        Session session = sf.openSession();</div><div class="line">        //开启事务</div><div class="line">        Transaction tx = session.beginTransaction();</div><div class="line">        //保存-数据库</div><div class="line">        session.save(emp);</div><div class="line">        //提交事务</div><div class="line">        tx.commit();</div><div class="line">        //关闭</div><div class="line">        session.close();</div><div class="line">        sf.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-9-通常把什么样的功能放在Spring中？"><a href="#2-9-通常把什么样的功能放在Spring中？" class="headerlink" title="2.9 通常把什么样的功能放在Spring中？"></a>2.9 通常把什么样的功能放在Spring中？</h3><blockquote>
<p><img src="http://my.csdn.net/uploads/201205/27/1338117197_8461.gif" alt=""></p>
<p>核心容器(Spring core)</p>
<p>核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。BeanFactory使用依赖注入的方式提供给组件依赖。</p>
<p>Spring上下文(Spring context)</p>
<p>Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。</p>
<p>Spring面向切面编程(Spring AOP)</p>
<p>通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p>
<p>Spring DAO模块</p>
<p>DAO模式主要目的是将持久层相关问题与一般的的业务规则和工作流隔离开来。Spring 中的DAO提供一致的方式访问数据库，不管采用何种持久化技术，Spring都提供一直的编程模型。Spring还对不同的持久层技术提供一致的DAO方式的异常层次结构。</p>
<p>Spring ORM模块</p>
<p>Spring 与所有的主要的ORM映射框架都集成的很好，包括Hibernate、JDO实现、TopLink和IBatis SQL Map等。Spring为所有的这些框架提供了模板之类的辅助类，达成了一致的编程风格。</p>
<p>Spring Web模块</p>
<p>Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。Web层使用Web层框架，可选的，可以是Spring自己的MVC框架，或者提供的Web框架，如Struts、Webwork、tapestry和jsf。</p>
<p>Spring MVC框架(Spring WebMVC)</p>
</blockquote>
<p>MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。Spring的MVC框架提供清晰的角色划分：控制器、验证器、命令对象、表单对象和模型对象、分发器、处理器映射和视图解析器。Spring支持多种视图技术。 </p>
<h3 id="2-10-Hibernate内对象session的生命周期？"><a href="#2-10-Hibernate内对象session的生命周期？" class="headerlink" title="2.10 Hibernate内对象session的生命周期？"></a>2.10 Hibernate内对象session的生命周期？</h3><blockquote>
<p><img src="http://images.cnitblog.com/blog/352511/201308/29150015-98e451d605cf4d7facee3bdca66df702.png" alt=""></p>
<p>Hibernate 三种状态</p>
<p>临时状态（Transient）：在通过new关键字，实例化一个对象开始，该对象就进入了临时状态，但它还没有被持久化，没有保存在Session当中。</p>
<p>持久化状态（Persistent）：对象被加入到Session缓存当中，如通过session.save(entity)，Hibernate把实体保存到seesion当中，entity就处在持久化状态中。</p>
<p>游离状态（Detached）：对象脱离了session缓存，如通过session清理，将对象保存到数据库中，原来在session中的对象仍然与内存中，该对象就处于游离状态。</p>
<p>hibernate Session的生命周期受到其自身属性和方法的影响，简单的说：</p>
<p>SessionFactory的openSession() 方法会开启一个session。</p>
<p>Session的flushMode会决定session何时进行flush。</p>
<p>Session的flush()方法会对session进行强制flush。</p>
<p>Session的close()方法会关闭session。</p>
<ol>
<li>读取并解析配置文件 </li>
<li>读取并解析映射信息，创建SessionFactory </li>
<li>打开Sesssion </li>
<li>创建事务Transation </li>
<li>持久化操作 </li>
<li>提交事务 </li>
<li>关闭Session </li>
<li><p>关闭SesstionFactory</p>
<p>当一个对象被实例化出来以后，该对象是临时状态，当调用方法session.save(entity)，后该对象被加入到session缓存中，进入持久化状态，这时数据库中还不存在相关的记录，当session提交数据库事务时，这里隐含做了两件事，一件事是隐式调用session.flush()，其作用先是清理缓存（相当于调用了session.clear()），再生成一条对应的insert语句，但该语句还没有提交，第二件事是对刚才生成的语句进行提交，从而在数据库中生成了对应的记录。至此原entity对象就在数据库中生成了一条对应的记录，而它本身也脱离了session缓存，处于游离状态，该对象经过垃圾回收机制处理被回收。一个hibernate的保存对象过程就此结束。</p>
</li>
</ol>
<p>Hibernate一级缓存又称为“Session的缓存”。Session的缓存是事务范围的缓存（Session对象的生命周期通常对应一个数据库事务或者一个应用事务）。</p>
<p>Hibernate二级缓存又称为“SessionFactory的缓存”。由于SessionFactory对象的生命周期和应用程序的整个过程对应，因此Hibernate二级缓存是进程范围或者集群范围的缓存。适合1) 很少被修改的数据 2) 不是很重要的数据，允许出现偶尔并发的数据 3) 不会被并发访问的数据 4) 常量数据 。</p>
<p>当Hibernate根据ID访问数据对象的时候，首先从Session一级缓存中查；查不到，如果配置了二级缓存，那么从二级缓存中查；如果都查不到，再查询数据库，把结果按照ID放入到缓存删除、更新、增加数据的时候，同时更新缓存。</p>
<p>Session的延迟加载实现要解决两个问题：正常关闭连接和确保请求中访问的是同一个session。Hibernate session就是java.sql.Connection的一层高级封装，一个session对应了一个Connection。http请求结束后正确的关闭session（过滤器实现了session的正常关闭）；延迟加载必须保证是同一个session（session绑定在ThreadLocal）。</p>
</blockquote>
<h3 id="2-11-SSH，SSM请求过程？"><a href="#2-11-SSH，SSM请求过程？" class="headerlink" title="2.11 SSH，SSM请求过程？"></a>2.11 SSH，SSM请求过程？</h3><blockquote>
<p>SSH</p>
<ol>
<li>jsp页面，提交表单或者点击链接会触发一个action。</li>
<li>action交给struts2处理，读取struts.xml文件，在配置中找到对应的action。</li>
<li>根据struts.xml文件中找到的class=”XXXAction”交给spring，读取Spring容器的配置文件/WebRoot/WEB-INF/applicationContext.xml文件。根据applicationContext.xml配置文件找到xxx.xxx.action.xxxAction类，其中有一个属性xxxService,并提供setxxxService()方法，由applicationContext.xml文件得知该xxxService对象由Spring容器依赖注入，set注入。</li>
<li>取得xxxService对象(接口对接口实现类的一个引用)后，调用它的方法。后面的就是访问DAO了。</li>
<li>执行的结果会在action的对应的方法中以字符串的形式给出。然后根据配置文件中的result.找到下一步要执行的动作，是跳转到页面显示还是继续交给其他的action处理。</li>
</ol>
<p><img src="http://img0.imgtn.bdimg.com/it/u=931081471,3169631465&amp;fm=214&amp;gp=0.jpg" alt=""></p>
<p>SSM</p>
<p><img src="https://www.2cto.com/uploadfile/Collfiles/20160402/20160402094622923.jpg" alt=""></p>
</blockquote>
<h3 id="2-12-Spring如何实现AOP，那几种方式实现，内部如何实现？"><a href="#2-12-Spring如何实现AOP，那几种方式实现，内部如何实现？" class="headerlink" title="2.12 Spring如何实现AOP，那几种方式实现，内部如何实现？"></a>2.12 Spring如何实现AOP，那几种方式实现，内部如何实现？</h3><blockquote>
<p>Spring提供了4种实现AOP的方式：</p>
<ol>
<li>经典的基于代理的AOP</li>
<li>@AspectJ注解驱动的切面</li>
<li>纯POJO切面</li>
<li>注入式AspectJ切面</li>
</ol>
<p>内部实现：<br>动态代理就是说AOP框架不会去修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
</blockquote>
<h3 id="2-13-Struts2中的拦截器的实现运用哪一种设计模式？"><a href="#2-13-Struts2中的拦截器的实现运用哪一种设计模式？" class="headerlink" title="2.13 Struts2中的拦截器的实现运用哪一种设计模式？"></a>2.13 Struts2中的拦截器的实现运用哪一种设计模式？</h3><blockquote>
<p>拦截器用到了代理模式，过滤器用到了责任链的设计模式。<br>拦截器栈（Interceptor Stack）：将拦截器按一定的顺序联结成一条链，在访问被拦截的方法时，Struts2拦截器链中的拦截器就会按其之前定义的顺序依次调用。类似于FilterChain，但又有很大的不同，比如FilterChain需要在编写doFilter方法时自行实现返回时的过滤以及链的向下执行，并且是在Servlet容器执行的这些操作。相反Intercetor是通过反射，通过XWork容器调用，自动返回拦截。</p>
<p><img src="https://pic2.zhimg.com/0095fecf492250c5bbdbd347cd49e5cd_b.png" alt=""></p>
</blockquote>
<h2 id="3-基础知识"><a href="#3-基础知识" class="headerlink" title="3. 基础知识"></a>3. 基础知识</h2><h3 id="3-1-TCP如何保证消息传递的顺序？"><a href="#3-1-TCP如何保证消息传递的顺序？" class="headerlink" title="3.1 TCP如何保证消息传递的顺序？"></a>3.1 TCP如何保证消息传递的顺序？</h3><blockquote>
<ol>
<li>主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认，</li>
<li>如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。</li>
<li>接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等，</li>
<li>接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理。</li>
</ol>
</blockquote>
<h3 id="3-2-出现拥塞如何解决？如何进行流量控制？"><a href="#3-2-出现拥塞如何解决？如何进行流量控制？" class="headerlink" title="3.2 出现拥塞如何解决？如何进行流量控制？"></a>3.2 出现拥塞如何解决？如何进行流量控制？</h3><blockquote>
<p>TCP的流量控制是利用滑动窗口机制实现的，流量的端到端控制的实现是接收方在返回的ACK中会包含自己的接收窗口的大小，以控制发送方的数据发送。<br>TCP的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。</p>
<p>网络中的链路容量和交换结点中的缓存和处理机都有着工作的极限，当网络的需求超过它们的工作极限时，就出现了拥塞。拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p>
<ol>
<li>慢开始（Slow-Start）和拥塞避免（Congestion Avoidance）结合</li>
</ol>
<p><img src="http://img.blog.csdn.net/20161117115524747" alt=""></p>
<p>（1）当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。<br>（2）当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。<br>（3）当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p>
<ol>
<li>快重传（Fast Retransmit）和快恢复（Fast Recovery）结合</li>
</ol>
<p><img src="http://img.blog.csdn.net/20161117115612966" alt=""></p>
<p><img src="http://img.blog.csdn.net/20161117115641310" alt=""></p>
<p>（1）当发送方在cwnd=24时连续收到三个重复确认，就把慢开始门限ssthresh减半，就是上图中的24修改为12。这是为了预防网络发生拥塞。<br>（2）与慢开始不同之处是现在不执行慢开始算法，而是把cwnd值设置为慢开始门限ssthresh减半后的数值，即cwnd不是设置为1而是设置为12，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。<br>这里为什么替换掉了慢开始算法呢，这是因为收到重复的ACK不仅仅告诉我们一个分组丢失了，由于接收方只有在收到另一个报文段时才会产生重复的ACK，所以还告诉我们该报文段已经离开了网络并进入了接收方的缓存。也就是说，在收发两端之间仍然有流动的数据，而我们不想执行慢启动来突然减少数据流。无论在慢开始阶段还是在拥塞避免阶段，只要发送方没有收到确认通知判断网络出现拥塞，就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半，上例中是把发送方窗口值24修改为12。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p>参考文章：<a href="http://www.cnblogs.com/qitian1/p/6461468.html" target="_blank" rel="external">NetWork——TCP的流量控制和拥塞控制</a></p>
</blockquote>
<h3 id="3-3-HTTP状态码以3开头的含义？"><a href="#3-3-HTTP状态码以3开头的含义？" class="headerlink" title="3.3 HTTP状态码以3开头的含义？"></a>3.3 HTTP状态码以3开头的含义？</h3><blockquote>
<ol>
<li>重定向。基本上会配合Location首部字段来使用。301、302、304是HTTP1.0定义的，303、307是HTTP1.1定义的。</li>
<li>301：永久性重定向，该状态码表示请求的资源已被分配了新的URI，以后应使用Location指定的URI。</li>
<li>302：表示资源是临时性移动，已移动资源对应的URI将来还可能发生改变。301和302标准是禁止将post请求改变为get请求的，即原先使用post的请求，收到301和302的响应时，不能使用get请求Location指定的URI，而是应该得到用户的确认，然后使用post请求Location指定的URI。但是很多浏览器为了方便，直接略过用户确认，并使用get请求Location指定的URI。</li>
<li>303：与302类似。标准明确规定客户端应使用get请求Location指定的URI。</li>
<li>304：304其实和重定向没有任何关系。当客户端缓存了目标资源但不确定该缓存资源是否是最新版本的时候,就会发送一个条件请求.在Fiddler中,你可以在Headers Inspector查找相关请求头,这样就可以辨别出一个请求是否是条件请求。服务器会读取到这两个请求头中的值,判断出客户端缓存的资源是否是最新的,如果是的话,服务器就会返回HTTP/304 Not Modified响应。</li>
<li>307：相当于302，由于浏览器对于302标准并不遵守，因此定义307来代替302。post请求不会改变为get请求。</li>
</ol>
</blockquote>
<h3 id="3-3-进程之间的通信方式？"><a href="#3-3-进程之间的通信方式？" class="headerlink" title="3.3 进程之间的通信方式？"></a>3.3 进程之间的通信方式？</h3><blockquote>
<ol>
<li>无名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li>高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</li>
<li>有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>
<li>套接字( socket ) ： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;美团点评一面&quot;&gt;&lt;a href=&quot;#美团点评一面&quot; class=&quot;headerlink&quot; title=&quot;美团点评一面&quot;&gt;&lt;/a&gt;美团点评一面&lt;/h1&gt;&lt;blockq
    
    </summary>
    
      <category term="面试记录" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
      <category term="meituan" scheme="http://lincentma.men/tags/meituan/"/>
    
  </entry>
  
  <entry>
    <title>百度运维一面</title>
    <link href="http://lincentma.men/baidu_interview.html"/>
    <id>http://lincentma.men/baidu_interview.html</id>
    <published>2017-09-01T14:16:55.000Z</published>
    <updated>2017-09-01T14:19:30.235Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="百度运维一面"><a href="#百度运维一面" class="headerlink" title="百度运维一面"></a>百度运维一面</h1><blockquote>
<p>问的最多的问题就是你为什么不在原来的部门留下来。<br>这个问题回答的不是很自信。</p>
<p>面对自己的过去，明白自己想要的。</p>
</blockquote>
<h2 id="1-实习经历梳理以及Sug项目介绍"><a href="#1-实习经历梳理以及Sug项目介绍" class="headerlink" title="1. 实习经历梳理以及Sug项目介绍"></a>1. 实习经历梳理以及Sug项目介绍</h2><blockquote>
<p>还不错。</p>
</blockquote>
<h2 id="2-关于正则表达式"><a href="#2-关于正则表达式" class="headerlink" title="2. 关于正则表达式"></a>2. 关于正则表达式</h2><h3 id="2-1-项目中正则表达式匹配效率"><a href="#2-1-项目中正则表达式匹配效率" class="headerlink" title="2.1 项目中正则表达式匹配效率"></a>2.1 项目中正则表达式匹配效率</h3><blockquote>
<p>自己当时说自己主要是匹配一些策略类型，然后聊到匹配的效率，同阿伦如何一次匹配所有。因为自己之前是写了几个正则表达式去匹配各自的信息。</p>
</blockquote>
<h3 id="2-2-写出提取一行中所有满足格式的数据的正则表达式：例如提取a-3-b-2-c-1-…"><a href="#2-2-写出提取一行中所有满足格式的数据的正则表达式：例如提取a-3-b-2-c-1-…" class="headerlink" title="2.2 写出提取一行中所有满足格式的数据的正则表达式：例如提取a:3, b:2, c:1,…"></a>2.2 写出提取一行中所有满足格式的数据的正则表达式：例如提取a:3, b:2, c:1,…</h3><blockquote>
<p>如何提取？<br>类似于匹配多个结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public void testRegex() &#123;  </div><div class="line">      String msg = &quot;Rect(x1=\&quot;0\&quot; y1=\&quot;0\&quot; x2=\&quot;416\&quot; y2=\&quot;416\&quot;)Rect(x1=\&quot;1\&quot; y1=\&quot;2\&quot; x2=\&quot;413\&quot; y2=\&quot;414\&quot;)&quot;;  </div><div class="line">      List&lt;String&gt; textList = new ArrayList&lt;String&gt;();  </div><div class="line">      Pattern pattern = Pattern.compile(&quot;(x1=\&quot;[^\&quot;]*\&quot;\\s*y1=\&quot;[^\&quot;]*\&quot;\\s*x2=\&quot;[^\&quot;]*\&quot;\\s*y2=\&quot;[^\&quot;]*\&quot;)&quot;);  </div><div class="line">      Matcher matcher = pattern.matcher(msg);  </div><div class="line">      while (matcher.find()) &#123;  </div><div class="line">          textList.add(matcher.group(1));  </div><div class="line">      &#125;  </div><div class="line">      for (String text : textList) &#123;  </div><div class="line">          try &#123;  </div><div class="line">              System.out.println(text);  </div><div class="line">              System.out.println(getValue(text, &quot;x1&quot;));  </div><div class="line">              System.out.println(getValue(text, &quot;y1&quot;));  </div><div class="line">              System.out.println(getValue(text, &quot;x2&quot;));  </div><div class="line">              System.out.println(getValue(text, &quot;y2&quot;));  </div><div class="line">          &#125;  </div><div class="line">          catch (Exception ex)  </div><div class="line">          &#123;&#125;  </div><div class="line">      &#125;  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="3-crontab实现原理以及使用格式"><a href="#3-crontab实现原理以及使用格式" class="headerlink" title="3. crontab实现原理以及使用格式"></a>3. crontab实现原理以及使用格式</h2><blockquote>
<p>周期执行的任务一般由cron这个守护进程来处理。cron读取一个或多个配置文件，这些配置文件中包含了命令行及其调用时间。cron的配置文件称为“crontab”，是“cron table”的简写。</p>
<p>一旦cron进程启动，它就会读取配置文件，并将其保存在内存中，接着自己转入到休眠状态。以后每分钟会醒来一次检查配置文件，读取修改过的，并执行为这一刻安排的任务，然后再转入休眠。</p>
<p><img src="https://pic2.zhimg.com/15cf8e0cb2f82a8b54fc4205546ea3f1_b.jpg" alt=""></p>
<p>实例5：每个星期一的上午8点到11点的第3和第15分钟执行<br>命令： 3,15 8-11 <em> </em> 1 command</p>
</blockquote>
<h2 id="4-如何在日志中找到ip最大的10个，Linux命令以及设计算法实现"><a href="#4-如何在日志中找到ip最大的10个，Linux命令以及设计算法实现" class="headerlink" title="4. 如何在日志中找到ip最大的10个，Linux命令以及设计算法实现"></a>4. 如何在日志中找到ip最大的10个，Linux命令以及设计算法实现</h2><blockquote>
<p>自己回答桶排序是错的，IP32位无法映射完所有的IP</p>
<p>IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理。</p>
<p>按照IP地址的Hash(IP) % 1024的值，把海量IP日志分别存储到1024个小文件中，这样，每个小文件最多包含4MB个IP地址；</p>
<p>每一个文件中建立Top10的堆, 比较IP地址大小，遍历维护堆</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"> /** </div><div class="line"> * 比较两个ip地址，如果两个都是合法地址，则1代表ip1大于ip2，-1代表ip1小于ip2,0代表相等； </div><div class="line"> * 如果有其一不是合法地址，如ip2不是合法地址，则ip1大于ip2，返回1，反之返回-1；两个都是非法地址时，则返回0； </div><div class="line"> * 注意此处的ip地址指的是如“192.168.1.1”地址，并不包括mask </div><div class="line"> * @return </div><div class="line"> */  </div><div class="line"> public static int compareIpV4s(String ip1,String ip2)  </div><div class="line"> &#123;  </div><div class="line">      int result = 0;  </div><div class="line">      int ipValue1 = getIpV4Value(ip1);     // 获取ip1的32bit值  </div><div class="line">      int ipValue2 = getIpV4Value(ip2); // 获取ip2的32bit值  </div><div class="line">      if(ipValue1 &gt; ipValue2)  </div><div class="line">      &#123;  </div><div class="line">           result =  -1;  </div><div class="line">      &#125;  </div><div class="line">      else if(ipValue1 &lt;= ipValue2)  </div><div class="line">      &#123;  </div><div class="line">           result = 1;  </div><div class="line">      &#125;  </div><div class="line">      return result;  </div><div class="line"> &#125;  </div><div class="line"></div><div class="line">public static int getIpV4Value(String ipOrMask)  </div><div class="line"> &#123;  </div><div class="line">      byte[] addr = getIpV4Bytes(ipOrMask);  </div><div class="line">      int address1  = addr[3] &amp; 0xFF;  </div><div class="line">      address1 |= ((addr[2] &lt;&lt; 8) &amp; 0xFF00);  </div><div class="line">      address1 |= ((addr[1] &lt;&lt; 16) &amp; 0xFF0000);  </div><div class="line">      address1 |= ((addr[0] &lt;&lt; 24) &amp; 0xFF000000);  </div><div class="line">      return address1;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>最后遍历所有的堆取所有的Top10。</p>
</blockquote>
<h2 id="5-MySQL中联合索引（A，B，C）单独使用B会使用联合索引吗？联合索引为什么比单独的索引快？"><a href="#5-MySQL中联合索引（A，B，C）单独使用B会使用联合索引吗？联合索引为什么比单独的索引快？" class="headerlink" title="5. MySQL中联合索引（A，B，C）单独使用B会使用联合索引吗？联合索引为什么比单独的索引快？"></a>5. MySQL中联合索引（A，B，C）单独使用B会使用联合索引吗？联合索引为什么比单独的索引快？</h2><blockquote>
<p>SELECT  *  FROM TABLE_NAME  WHERE COL1=’ABC’  AND  COL2=123;</p>
<p>在2个列上单独创建索引，如果查询语句使用到，叫合并索引；如果是在2个列上创建组合索引，就叫组合索引。</p>
<p>单独的2个索引进行查找——索引合并，需要反复在2个索引表间进行跳转，这是造成速度慢的第一个影响。第2个影响是，假设满足COL1=’ABC’的数据有5行，满足COL2=123的数据有1000行。最坏的情况下（那5行在COL2的1000行最后面）需要扫描完COL2的1000行才能找到需要的数据，并不能达到快速查找的目的。</p>
<p>由于组合索引综合保存了COL1和COL2的数据，它不需要在2个索引表之间跳转，所以速度会更快。组合索引不需要像索引合并那样对索引的ROWID进行比较合并。</p>
<p>复合索引的优势只有查询复合索引的全部列，并且按索引的设置顺序查询，最重要的是一定要有首列的查询条件。</p>
<p><img src="http://segmentfault.com/img/bVbBfF" alt=""></p>
</blockquote>
<h2 id="6-手写堆排序维护最大的10个数"><a href="#6-手写堆排序维护最大的10个数" class="headerlink" title="6. 手写堆排序维护最大的10个数"></a>6. 手写堆排序维护最大的10个数</h2><blockquote>
<p>Key[i]&lt;=key[2i+1]&amp;&amp;Key[i]&lt;=key[2i+2]或者Key[i]&gt;=Key[2i+1]&amp;&amp;key[i]&gt;=key[2i+2]即任何一非叶节点的关键字不大于或者不小于其左右孩子节点的关键字。</p>
<p>step 1. 随意选出K个数，挑出这K个数的最小的数。这个过程可以用最小堆完成。</p>
<p>step 2. 在剩下的n – K个数中，挑出任意一个数m，和最小堆的堆顶进行比较，如果比最小堆的堆顶大，那么说明此数可以入围前K的队伍，于是将最小堆的堆顶置为当前的数m。</p>
<p>step 3. 调整最小堆。时间复杂度为Olg(K)，由于K是constant(常数级别)，所以时间复杂度可以认为是常数级别。</p>
<p>step 4. 重复进行step 2 ~ step 3，直到剩下的n – K个数完成。进行了n –constant次，时间复杂度为O(n lgK)。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by jeff on 16/5/11.</div><div class="line"> */</div><div class="line">public class MinHeap &#123;</div><div class="line">    // 堆的存储结构 - 数组</div><div class="line">    private int[] data;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化堆中的数据,以int的最小值作为初始值</div><div class="line">     *</div><div class="line">     * @param k</div><div class="line">     */</div><div class="line">    public MinHeap(int k)</div><div class="line">    &#123;</div><div class="line">        this.data = new int[k];</div><div class="line">        for(int i=0;i&lt;k;i++)&#123;</div><div class="line">            data[i]=Integer.MIN_VALUE;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void adjustHeap(int i)</div><div class="line">    &#123;</div><div class="line">        //获取左右结点的数组下标</div><div class="line">        int l = left(i);</div><div class="line">        int r = right(i);</div><div class="line"></div><div class="line">        // 这是一个临时变量，表示 跟结点、左结点、右结点中最小的值的结点的下标</div><div class="line">        int min = i;</div><div class="line"></div><div class="line">        // 存在左结点，且左结点的值小于根结点的值</div><div class="line">        if (l &lt; data.length &amp;&amp; data[l]&lt;data[i])&#123;</div><div class="line">            min = l;</div><div class="line">        &#125;</div><div class="line">        // 存在右结点，且右结点的值小于以上比较的较小值</div><div class="line">        if (r &lt; data.length &amp;&amp; data[r]&lt;data[min])&#123;</div><div class="line">            min = r;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 左右结点的值都大于根节点，直接return，不做任何操作</div><div class="line">        if (i == min)</div><div class="line">            return;</div><div class="line"></div><div class="line">        // 交换根节点和左右结点中最小的那个值，把根节点的值替换下去</div><div class="line">        swap(i, min);</div><div class="line"></div><div class="line">        // 由于替换后左右子树会被影响，所以要对受影响的子树再进行adjustHeap</div><div class="line">        adjustHeap(min);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取右结点的数组下标</div><div class="line">     * @param i</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private int right(int i)</div><div class="line">    &#123;</div><div class="line">        return (i + 1) &lt;&lt; 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取左结点的数组下标</div><div class="line">     * @param i</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private int left(int i)</div><div class="line">    &#123;</div><div class="line">        return ((i + 1) &lt;&lt; 1) - 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 交换元素位置</div><div class="line">     *</div><div class="line">     * @param i</div><div class="line">     * @param j</div><div class="line">     */</div><div class="line">    private void swap(int i, int j)</div><div class="line">    &#123;</div><div class="line">        int tmp = data[i];</div><div class="line">        data[i] = data[j];</div><div class="line">        data[j] = tmp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 将数值加入到堆中</div><div class="line">     *</div><div class="line">     * @param element</div><div class="line">     */</div><div class="line">    public void add(int element)</div><div class="line">    &#123;</div><div class="line">        if(element&gt;data[0]) &#123;</div><div class="line">            data[0] = element;</div><div class="line">            adjustHeap(0);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int[] getData()&#123;</div><div class="line">        return data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString()&#123;</div><div class="line">        StringBuilder builder = new StringBuilder();</div><div class="line">        builder.append(&quot;&#123;&quot;);</div><div class="line">        for (int i=0;i&lt;data.length;i++)&#123;</div><div class="line">            builder.append(data[i]);</div><div class="line">            if(i!=data.length-1)&#123;</div><div class="line">                builder.append(&quot;,&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        builder.append(&quot;&#125;&quot;);</div><div class="line"></div><div class="line">        return builder.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>参考文章：<a href="http://blog.csdn.net/cyxlzzs/article/details/51375974" target="_blank" rel="external">算法——TOP K问题最小堆实现</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;百度运维一面&quot;&gt;&lt;a href=&quot;#百度运维一面&quot; class=&quot;headerlink&quot; title=&quot;百度运维一面&quot;&gt;&lt;/a&gt;百度运维一面&lt;/h1&gt;&lt;blockq
    
    </summary>
    
      <category term="面试记录" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
      <category term="baidu" scheme="http://lincentma.men/tags/baidu/"/>
    
  </entry>
  
  <entry>
    <title>蘑菇街二面记录</title>
    <link href="http://lincentma.men/mogujie_interview_2.html"/>
    <id>http://lincentma.men/mogujie_interview_2.html</id>
    <published>2017-08-31T04:04:03.000Z</published>
    <updated>2017-08-31T04:05:36.334Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="蘑菇街二面"><a href="#蘑菇街二面" class="headerlink" title="蘑菇街二面"></a>蘑菇街二面</h1><blockquote>
<p>全是项目<br>对于活动类问题问的非常详细</p>
</blockquote>
<h2 id="项目中面试询问计数点"><a href="#项目中面试询问计数点" class="headerlink" title="项目中面试询问计数点"></a>项目中面试询问计数点</h2><h3 id="1-项目流程图"><a href="#1-项目流程图" class="headerlink" title="1. 项目流程图"></a>1. 项目流程图</h3><pre><code>- 略。
</code></pre><h3 id="2-订单中心接口的时延是多少？"><a href="#2-订单中心接口的时延是多少？" class="headerlink" title="2. 订单中心接口的时延是多少？"></a>2. 订单中心接口的时延是多少？</h3><pre><code>- 接口文档说明。
- 自己的理解应该是如何降低接口的响应时间？
    - 从接口垂直与水平拆分（MapReduce）：项目没用到。。。
    - 接口缓存与本地缓存 ：对于订单的实时获取，将用户的最新订单缓存到本地，然后计算结果放入缓存？随之带来存储问题？感觉可以把用户信息缓存，省去一部分查询用户的时间比较实际？
    - 非核心流程异步化：类似于发消息，写日志，更新缓存等不会影响接口准确性的非核心流程，可以采用异步方式进行处理，不阻塞主计算逻辑处理。
    - 内部并发：项目没有考虑。
    - 参考文章：[如何减少接口响应时间](http://blog.csdn.net/xiaoxuan2015/article/details/51240872)
</code></pre><h3 id="3-高QPS下如何保证接口访问的稳定性？除了加服务器之外？"><a href="#3-高QPS下如何保证接口访问的稳定性？除了加服务器之外？" class="headerlink" title="3. 高QPS下如何保证接口访问的稳定性？除了加服务器之外？"></a>3. 高QPS下如何保证接口访问的稳定性？除了加服务器之外？</h3><pre><code>- QPS（TPS）：每秒钟request/事务 数量
- 并发数： 系统同时处理的request/事务数
- 响应时间：  一般取平均响应时间

- 自己的理解应该是业务的解耦分拆，提高并发量。具体没有实践所以需要好好学习。
- 服务做到多少QPS，多长的耗时，应结合手头有限的资源、业务需求来制定。

- 参考文章：[美团团购订单系统优化记](https://tech.meituan.com/meituan_tuangou_order.html)
- 非常有价值的文章。
</code></pre><h3 id="4-高QPS下哪一个模块的压力最大？如何解决？"><a href="#4-高QPS下哪一个模块的压力最大？如何解决？" class="headerlink" title="4. 高QPS下哪一个模块的压力最大？如何解决？"></a>4. 高QPS下哪一个模块的压力最大？如何解决？</h3><pre><code>- 数据库访问。引入连接池。
- 如果在代码中显式为每次操作分别建立并释放资源，无疑增大了业务代码的复杂度，并且建立和释放连接的开销变得不可忽略。
</code></pre><h3 id="5-对于超时如何处理？"><a href="#5-对于超时如何处理？" class="headerlink" title="5. 对于超时如何处理？"></a>5. 对于超时如何处理？</h3><pre><code>- 尝试多调用一次
- 使用待处理队列
- 回滚数据
- 使用异步机制
- 参考文章：[【干货篇】调用其他系统http接口超时了，如何处理，方案汇总](http://blog.csdn.net/linsongbin1/article/details/50393383)

- 自己的理解：对于活动类需要实时返回查询结果的，增加尝试调用次数是最合适的选择，要有错误策略来包容所有的错误类别。
- 实际项目中对于API接口调用是通过RAL调用，通过配置RAL的相关超时信息设置。具体设置搞忘了。
</code></pre><h3 id="6-如何确定每一次接口数据查询范围？极端数据情况占比多少？如何考虑这部分的数据的处理？"><a href="#6-如何确定每一次接口数据查询范围？极端数据情况占比多少？如何考虑这部分的数据的处理？" class="headerlink" title="6. 如何确定每一次接口数据查询范围？极端数据情况占比多少？如何考虑这部分的数据的处理？"></a>6. 如何确定每一次接口数据查询范围？极端数据情况占比多少？如何考虑这部分的数据的处理？</h3><pre><code>- 针对于活动类接口，数据查询范围是根据活动规则制定，那么如何制定活动规则保证尽可能所有多的用户满足活动？
- 另一方面，调用其他接口获取数据量也需要根据实际需求去保证接口响应时间的可控性。
- API接口设计的考虑因素：是否需要为一小部分数据的需求去增加所有的适配工作？还是为了保证大部分的使用体验，对于小部分进行抛出错误的设计？
- 如何根据现有资源和条件进行权衡?
</code></pre><h3 id="7-活动中有用到消息队列吗？"><a href="#7-活动中有用到消息队列吗？" class="headerlink" title="7. 活动中有用到消息队列吗？"></a>7. 活动中有用到消息队列吗？</h3><pre><code>- 消息队列解决的是将突发大量请求转换为后端能承受的队列请求。
- NMQ。
- 参考文章：[nmq消息队列解析](http://www.cnblogs.com/lushilin/p/6209976.html)
</code></pre><h3 id="8-自己的学习目标和计划？"><a href="#8-自己的学习目标和计划？" class="headerlink" title="8. 自己的学习目标和计划？"></a>8. 自己的学习目标和计划？</h3>]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;蘑菇街二面&quot;&gt;&lt;a href=&quot;#蘑菇街二面&quot; class=&quot;headerlink&quot; title=&quot;蘑菇街二面&quot;&gt;&lt;/a&gt;蘑菇街二面&lt;/h1&gt;&lt;blockquote
    
    </summary>
    
      <category term="面试记录" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
      <category term="mogujie" scheme="http://lincentma.men/tags/mogujie/"/>
    
  </entry>
  
  <entry>
    <title>蘑菇街一面记录</title>
    <link href="http://lincentma.men/mogujie_interview.html"/>
    <id>http://lincentma.men/mogujie_interview.html</id>
    <published>2017-08-28T14:11:49.000Z</published>
    <updated>2017-08-28T14:13:31.385Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="蘑菇街应用平台开发工程师一面"><a href="#蘑菇街应用平台开发工程师一面" class="headerlink" title="蘑菇街应用平台开发工程师一面"></a>蘑菇街应用平台开发工程师一面</h1><blockquote>
<p>面试官给自己的建议是，按部就班，面试偶然性很多，没有办法一应俱全，打好自己的基础才是最好的办法。</p>
</blockquote>
<h2 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h2><ol>
<li><p>Java集合中哪些是线程安全的？</p>
<ul>
<li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。<br>在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li>
<li>statck：堆栈类，先进后出。</li>
<li>hashtable：内部的方法基本都是synchronized。</li>
<li>enumeration：枚举，相当于迭代器。</li>
</ul>
</li>
<li><p>Java集合其他的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">java.util.Collection [I]</div><div class="line">+--java.util.List [I]</div><div class="line">   +--java.util.ArrayList [C]</div><div class="line">   +--java.util.LinkedList [C]</div><div class="line">   +--java.util.Vector [C]</div><div class="line">      +--java.util.Stack [C]</div><div class="line">+--java.util.Set [I]</div><div class="line">   +--java.util.HashSet [C]</div><div class="line">   +--java.util.SortedSet [I]</div><div class="line">      +--java.util.TreeSet [C]</div><div class="line">java.util.Map [I]</div><div class="line">+--java.util.SortedMap [I]</div><div class="line">   +--java.util.TreeMap [C]</div><div class="line">+--java.util.Hashtable [C]</div><div class="line">+--java.util.HashMap [C]</div><div class="line">+--java.util.LinkedHashMap [C]</div><div class="line">+--java.util.WeakHashMap [C]</div></pre></td></tr></table></figure>
</li>
<li><p>ArrayList与LinkedList区别，增删改查时间复杂度区别？</p>
<ul>
<li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 </li>
<li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 </li>
<li><p>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</p>
</li>
<li><p>当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList.</p>
</li>
<li>ArrayList 是线性表（数组）<ul>
<li>get() 直接读取第几个下标，复杂度 O(1)</li>
<li>add(E) 添加元素，直接在后面添加，复杂度O(1)</li>
<li>add(index, E) 添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度O(n)</li>
<li>remove() 删除元素，后面的元素需要逐个移动，复杂度O(n)</li>
</ul>
</li>
<li>LinkedList 是链表的操作<ul>
<li>get() 获取第几个元素，依次遍历，复杂度O(n)</li>
<li>add(E) 添加到末尾，复杂度O(1)</li>
<li>add(index, E) 添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度O(n)</li>
<li>remove() 删除元素，直接指针指向操作，复杂度O(1)</li>
</ul>
</li>
</ul>
</li>
<li><p>如何描述链表的数据结构</p>
<ul>
<li>链表种类：单向链表、双向链表、单向循环链表和双向循环链表</li>
<li>单向链表：每个元素包含两部分：数据域和一个称为next的指针域。通过采用这种结构，next的指针域将按某一个方向指向其下一个元素。最后一个元素的next指针域指向NULL，即为空，它表示链表的末尾元素，链表的第一个元素称为“头”元素。</li>
</ul>
</li>
</ol>
<h2 id="项目详细状况"><a href="#项目详细状况" class="headerlink" title="项目详细状况"></a>项目详细状况</h2><ol>
<li>报表日志项目流程</li>
<li>遇到哪些问题，如何解决？</li>
</ol>
<h2 id="MySQL手写语句"><a href="#MySQL手写语句" class="headerlink" title="MySQL手写语句"></a>MySQL手写语句</h2><p>1.三个表（school、class、student）连接查询，查找制定学校、学院、姓名的学号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT 学生.id,学生.name </div><div class="line">FROM 学校,院系,学生</div><div class="line">WHERE 学校.id=院系.sid AND 学生.cid=院系.id</div><div class="line">AND 学校.name = &quot;大学&quot; and 院系.name = &quot;信息&quot; and 学生.name = &quot;小王&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select 学生.id,学生.name</div><div class="line">  from 学校     </div><div class="line">  inner join 院系 on 学校.id=院系.sid  </div><div class="line">  inner join 学生 on 学生.cid=院系.id  </div><div class="line">  where 学校.name = &quot;大学&quot; and 院系.name = &quot;信息&quot; and 学生.name = &quot;小王&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">子查询嵌套</div></pre></td></tr></table></figure>
<ul>
<li>from多表加上where和多个inner join表加上on条件查询结果一样的，都是做完笛卡尔积在从里面根据条件筛选数据。</li>
<li>优化核心在索引。</li>
</ul>
<h2 id="Linux手写语句"><a href="#Linux手写语句" class="headerlink" title="Linux手写语句"></a>Linux手写语句</h2><blockquote>
<p>看过不如写过的感受</p>
</blockquote>
<ol>
<li><p>在123.txt中找到abc所在的行</p>
<ul>
<li>grep –i “被查找的字符串” 文件名</li>
<li>cat 123.txt | grep -n ‘wang’</li>
</ul>
</li>
<li><p>输出所有找到的行数</p>
<ul>
<li>grep -c “被查找的字符串” 文件名</li>
<li>cat 123.txt | grep -c ‘wang’</li>
</ul>
</li>
<li>输出所有匹配的行号<ul>
<li>cat 123.txt | grep -n ‘wang’ | awk -F: ‘{print $1}’ </li>
</ul>
</li>
<li>grep命令原理</li>
</ol>
<ul>
<li>find命令是根据文件的属性进行查找。</li>
<li>grep是根据文件的内容进行查找，会对文件的每一行按照给定的模式(patter)进行匹配查找。<ul>
<li>－c：只输出匹配行的计数。</li>
<li>－i：不区分大小写</li>
<li>－h：查询多文件时不显示文件名。</li>
<li>－l：查询多文件时只输出包含匹配字符的文件名。</li>
<li>－n：显示匹配行及行号。</li>
<li>－s：不显示不存在或无匹配文本的错误信息。</li>
<li>－v：显示不包含匹配文本的所有行。</li>
</ul>
</li>
<li>grep是基于行的文本搜索 工具， 按匹配模式打印出符合条件的所有行。sed是流式文本编辑器，每次读入一行，处理一行；</li>
</ul>
<h2 id="开放性试题"><a href="#开放性试题" class="headerlink" title="开放性试题"></a>开放性试题</h2><ol>
<li>如何设计斗地主的发牌过程</li>
</ol>
<ul>
<li>int CardValueArray[54]。我们将54个元素用来代表不同的牌。</li>
<li>CardValueArray[0——–12]:    方块A———方块K</li>
<li>CardValueArray[13——-25]:    梅花A———梅花K</li>
<li>CardValueArray[26——-38]:    红心A———红心K</li>
<li>CardValueArray[39——-51]:    黑桃A———黑桃K</li>
<li>CardValueArray[52] 小鬼   </li>
<li>CardValueArray[53] 大鬼</li>
<li><p>规则：将数组分为4份。3份17张，1份3张（抢地主牌）。将3份17张牌，依次分发给3个不同的玩家。</p>
<ul>
<li>方法一：Collections.shuffle(CardValueArray); 该方法方法用于随机排列随机使用一个默认的源指定的列表。然后依次取出17张牌即可。</li>
<li>方法二：顺序写入，随机生成0-53随机数，依次遍历交换，达到洗牌的目的。最后依次取出17张牌。<ul>
<li>顺序遍历，每次生成一个随机位置，和当前位置的元素互换。运行时间是线性的。 </li>
</ul>
</li>
<li>面试官问的思路应该是如何把一个数组随机排列，并且减少交换次数？<ul>
<li>未来待续</li>
</ul>
</li>
</ul>
</li>
<li><p>参考文章：<a href="https://www.zhihu.com/question/19695571" target="_blank" rel="external">QQ 斗地主发牌是完全随机吗？</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;蘑菇街应用平台开发工程师一面&quot;&gt;&lt;a href=&quot;#蘑菇街应用平台开发工程师一面&quot; class=&quot;headerlink&quot; title=&quot;蘑菇街应用平台开发工程师一面
    
    </summary>
    
      <category term="面试记录" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
      <category term="mogujie" scheme="http://lincentma.men/tags/mogujie/"/>
    
  </entry>
  
  <entry>
    <title>华为成渝地区面试</title>
    <link href="http://lincentma.men/huawei_interview.html"/>
    <id>http://lincentma.men/huawei_interview.html</id>
    <published>2017-08-26T14:00:47.000Z</published>
    <updated>2017-08-26T14:02:09.363Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="华为成渝地区面试"><a href="#华为成渝地区面试" class="headerlink" title="华为成渝地区面试"></a>华为成渝地区面试</h1><blockquote>
<p>每一家公司的特点的不同就会决定了不同的面试风格以及不同的侧重点<br>记录每一个不同，完善自己</p>
</blockquote>
<h2 id="一面业务面"><a href="#一面业务面" class="headerlink" title="一面业务面"></a>一面业务面</h2><ol>
<li><p>重点在于项目细节</p>
<ul>
<li>手绘项目流程图</li>
<li>项目实现细节</li>
<li>自己负责的部分详细说明</li>
</ul>
</li>
<li><p>Java基础知识</p>
<ul>
<li><p>try-catch-finally 执行顺序</p>
<ul>
<li>不管有木有出现异常，finally块中代码都会执行；</li>
<li>当try和catch中有return时，finally仍然会执行；</li>
<li>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；</li>
<li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</li>
<li>任何执行try 或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。<br>如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，<br>编译器把finally中的return实现为一个warning。</li>
<li>参考文章：<a href="">有return的情况下try catch finally的执行顺序（最有说服力的总结）</a><a href="http://blog.csdn.net/kavensu/article/details/8067850" target="_blank" rel="external">http://blog.csdn.net/kavensu/article/details/8067850</a></li>
</ul>
</li>
<li><p>描述线程安全：</p>
<ul>
<li>线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。</li>
<li>Java中对于线程安全的机制。<ul>
<li><ol>
<li>加锁。(1) 锁能使其保护的代码以串行的形式来访问，当给一个复合操作加锁后，能使其成为原子操作。一种错误的思想是只要对写数据的方法加锁，其实这是错的，对数据进行操作的所有方法都需加锁，不管是读还是写。(2) 加锁时需要考虑性能问题，不能总是一味地给整个方法加锁synchronized就了事了，应该将方法中不影响共享状态且执行时间比较长的代码分离出去。(3) 加锁的含义不仅仅局限于互斥，还包括可见性。为了确保所有线程都能看见最新值，读操作和写操作必须使用同样的锁对象。</li>
</ol>
</li>
<li><ol>
<li>不共享状态。(1) 无状态对象： 无状态对象一定是线程安全的，因为不会影响到其他线程。(2) 线程关闭： 仅在单线程环境下使用。</li>
</ol>
</li>
<li><ol>
<li>不可变对象。可以使用final修饰的对象保证线程安全，由于final修饰的引用型变量(除String外)不可变是指引用不可变，但其指向的对象是可变的，所以此类必须安全发布，也即不能对外提供可以修改final对象的接口。</li>
</ol>
</li>
</ul>
</li>
<li>参考文章：<a href="http://www.cnblogs.com/zhanht/p/5450325.html" target="_blank" rel="external">Java并发编程——线程安全及解决机制简介</a></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="二面综合面"><a href="#二面综合面" class="headerlink" title="二面综合面"></a>二面综合面</h2><blockquote>
<p>综合面最大的感觉是类似压力面的形式，多个综合性问题，反应时间短.</p>
</blockquote>
<ol>
<li>自我介绍</li>
<li>自己的优缺点。紧接着用实例描述自己的缺点。</li>
<li>你认为自己的编程水平在你的专业是什么样的水平？</li>
<li>自己认为目前行业前沿的变成设计趋势是哪些？如何理解微服务？</li>
<li>你认为优秀的编程人员和普通的编程人员的区别在哪里？</li>
<li>你认为代码能力的提高你会从哪些方面着手？</li>
<li>在你的眼中华为是一个什么样的公司，为什么选择来到华为？</li>
<li>你认为你来到华为自己具备什么样的实力？</li>
<li>如果在华为你的付出与你的回报不成正比，或者说不公平的现象在你身上发生，你该怎么办？</li>
<li>你在成都学习生活，你对于成都的印象，你的第一意向城市是哪里？</li>
<li>未完待续</li>
</ol>
<h2 id="等待结果"><a href="#等待结果" class="headerlink" title="等待结果"></a>等待结果</h2>]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;华为成渝地区面试&quot;&gt;&lt;a href=&quot;#华为成渝地区面试&quot; class=&quot;headerlink&quot; title=&quot;华为成渝地区面试&quot;&gt;&lt;/a&gt;华为成渝地区面试&lt;/h1
    
    </summary>
    
      <category term="面试记录" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>好未来面试记录</title>
    <link href="http://lincentma.men/haoweilai_interview.html"/>
    <id>http://lincentma.men/haoweilai_interview.html</id>
    <published>2017-08-23T08:52:01.000Z</published>
    <updated>2017-08-23T08:53:25.876Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="好未来面试记录"><a href="#好未来面试记录" class="headerlink" title="好未来面试记录"></a>好未来面试记录</h1><blockquote>
<p>通过提前批筛选之后就是二次现场面试。</p>
<p>相对于机器学习的面试来说，自己的难度确实简单，需要查漏补缺的地方还是很多。</p>
</blockquote>
<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><h3 id="1-如何处理hadoop的数据倾斜问题"><a href="#1-如何处理hadoop的数据倾斜问题" class="headerlink" title="1.如何处理hadoop的数据倾斜问题"></a>1.如何处理hadoop的数据倾斜问题</h3><p>针对问题是，请描述一个自己印象最深刻的项目</p>
<ul>
<li>数据倾斜表现：ruduce阶段卡在99.99%，一直99.99%不能结束。</li>
<li><p>数据分布不均匀，导致大量的数据分配到了一个节点。</p>
</li>
<li><p>解决思路：</p>
<ul>
<li>业务逻辑：我们从业务逻辑的层面上来优化数据倾斜。对于数据同一类型数量巨大，单独来做count，最后和其他数据做整合。这也是面试官想要引导我说出的方案</li>
<li>调参方面，Hadoop和Spark都自带了很多的参数和机制来调节数据倾斜，合理利用它们就能解决大部分问题。<ul>
<li>mapjoin方式</li>
<li>count distinct的操作，先转成group，再count</li>
<li>万能膏药：hive.groupby.skewindata=true</li>
<li>left semi jioin的使用</li>
<li>设置map端输出、中间结果压缩。（不完全是解决数据倾斜的问题，但是减少了IO读写和网络传输，能提高很多效率）</li>
</ul>
</li>
<li>通过randint等函数把倾斜的数据分到不同的reduce上 ,解决数据倾斜问题。这是自己的回答。</li>
</ul>
</li>
<li>参考文章：<ul>
<li><a href="https://segmentfault.com/a/1190000009166436" target="_blank" rel="external">漫谈千亿级数据优化实践：数据倾斜（纯干货）</a></li>
<li>[Hive数据倾斜]<a href="http://www.cnblogs.com/skyl/p/4855099.html(" target="_blank" rel="external">http://www.cnblogs.com/skyl/p/4855099.html(</a>)</li>
</ul>
</li>
</ul>
<h3 id="2-Java多线程线程池的参数意义"><a href="#2-Java多线程线程池的参数意义" class="headerlink" title="2.Java多线程线程池的参数意义"></a>2.Java多线程线程池的参数意义</h3><pre><code>- 线程池解决的两个问题：
- 1）线程池通过减少每次做任务的时候产生的性能消耗来优化执行大量的异步任务的时候的系统性能。
- 2）线程池还提供了限制和管理批量任务被执行的时候消耗的资源、线程的方法。
Executors提供的一些工厂方法来快速创建ThreadPoolExecutor实例:
    1.newCachedThreadPool创建一个可缓存线程池，如果线程池长度超处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
    2.newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
    3.newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
    4.newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
    5.newWorkStealingPool JDK8引入。返回一个ForkJoinPool类型的 executor，它的工作方法与其他常见的execuotr稍有不同。与使用一个固定大小的线程池不同，ForkJoinPools使用一个并行因子数来创建，默认值为主机CPU的可用核心数。
- 线程池构造器参数：
    - corePoolSize：核心池的大小，这个参数与后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；
    - maximumPoolSize：线程池最大线程数，它表示在线程池中最多能创建多少个线程；
    - keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize：即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize；但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；
    - unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性
- 参考文章：
    - [Java线程池（ThreadPool）详解](http://www.cnblogs.com/kuoAT/p/6714762.html)
</code></pre><h3 id="3-如何设置Java多线程个数最合理"><a href="#3-如何设置Java多线程个数最合理" class="headerlink" title="3.如何设置Java多线程个数最合理"></a>3.如何设置Java多线程个数最合理</h3><pre><code>- 对于计算密集型的任务，在拥有N个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的效率。(即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。)
- 如果是IO密集型应用，则线程池大小设置为2N+1
- 参考文章：
    - [java线程池大小为何会大多被设置成CPU核心数+1？](https://www.zhihu.com/question/38128980)
</code></pre><h3 id="4-用尽可能多的方法去实现判断数组回文"><a href="#4-用尽可能多的方法去实现判断数组回文" class="headerlink" title="4.用尽可能多的方法去实现判断数组回文"></a>4.用尽可能多的方法去实现判断数组回文</h3><pre><code>1. 处理小数字。使用数学方法。取每一位数字然后从后往前计算值，与原来数进行比较是否相等。
2. 处理大数字。使用字符串处理方式。因为回文数关于中心对称，只要比较对称的数即可。
3. 使用栈的思想。入栈一半元素，比较出栈元素与串中字符。

4. 回文判断不能使用正则表达式。正则表达式对应的是有限状态自动机，要达到你所说的需求，至少要图灵机。[正则表达式能否解决所有的字符串的模式匹配问题?](https://www.zhihu.com/question/32327623)


- 参考文章：
    - [回文数的判断(三种方法)](http://blog.csdn.net/deaidai/article/details/71820164)
</code></pre><h3 id="5-reverse函数源码实现"><a href="#5-reverse函数源码实现" class="headerlink" title="5.reverse函数源码实现"></a>5.reverse函数源码实现</h3><pre><code>- StringBuffer和StringBuilder常用到的方法，而String并没有这个牛逼的功能~~
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">    public AbstractStringBuilder reverse() &#123;</div><div class="line">    boolean hasSurrogates = false;</div><div class="line">    int n = count - 1;</div><div class="line">    //j初始化，长度-2再算术右移一位 j = (count-2)/2</div><div class="line">    //偶数长度，遍历一半次数，对调替换</div><div class="line">    //奇数长度，遍历一半-1次数，对调替换，中间值不用替换</div><div class="line">    for (int j = (n-1) &gt;&gt; 1; j &gt;= 0; j--) &#123;</div><div class="line">        int k = n - j;</div><div class="line">        char cj = value[j];</div><div class="line">        char ck = value[k];</div><div class="line">        value[j] = ck;</div><div class="line">        value[k] = cj;</div><div class="line">        if (Character.isSurrogate(cj) ||</div><div class="line">            Character.isSurrogate(ck)) &#123;</div><div class="line">            hasSurrogates = true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (hasSurrogates) &#123;</div><div class="line">        reverseAllValidSurrogatePairs();</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><h3 id="1-如何让接口发生改变时，使得调用方调用无感变化情况"><a href="#1-如何让接口发生改变时，使得调用方调用无感变化情况" class="headerlink" title="1.如何让接口发生改变时，使得调用方调用无感变化情况"></a>1.如何让接口发生改变时，使得调用方调用无感变化情况</h3><pre><code>- 百度了下：采用调用中间代理方法
- 设计模式：Adpater。接口调用者不变。协议改变时由Adapter做转换。
</code></pre><h3 id="1-session和cookie"><a href="#1-session和cookie" class="headerlink" title="1.session和cookie"></a>1.session和cookie</h3><pre><code>- Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
- Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;好未来面试记录&quot;&gt;&lt;a href=&quot;#好未来面试记录&quot; class=&quot;headerlink&quot; title=&quot;好未来面试记录&quot;&gt;&lt;/a&gt;好未来面试记录&lt;/h1&gt;&lt;bl
    
    </summary>
    
      <category term="面试记录" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>百度运维部交流会学习笔记</title>
    <link href="http://lincentma.men/baiduOPCoumminate.html"/>
    <id>http://lincentma.men/baiduOPCoumminate.html</id>
    <published>2017-08-20T14:15:47.000Z</published>
    <updated>2017-08-20T14:17:07.727Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="百度运维部交流会学习笔记"><a href="#百度运维部交流会学习笔记" class="headerlink" title="百度运维部交流会学习笔记"></a>百度运维部交流会学习笔记</h1><h2 id="地点：电子科技大学"><a href="#地点：电子科技大学" class="headerlink" title="地点：电子科技大学"></a>地点：电子科技大学</h2><h2 id="时间：2017-08-20"><a href="#时间：2017-08-20" class="headerlink" title="时间：2017.08.20"></a>时间：2017.08.20</h2><blockquote>
<p>最大的感受：随着AI的不断发展，自己未来工作中会遇到越来越多AI场景，要去拥抱这样的变化。<br>自己希望工作之后也可以回到母校为学弟学妹们带来这样一场业界前沿、职场相关的交流会。</p>
</blockquote>
<h3 id="1-AIOps"><a href="#1-AIOps" class="headerlink" title="1. AIOps"></a>1. AIOps</h3><ul>
<li>AIOps 定义：按照 Gartner 的定义，AIOps 是 Algorithmic IT Operations，但是在人工智能时代，可能很多的人会把 AI 理解成 Artificial Intelligence，不去纠结定义，我觉得本质上，想要表达的意思是一样的，就是让运维具备机器学习和算法的能力。</li>
<li>特征：<ul>
<li>高质量</li>
<li>可靠用户访问体验</li>
<li>低成本</li>
<li>高效率</li>
</ul>
</li>
<li>发展过程：最开始的人工填单、到Web自动化。由于计算成本的下降，导致机器的数量快速增长，这就加剧了运维成本上升，智能运维代替人工，降低成本就应运而生。</li>
<li>讲解单机房故障的止损以及排查方案<ul>
<li>BGW与BFE之间的故障</li>
<li>后端服务故障</li>
</ul>
</li>
</ul>
<p><img src="http://img.mp.itc.cn/upload/20170730/d648c25952fe417fbd1678e206ed4dcf_th.jpg" alt=""></p>
<blockquote>
<p>自己的感受：运维中的海量日志信息蕴含的故障问题原因以及其他相关信息都是可以数据挖掘机器学习去实现。所有的大数据行业都存在这样的过程。<br>关键在与运维知识库：将传统运维基于人的经验，操作行为、规则固化至知识库中。<br>如何将问题的特征提取出来，标签尽可能细化，比如地点标签精确到大学，那么检测到该地点流量下降就可以推测该地点存在故障，此外还有日期特征，等等，如何将尽可能多地相关特征提取出来，匹配最佳的知识库中的运维方案，这也是机器学习的重点吧，自己在这方面的技术知识太少，需要制定学习计划完善自己。</p>
</blockquote>
<h3 id="2-BFE"><a href="#2-BFE" class="headerlink" title="2. BFE"></a>2. BFE</h3><ul>
<li>BFE: 百度统一前端，Baidu Front End</li>
<li>对标Google的GFE</li>
<li>它相对于整个应用是处于最前面直接处理用户的http请求。</li>
<li>采用Go语言编写</li>
<li>基于机器学习的动态优化，识别机器访问与真实访问</li>
<li>全站HTTPS，有效避免网络信息劫持</li>
</ul>
<h3 id="3-职场建议"><a href="#3-职场建议" class="headerlink" title="3. 职场建议"></a>3. 职场建议</h3><ul>
<li>小事做好，自然轮到做大事</li>
<li>自我驱动去完成项目比分配任务去完成更加提升自己</li>
<li>运维是架构的学堂。听完了分享，我是认可这句话。单纯的从业务方面是专注于业务一点，运维是需要掌握上下游所有的流程，从这点来看，运维入门难，最后深度与广度是更优的。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;百度运维部交流会学习笔记&quot;&gt;&lt;a href=&quot;#百度运维部交流会学习笔记&quot; class=&quot;headerlink&quot; title=&quot;百度运维部交流会学习笔记&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://lincentma.men/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="AIOps" scheme="http://lincentma.men/tags/AIOps/"/>
    
      <category term="BFE" scheme="http://lincentma.men/tags/BFE/"/>
    
      <category term="Baidu" scheme="http://lincentma.men/tags/Baidu/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟物流简历评估面试</title>
    <link href="http://lincentma.men/alibaba_interview_0820.html"/>
    <id>http://lincentma.men/alibaba_interview_0820.html</id>
    <published>2017-08-20T12:50:55.000Z</published>
    <updated>2017-08-20T12:52:30.308Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="菜鸟物流简历评估面试记录"><a href="#菜鸟物流简历评估面试记录" class="headerlink" title="菜鸟物流简历评估面试记录"></a>菜鸟物流简历评估面试记录</h1><ul>
<li>刚睡醒的面试一塌糊涂，不打没有准备的仗。总结经验，扎实基础</li>
</ul>
<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h3><p>两方面简单自我介绍：公司实习经历和学校项目。<br>最后总结与申请职位的契合程度以及表明下自己的意愿。<br>PS：感觉并没有什么用。。。</p>
<h3 id="2-你的简历中关于Java的很少，为什么还要选择投递研发工程师Java呢？"><a href="#2-你的简历中关于Java的很少，为什么还要选择投递研发工程师Java呢？" class="headerlink" title="2. 你的简历中关于Java的很少，为什么还要选择投递研发工程师Java呢？"></a>2. 你的简历中关于Java的很少，为什么还要选择投递研发工程师Java呢？</h3><ul>
<li>当自己听到这个问题的时候，自己就懵了，和自己之前复习准备，参考其他菜鸟网络面经有很大的不一样。</li>
<li>每一位面试官都有自己的风格。</li>
<li>自己还是主动把学校项目中的Java部分阐述，以及在公司实习中采用PHP以及Python同时可以表现出自己的自学能力。</li>
<li>但是面试官的反馈是，从你的简历上无法看到Java相关的内容，无法谈论Java技术方面的问题。<br>自己在项目中的SSH框架以及Java与Hadoop的项目经历放在实习经历后面，对于Java的具体实现功能自己之前因为一页简历的限制并没有详细叙述，这是自己的一个缺点。</li>
<li>自己面试完成后总结自己应该向面试官表达自己对于Java研发工程师岗位的浓厚兴趣以及自己在项目实践，博客记录等自己所做的工作。</li>
<li>自己对于压力面试的准备不是很充分，在面对压力以及工作之后的困难应该表现出进取向上的态度吧。</li>
</ul>
<h3 id="3-那么你用过Java、PHP、Python这些不同的编程语言，你认为它们最大的区别在哪里？"><a href="#3-那么你用过Java、PHP、Python这些不同的编程语言，你认为它们最大的区别在哪里？" class="headerlink" title="3. 那么你用过Java、PHP、Python这些不同的编程语言，你认为它们最大的区别在哪里？"></a>3. 那么你用过Java、PHP、Python这些不同的编程语言，你认为它们最大的区别在哪里？</h3><ul>
<li>听到这个问题，我又懵了。自己的横向广度可以，但是纵向深度缺乏。</li>
<li>百度整理答案以及自己实践理解如下：<ul>
<li>Java：Java 编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言。</li>
<li>PHP：Hypertext Preprocessor的缩写，中文名：“PHP：超文本预处理器”）是一种通用开源脚本语言。语法吸收了C语言、Java和Perl的特点，入门门槛较低，易于学习，使用广泛，主要适用于Web开发领域。</li>
<li>Python：是一种面向对象、直译式计算机程序设计语言，Python语法简洁而清晰，具有丰富和强大的类库。它常被昵称为胶水语言，它能够很轻松的把用其他语言制作的各种模块（尤其是C/C++）轻松地联结在一起。</li>
<li>参考文章：<a href="http://blog.csdn.net/zllzb2011/article/details/47169479" target="_blank" rel="external">C、C++、C#、Java、php、python语言的内在特性及区别</a></li>
<li>通过不同语言与MySQL数据库连接过程，发现不同语言之间的特点差异：<a href="http://www.cnblogs.com/bluedy1229/p/3750168.html" target="_blank" rel="external">六种流行的语言—C、C++、python、Java、php、C#比较</a></li>
</ul>
</li>
<li>总结：自己在使用编程语言的时候，会用是基础，为什么这么用，这么用的好处，设计的原则这些都要好好理解。</li>
</ul>
<h3 id="4-Java基础知识"><a href="#4-Java基础知识" class="headerlink" title="4. Java基础知识"></a>4. Java基础知识</h3><ol>
<li><p>Object对象的方法有哪些？记得但是没有答全。重新阅读Java.lang.Object.java文件源码，温故知新。</p>
<ul>
<li>Java中，用native关键字修饰的函数表明该方法的实现并不是在Java中去完成，而是由C/C++去完成，并被编译成了.dll，由Java去调用。<ol>
<li>private static native void registerNatives();<br>//返回此Object运行时类型</li>
<li>public final native Class&lt;?&gt; getClass();<br>//返回对象的哈希值</li>
<li>public native int hashCode();<br>//判断其他对象是否与此对象”相等”</li>
<li>public boolean equals(Object obj);<br>//创建并返回此对象的一个副本</li>
<li>protected native Object clone() throws CloneNotSupportedException;<br>//返回此对象的字符串表示</li>
<li>public String toString();<br>//唤醒在此对象监视器上等待的单个线程</li>
<li>public final native void notify();<br>//唤醒在此对象监视器等待的所有线程</li>
<li>public final native void notifyAll();<br>//在其他线程调用此对象的notify()方法或notifyAll()方法前，或者超过指定的时间量前，让当前线程等待</li>
<li>public final void wait() throws InterruptedException;</li>
<li>public final native void wait(long timeout) throws InterruptedException;</li>
<li>public final void wait(long timeout, int nanos) throws InterruptedException<br>//当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法</li>
<li>protected void finalize() throws Throwable;</li>
</ol>
</li>
<li>参考文章：<a href="http://blog.csdn.net/uxiaolang/article/details/46632973" target="_blank" rel="external">Java源码解读：顶级父类Object</a></li>
</ul>
</li>
<li><p>hashCode()方法重写与equals()方法的关系。这个答上来了。</p>
<ul>
<li>equals方法和hashCode方法的关系</li>
<li>如果重写了equals方法，则必须重写hashCode防止两个等价的对象的hashCode值不同，这在集合中将造成严重后果。</li>
<li>如果equals成立，则hashCode必须相同，如果hashCode不同，则equals则一定不成立。</li>
<li>如果两个对象各自调用hashCode方法产生的不同结果，对这两个对象进行equals方法的比较一定要返回false。</li>
<li>如果根据equals方法比较。两个对象时等价的，那么在两个对象中各自调用hashCode方法必须产生相同的整数结果。</li>
<li>如果根据equals方法比较，两个对象不等价，那么在两个对象中各自调用hashCode方法不一定会产生不同的整数结果。</li>
</ul>
</li>
<li><p>final，finally，finalize区别。这个答上来了。现在回想自己回答的不够简练。</p>
<ul>
<li>final: 常量声明。 finally: 处理异常。 finalize: 帮助进行垃圾回收。</li>
<li>接口里声明的变量默认是final的。final类无法继承，也就是没有子类。这么做是出于基础类型的安全考虑，比如String和Integer。这样也使得编译器进行一些优化，更容易保证线程的安全性。final方法无法重写。final变量的值不能改变。finalize()方法在一个对象被销毁和回收前会被调用。finally,通常用于异常处理，不管有没有异常被抛出都会执行到。比如，关闭连接通常放到finally块中完成。</li>
<li>参考文章：<a href="http://www.jianshu.com/p/a801461efb97" target="_blank" rel="external">Java面试题与解答(一)——基础部分</a></li>
</ul>
</li>
<li><p>介绍序列化。并提出当一个对象序列化之后又添加一个字段，当其被反序列化时会发生什么？这个问题后半部分答得不好，说在类加载的验证过程中不通过报错。感觉不对。</p>
<ul>
<li>序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。</li>
<li><strong><em>序列化允许重构：序列化允许一定数量的类变种，甚至重构之后也是如此，ObjectInputStream 仍可以很好地将其读出来。</em></strong></li>
<li>Java Object Serialization 规范可以自动管理的关键任务是：将新字段添加到类中；将字段从 static 改为非 static；将字段从 transient 改为非 transient。</li>
<li>序列化新加字段，前一个类与后一个类必须有有相同的序列化版本 hash（存储为 private static final serialVersionUID 字段）。</li>
<li>一旦有了serialVersionUID，不仅可以从原始对象的序列化数据创建新加字段对象（当出现新字段时，新字段被设为缺省值，最常见的是“null”），还可以反过来做：即从新加字段对象的数据通过反序列化得到原始对象。</li>
<li>序列化文件格式为二进制文件流：<ul>
<li>0xACED:根据协议文档的约定,由于所有二进制流(文件)都需要在流的头部约定魔数(magic number=STREAM_MAGIC),既java object 序列化后的流的魔数约定为ACED;</li>
<li>0x0005:然后是流协议版本是short类型(2字节)并且值为5,则十六进制值为0005;</li>
<li>0x7372:java byte型长度为1字节,所以0x73 0x72直接对应到字节流上,0x73(TC_OBJECT)代表这是一个对象,0x72(TC_CLASSDESC)代表这个之后开始是对类的描述.</li>
<li>0x0003:类名的长度,这个类名是Pet,是三个字符,所以长度是3,对应16进制中就是0x0003.</li>
<li>0x506574:这三个字节转为ASCII码就是类名Pet。</li>
</ul>
</li>
<li>序列化存在安全风险，信任，但要验证。可以实现 ObjectInputValidation接口，并覆盖 validateObject() 方法。如果调用该方法时发现某处有错误，则抛出一个 InvalidObjectException。</li>
<li>参考文章：<ul>
<li><a href="http://www.importnew.com/16151.html" target="_blank" rel="external">关于 Java 对象序列化您不知道的 5 件事</a></li>
<li><a href="https://segmentfault.com/a/1190000003841957" target="_blank" rel="external">Java序列化格式详解</a></li>
</ul>
</li>
</ul>
</li>
<li><p>接下来转为数据结构，问的基础问题。但是越是基础，越容易犯眼高手低的毛病。什么是二叉树？什么是平衡二叉树？</p>
<ul>
<li>自己从数据结构的实现方面阐述被打断。要求用自己的理解来阐述二叉树的结构。</li>
<li>二叉树是每个节点最多有两个子树的树结构。</li>
<li>二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其终端结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。</li>
<li>平衡二叉树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。常用算法有红黑树、AVL、Treap、伸展树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O（log（n）），大大降低了操作的时间复杂度。</li>
<li>自己把平衡二叉树和二叉查找树弄反了，汗颜。</li>
<li>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<ul>
<li>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
</ul>
</li>
<li>参考文章：<a href="https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/10421057?fr=aladdin" target="_blank" rel="external">平衡二叉树</a></li>
</ul>
</li>
<li><p>算法题：给定一个数组A，一个数组B，两个数组元素均是数字，只允许分别循环遍历每个数组1次，求出：</p>
<pre><code>1. A中有B中没有的元素集合；
2. A中没有B中有的元素集合；
3. A中有B中也有的元素集合。
</code></pre><ul>
<li>思路：桶排序（位图）来解决，但是还是要多一次桶的循环。HashMap也是一样的思路。</li>
<li>升级版思路：TreeSet来解决,遍历A构建TreeSet，遍历B通过add返回值来判断，同时再remove该元素。</li>
<li><p>桶排序思路改进：遍历A数组，添加时+1；遍历B数组，添加时+2；对应三种情况值分别为1,2,3。最后遍历输出即可。设置不同的权值来进行区分，重复元素不再重复相加即可。</p>
</li>
<li><p>当数组数据有序和无序两种情况下，算法有哪些不同？</p>
</li>
<li>无序最终也要归结为有序来处理吧。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.alibaba.interview;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ml on 2017/8/20.</div><div class="line"> * 给定一个数组A，一个数组B，两个数组元素均是数字，只允许分别循环遍历每个数组1次，求出：</div><div class="line"> 1. A中有B中没有的元素集合；</div><div class="line"> 2. A中没有B中有的元素集合；</div><div class="line"> 3. A中有B中也有的元素集合。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">findNumber</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] testA = &#123; <span class="number">5</span>, <span class="number">9</span>, -<span class="number">4</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">16</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] testB = &#123; <span class="number">10</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, -<span class="number">3</span> &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] test2A = &#123;&#125;;</div><div class="line">        <span class="keyword">int</span>[] test2B = &#123;&#125;;</div><div class="line">        </div><div class="line">        calSorted(testA, testB);</div><div class="line">        calSorted2(testA, testB);</div><div class="line">        calRandom(test2A,test2B);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//自己当时的思路，桶排序但是只能实现两种</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calSorted</span><span class="params">(<span class="keyword">int</span>[] testA, <span class="keyword">int</span>[] testB)</span> </span>&#123;</div><div class="line">        <span class="comment">//数组有序</span></div><div class="line">        Arrays.sort(testA);</div><div class="line">        Arrays.sort(testB);</div><div class="line">        <span class="comment">//确定最大值和最小值</span></div><div class="line">        <span class="keyword">int</span> len = testA.length &lt;= testB.length ? testB.length : testA.length;</div><div class="line">        <span class="keyword">int</span> min = testA[<span class="number">0</span>] &lt;= testB[<span class="number">0</span>] ? testA[<span class="number">0</span>] : testB[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> max = testA[testA.length - <span class="number">1</span>] &lt;= testB[testB.length - <span class="number">1</span>] ? testB[testB.length - <span class="number">1</span>] : testA[testA.length - <span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span>[] tong = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testA.length;i++) &#123;</div><div class="line">            tong[testA[i] - min]++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//A中有B中没有的元素集合</span></div><div class="line">        List&lt;Integer&gt; A1B0 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">//A中没有B中有的元素集合</span></div><div class="line">        List&lt;Integer&gt; A0B1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">//A中有B中也有的元素集合</span></div><div class="line">        List&lt;Integer&gt; A1B1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testB.length;i++) &#123;</div><div class="line">            <span class="comment">//A中没有B中有的元素</span></div><div class="line">            <span class="keyword">if</span>(tong[testB[i] - min] == <span class="number">0</span>) &#123;</div><div class="line">                A0B1.add(testB[i]);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//A中有B中也有的元素</span></div><div class="line">            <span class="keyword">if</span>(tong[testB[i] - min] &gt; <span class="number">0</span>) &#123;</div><div class="line">                A1B1.add(testB[i]);</div><div class="line">                tong[testB[i] - min]--;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//A中有B中没有的元素无法搞定</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//必须要添加一层循环</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tong.length;i++) &#123;</div><div class="line">            <span class="keyword">if</span>(tong[i] &gt; <span class="number">0</span>) &#123;</div><div class="line">                A1B0.add(i + min);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"A中没有B中有的元素:"</span>);</div><div class="line">        printList(A0B1);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"A中有B中没有的元素:"</span>);</div><div class="line">        printList(A1B0);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"A中有B中也有的元素:"</span>);</div><div class="line">        printList(A1B1);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//改进版</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calSorted2</span><span class="params">(<span class="keyword">int</span>[] testA, <span class="keyword">int</span>[] testB)</span> </span>&#123;</div><div class="line">        TreeSet&lt;Integer&gt; treeA = <span class="keyword">new</span> TreeSet&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testA.length; i++) &#123;</div><div class="line">            treeA.add(testA[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//A中有B中没有的元素集合</span></div><div class="line">        List&lt;Integer&gt; A1B0 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">//A中没有B中有的元素集合</span></div><div class="line">        List&lt;Integer&gt; A0B1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">//A中有B中也有的元素集合</span></div><div class="line">        List&lt;Integer&gt; A1B1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; testB.length; j++) &#123;</div><div class="line">            <span class="comment">//A中没有B中有的元素</span></div><div class="line">            <span class="keyword">if</span>(treeA.add(testB[j])) &#123;</div><div class="line">                A0B1.add(testB[j]);</div><div class="line">                treeA.remove(testB[j]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                A1B1.add(testB[j]);</div><div class="line">                treeA.remove(testB[j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"A中没有B中有的元素:"</span>);</div><div class="line">        printList(A0B1);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"A中有B中没有的元素:"</span>);</div><div class="line">        printSet(treeA);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"A中有B中也有的元素:"</span>);</div><div class="line">        printList(A1B1);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calRandom</span><span class="params">(<span class="keyword">int</span>[] test2A, <span class="keyword">int</span>[] test2B)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</div><div class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.print(arr[arr.length - <span class="number">1</span>]);</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</div><div class="line">            System.out.print(list.get(i) + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.print(list.get(list.size() - <span class="number">1</span>));</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSet</span><span class="params">(TreeSet&lt;Integer&gt; tree)</span> </span>&#123;</div><div class="line">        Iterator&lt;Integer&gt; it=tree.iterator();</div><div class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">            i++;</div><div class="line">            <span class="keyword">if</span>(i&lt;tree.size())&#123;</div><div class="line">                System.out.print(it.next()+<span class="string">" "</span>);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                System.out.print(it.next());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>验证结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">A中没有B中有的元素:</div><div class="line">-3 4 8</div><div class="line">A中有B中没有的元素:</div><div class="line">-4 9 16 21</div><div class="line">A中有B中也有的元素:</div><div class="line">5 10</div><div class="line">A中没有B中有的元素:</div><div class="line">-3 4 8</div><div class="line">A中有B中没有的元素:</div><div class="line">-4 9 16 21</div><div class="line">A中有B中也有的元素:</div><div class="line">5 10</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;菜鸟物流简历评估面试记录&quot;&gt;&lt;a href=&quot;#菜鸟物流简历评估面试记录&quot; class=&quot;headerlink&quot; title=&quot;菜鸟物流简历评估面试记录&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="alibaba" scheme="http://lincentma.men/categories/alibaba/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>学习《阿里巴巴Java开发手册》</title>
    <link href="http://lincentma.men/learn_alibaba_java.html"/>
    <id>http://lincentma.men/learn_alibaba_java.html</id>
    <published>2017-07-23T08:24:02.000Z</published>
    <updated>2017-07-26T11:03:57.412Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote>
<p>经验，是提高自己的重要途径之一。</p>
</blockquote>
<h1 id="学习笔记："><a href="#学习笔记：" class="headerlink" title="学习笔记："></a>学习笔记：</h1><h2 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h2><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><ol>
<li>“骆驼拼写法”分为两种。第一个词的首字母小写，后面每个词的首字母大写，叫做“小骆驼拼写法”（lowerCamelCase）；第一个词的首字母，以及后面每个词的首字母都大写，叫做“大骆驼拼写法”（UpperCamelCase），又称“帕斯卡拼写法”。类名大骆驼，方法名、参数名、成员变量、局部变量都是小骆驼。</li>
<li>POJO类（只有getter和setter方法的简单类）：布尔类型变量不要加is，否则会引起部分框架解析引起序列化错误。</li>
<li>接口类的方法和属性不要加任何修饰符号，包括public。JDK8允许接口有默认实现，default方法。</li>
<li>基于SOA理念，暴露出来的一定是接口，内部实现类加Impl后缀。</li>
</ol>
<h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3><ol>
<li><p>常量的复用层次：<br> 跨应用共享常量<br> 应用内共享常量<br> 子工程内共享常量<br> 包内共享常量<br> 类内共享常量： private static final</p>
</li>
<li><p>变量值在范围内变化，设置为枚举类。成员名称全部大写。</p>
</li>
</ol>
<h3 id="OOP规约"><a href="#OOP规约" class="headerlink" title="OOP规约"></a>OOP规约</h3><ol>
<li><p>直接通过类名访问类的静态变量和静态方法，而不是通过类的对象，增加编译器的解析成本。</p>
</li>
<li><p>所有覆写方法都必须加上@override注解。</p>
</li>
<li><p>所有相同类型的包装对象之间的值的比较，通过equals方法。</p>
<p> 原因：Integer在128  127 分为内的复制，Integer对象是在IntegerCache.cache产生，会复用已有的对象，区间之外的所有数据都在堆上产生，并不会复用已有对象。<br> == 不仅比较值的大小，还比较对象的地址。</p>
</li>
<li><p>POJO类属性必须使用包装类型，返回值和参数也必须使用包装数据类型。预防NPE现象。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody>
</table>
<ol>
<li><p>使用索引访问String的split方法，需要对最后一个分隔符后面有无内容进行检查，否则会报IndexOutOfBoundsException。</p>
<p>public String[] split(String regex,int limit)方法：split(String regex) 方法，其实也就等同于split(String regex，0)方法，把结尾的空字符串丢弃！ </p>
<p>可以使用split(“分隔符”,1)或者是org.apache.commons.lang.StringUtils提供的split</p>
<p>参考文章：<a href="http://yinny.iteye.com/blog/1750210" target="_blank" rel="external">java 字符串split有很多坑，使用时请小心！！</a></p>
</li>
<li><p>循环体内字符串的链接方式：</p>
<p> 用String和“+”：因为“+”拼接字符串，每拼接一次都是再内存重新开辟一个新的内存区域（堆里边）,然后把得到的新的字符串存在这块内存，很容易引起内存溢出。<br> 使用StringBuilder的append方法进行扩展。是在已有的内存空间追加的字符串。<br> commonlang工具包的StringUtils.join(list,”,”);来一步实现这个拼接而且还能指定分隔的符号。</p>
</li>
<li><p>对象的clone方法默认是前拷贝，实现深拷贝需要重写clone方法。</p>
<p> 基本数据类型的拷贝是没有意义的，String类型这样的引用的拷贝才是有意义的。<br> 需要注意的是，如果在拷贝一个对象时，要想让这个拷贝的对象和源对象完全彼此独立，那么在引用链上的每一级对象都要被显式的拷贝。所以创建彻底的深拷贝是非常麻烦的，尤其是在引用关系非常复杂的情况下， 或者在引用链的某一级上引用了一个第三方的对象， 而这个对象没有实现clone方法， 那么在它之后的所有引用的对象都是被共享的。<br> 参考文章：<a href="http://www.importnew.com/16094.html" target="_blank" rel="external">详解Java中的clone方法 — 原型模式</a></p>
</li>
</ol>
<h3 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h3><ol>
<li><p>只要重写equals方法，就必须重写hashCode。</p>
<p> 为了保证同一个对象，保证在equals相同的情况下hashcode值必定相同，如果重写了equals而未重写hashcode方法，可能就会出现两个没有关系的对象equals相同的（因为equal都是根据对象的特征进行重写的），但hashcode确实不相同的。<br> Set存放不重复队形，先比较hashCode，再用equals比较，提高效率。<br> String两个方法都重写了，放心使用。<br> 参考文章：<a href="http://www.cnblogs.com/expiator/p/6064974.html" target="_blank" rel="external">为什么重写equals时必须重写hashCode方法？</a></p>
</li>
<li><p>ArrayList之subList：</p>
<p> Java.util.List中有一个subList方法，用来返回一个list的一部分的视图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;</div></pre></td></tr></table></figure>
<p> 它返回原来list的从[fromIndex, toIndex)之间这一部分的List(下面称之为sublist)，但是这个sublist是依赖于原来的List集合。</p>
<p> 在subList中进行了结构性修改（list大小修改），原来的list的大小也会发生变化，抛出一个ConcurrentModificationException。</p>
</li>
<li><p>集合转为数组的方法，必须使用集合的toArray(T[] array)，类型与大小完全一致。</p>
<p> 不带参数的toArray方法，是构造的一个Object数组，然后进行数据拷贝，此时进行转型就会产生ClassCastException。</p>
</li>
<li><p>Arrays.asList()数组转为集合方法，不能使用挂起修改集合相关的方法，如add、remove、clear等，会抛出UnsupportedOperationException异常。</p>
<p>  设计模式：适配器模式。只是转换接口，后台的数据仍是数组。</p>
<p>   Arrays.asList方法返回的ArrayList是继承自AbstractList同时实现了RandomAccess和Serializable接口，AbstractList定义add等方法抛出异常。</p>
<p>   解决方法：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1</span></div><div class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</div><div class="line"><span class="comment">//2</span></div><div class="line"><span class="keyword">int</span> i[]=&#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;;  </div><div class="line">Arrays.asList(ArrayUtils.toObject(i));</div></pre></td></tr></table></figure>
</code></pre></li>
<li><p>Java泛型通配符PECS原则：</p>
<p> 如果要从集合中读取类型T的数据，并且不能写入，可以使用 ? extends 通配符；(Producer Extends)</p>
<p> 如果要从集合中写入类型T的数据，并且不需要读取，可以使用 ? super 通配符；(Consumer Super)</p>
<p> 如果既要存又要取，那么就不要使用任何通配符。</p>
</li>
<li><p>不要在foreach循环中进行元素的remove/add操作。如果要remove，需在Iterator中。如果并发，需给Iterator加锁。</p>
<p> List类会在内部维护一个modCount的变量，用来记录修改次数。</p>
<p> 每生成一个Iterator，Iterator就会记录该modCount，每次调用next()方法就会将该记录与外部类List的modCount进行对比，发现不相等就会抛出多线程编辑异常。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//foreach和迭代器的hasNext()方法，foreach这个语法糖，实际上就是</span></div><div class="line"><span class="keyword">while</span>(itr.hasNext())&#123;</div><div class="line">    itr.next()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> cursor != size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> cursor是用于标记迭代器位置的变量，该变量由0开始，每次调用next执行+1操作。</p>
<blockquote>
<p>你的代码在执行删除“1”后，size=1，cursor=1，此时hasNext()返回false，结束循环，因此你的迭代器并没有调用next查找第二个元素，也就无从检测modCount了，因此也不会出现多线程修改异常<br>但当你删除“2”时，迭代器调用了两次next，此时size=1，cursor=2，hasNext()返回true，于是迭代器傻乎乎的就又去调用了一次next()，因此也引发了modCount不相等，抛出多线程修改的异常。</p>
<p>当你的集合有三个元素的时候，你就会神奇的发现，删除“1”是会抛出异常的，但删除“2”就没有问题了，究其原因，和上面的程序执行顺序是一致的。</p>
</blockquote>
<p> 参考文章：<a href="https://segmentfault.com/q/1010000008858681" target="_blank" rel="external">为什么java不要在foreach循环里进行元素的remove/add操作</a></p>
</li>
<li><p>在 JDK 7 版本以上， Comparator 要满足自反性，传递性，对称性，不然 Arrays.sort ，Collections.sort 会报 IllegalArgumentException 异常。</p>
<p>  保证等于和大小与分开，要严格有序。</p>
<p>  Comparable 是排序接口。若一个类实现了Comparable接口，就意味着“<strong>该类支持排序</strong>”。</p>
<p>   Comparable 接口仅仅只包括一个函数：</p>
<p>  Comparator 是比较器接口。我们若需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)，可以通过“<strong>实现Comparator类来新建一个比较器</strong>”，然后通过该比较器对类进行排序。</p>
<p>  Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.lang;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>集合初始化，指定集合的初始值大小。</p>
<p> Collection的初始容量也显得异常重要。所以：对于已知的情景，请为集合指定初始容量。</p>
<p>  HashMap初始化容量计算 = （需要存储元素的个数 / 负载因子） + 1</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// ArrayList新容量扩大到原容量的1.5倍，右移一位相关于原数值除以2。</div><div class="line">int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</div><div class="line">//Vector线程安全，速度慢。默认初始容量为10，加载因子为1：即当 元素个数 超过 容量长度 时，进行扩容扩容增量：原容量的1倍</div><div class="line">int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity);</div><div class="line">//HashMap</div><div class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</div><div class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</div><div class="line">if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1;</div><div class="line">//HashTable</div><div class="line">int newCapacity = oldCapacity * 2 + 1;</div><div class="line">//StringBuilder</div><div class="line">void expandCapacity(int minimumCapacity) &#123;  </div><div class="line">        int newCapacity = value.length * 2 + 2;  </div><div class="line">        if (newCapacity  minimumCapacity &lt; 0)  </div><div class="line">            newCapacity = minimumCapacity;  </div><div class="line">        if (newCapacity &lt; 0) &#123;  </div><div class="line">            if (minimumCapacity &lt; 0) // overflow  </div><div class="line">                throw new OutOfMemoryError();  </div><div class="line">            newCapacity = Integer.MAX_VALUE;  </div><div class="line">        &#125;  </div><div class="line">        value = Arrays.copyOf(value, newCapacity);  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<table>
<thead>
<tr>
<th>集合名称</th>
<th>默认容量</th>
<th>加载因子</th>
<th>扩容容量(扩大到原来的)</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>10</td>
<td>1</td>
<td>1.5</td>
</tr>
<tr>
<td>Vector</td>
<td>10</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>HashSet</td>
<td>16</td>
<td>0.75</td>
<td>2</td>
</tr>
<tr>
<td>HashMap</td>
<td>16</td>
<td>0.75</td>
<td>2</td>
</tr>
<tr>
<td>HashTable</td>
<td>11</td>
<td>0.75</td>
<td>*2 +1</td>
</tr>
<tr>
<td>StringBuilder（StringBuffer）</td>
<td>16</td>
<td>条件判断</td>
<td>*2+2</td>
</tr>
</tbody>
</table>
<ol>
<li><p>遍历Map类，使用entrySet。</p>
<p>同时遍历key和value时，keySet与entrySet方法的性能差异取决于key的具体情况，如复杂度（复杂对象）、离散度、冲突率等。换言之，取决于HashMap查找value的开销。entrySet一次性取出所有key和value的操作是有性能开销的，当这个损失小于HashMap查找value的开销时，entrySet的性能优势就会体现出来。</p>
<p>同时遍历key和value时，与HashMap不同，entrySet的性能远远高于keySet。这是由TreeMap的查询效率决定的，也就是说，TreeMap查找value的开销较大，明显高于entrySet一次性取出所有key和value的开销。因此，遍历TreeMap时强烈推荐使用entrySet方法。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//keySet遍历2次，一次转为Iterator对象，一次从HashMap中取出对应的value</span></div><div class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</div><div class="line">    value = map.get(key);</div><div class="line">&#125;</div><div class="line"><span class="comment">//entrySet</span></div><div class="line"><span class="keyword">for</span> (Entry&lt;String, String&gt; entry: map.entrySet()) &#123;</div><div class="line">    key = entry.getKey();</div><div class="line">    value = entry.getValue();</div><div class="line">&#125;</div><div class="line"><span class="comment">//for循环</span></div><div class="line"><span class="keyword">for</span> (String value : map.values()) &#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">//JDK8 增强for循环</span></div><div class="line">Map&lt;String, Integer&gt; items = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">items.forEach((k,v)&gt;System.out.println(<span class="string">"key : "</span> + k + <span class="string">"; value : "</span> + v));</div></pre></td></tr></table></figure>
<p> 参考文章：<a href="http://www.cnblogs.com/fczjuever/archive/2013/04/07/3005997.html" target="_blank" rel="external">Java Map遍历方式的选择</a></p>
<ol>
<li>Map类集合K/V为null需要注意的地方：</li>
</ol>
<table>
<thead>
<tr>
<th>集合类</th>
<th>Key</th>
<th>Value</th>
<th>Super</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hashtable</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>Dictionary</td>
<td>线程安全</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>AbstractMap</td>
<td>分段所锁技术</td>
</tr>
<tr>
<td>TreeMap</td>
<td>不允许为 null</td>
<td>允许为 null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
<tr>
<td>HashMap</td>
<td>允许为 null</td>
<td>允许为 null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
</tbody>
</table>
<pre><code>由于 HashMap的干扰，很多人认为 ConcurrentHashMap是可以置入 null值，注意存储null值时会抛出 NPE异常。
</code></pre><ol>
<li><p>集合的有序性和稳定性：<br>ArrayList是order/unsort，HashMap是unorder/unsort，TreeSet是order/sort</p>
</li>
<li><p>利用Set唯一性去重，避免使用List的contains方法遍历去重。<br>Collection的contains()和remove()操作都是线性时间复杂度，用set也会隐式的调用contains()方法，不过你用的是HashSet,这个contains()应该只会用常数时间，所以如果考虑平均时间复杂度，用set可能会占优；最坏情况下，两者可能差不多 。</p>
</li>
</ol>
<h3 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h3><ol>
<li><p>获取单例对象，保证线程安全，以及方法的线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//立即加载（饿汉模式），在调用getInstance()方法前，实例就被创建了，getInstance()方法没有同步，所以可能出现非线程安全问题。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> INSTANCE;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//延迟加载（懒汉模式），延迟加载就是在getInstance()方法中创建实例。在多线程的环境中，延迟加载中使用同步代码块，对类加锁。虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//DCL双检查锁机制。 DCL双检查锁机制即使用volatile关键字（使变量在多个线程中可见）修改对象和synchronized代码块</span></div><div class="line"><span class="comment">//两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</span></div><div class="line"><span class="comment">//instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</span></div><div class="line"><span class="comment">//给 instance 分配内存</span></div><div class="line"><span class="comment">//调用 Singleton 的构造函数来初始化成员变量</span></div><div class="line"><span class="comment">//将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</span></div><div class="line"><span class="comment">//JVM 的即时编译器中存在指令重排序的优化，只需要将 instance 变量声明成 volatile 来避免指令重排序。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</div><div class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</div><div class="line">                    singleton = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;    </div><div class="line">&#125;</div><div class="line"><span class="comment">//【推荐】静态内部类</span></div><div class="line"><span class="comment">//使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</span></div><div class="line"><span class="comment">//但是如果对象是序列化的就无法达到效果了。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line"><span class="comment">//枚举</span></div><div class="line"><span class="comment">//枚举的缺点是它无法从另一个基类继承，因为它已经继承自java.lang.Enum。</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FooEnumSingleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FooEnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTANCE; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>线程资源通过线城池提供，通过ThreadPoolExecutor方式创建。</p>
<p> ThreadPoolExecutor作为java.util.concurrent包对外提供基础实现，以内部线程池的形式对外提供管理任务执行，线程调度，线程池管理等等服务</p>
<p> Executors方法提供的线程服务，都是通过参数设置来实现不同的线程池机制。</p>
<p> 关系：Executors可以认为是封装好的线城池服务，ThreadPoolExecutor更加明确线程池的运行机制。</p>
<p> <code>Executors.newCachedThreadPool();        ``//创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE，允许创建线程为Integer.MAX_VALUE,容易OOM</code></p>
<p>  <code>Executors.newSingleThreadExecutor();   ``//创建容量为1的缓冲池，请求队列为长度为Integer.MAX_VALUE,容易OOM</code>，</p>
<p>  <code>Executors.newFixedThreadPool(``int``);    ``//创建固定容量大小的缓冲池请，求队列为长度为Integer.MAX_VALUE,容易OOM</code></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,  </span></span></div><div class="line">                              <span class="keyword">int</span> maximumPoolSize,  </div><div class="line">                              <span class="keyword">long</span> keepAliveTime,  </div><div class="line">                              TimeUnit unit,  </div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,  </div><div class="line">                              ThreadFactory threadFactory,  </div><div class="line">                              RejectedExecutionHandler handler) &#123;  </div><div class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||  </div><div class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||  </div><div class="line">            maximumPoolSize &lt; corePoolSize ||  </div><div class="line">            keepAliveTime &lt; <span class="number">0</span>)  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();  </div><div class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </div><div class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;  </div><div class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;  </div><div class="line">        <span class="keyword">this</span>.workQueue = workQueue;  </div><div class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);  </div><div class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;  </div><div class="line">        <span class="keyword">this</span>.handler = handler;  </div><div class="line">    &#125;  </div><div class="line"><span class="comment">/*</span></div><div class="line">corePoolSize 核心线程池大小</div><div class="line">maximumPoolSize 线程池最大容量大小</div><div class="line">keepAliveTime 线程池空闲时，线程存活的时间</div><div class="line">TimeUnit 时间单位</div><div class="line">ThreadFactory 线程工厂</div><div class="line">BlockingQueue任务队列</div><div class="line">RejectedExecutionHandler 线程拒绝策略</div><div class="line">*/</div></pre></td></tr></table></figure>
<p> <img src="http://dl2.iteye.com/upload/attachment/0105/9641/92ad44092ab4388b9fb19fc4e0d832cd.jpg" alt=""></p>
</li>
</ol>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </div><div class="line">         ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS,</div><div class="line">                 <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</div><div class="line"> </div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)&#123;</div><div class="line">             MyTask myTask = <span class="keyword">new</span> MyTask(i);</div><div class="line">             executor.execute(myTask);</div><div class="line">             System.out.println(<span class="string">"线程池中线程数目："</span>+executor.getPoolSize()+<span class="string">"，队列中等待执行的任务数目："</span>+</div><div class="line">             executor.getQueue().size()+<span class="string">"，已执行玩别的任务数目："</span>+executor.getCompletedTaskCount());</div><div class="line">         &#125;</div><div class="line">         executor.shutdown();</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskNum;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.taskNum = num;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"正在执行task "</span>+taskNum);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.currentThread().sleep(<span class="number">4000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"task "</span>+taskNum+<span class="string">"执行完毕"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

参考文章：[深入理解Java之线程池](http://www.importnew.com/19011.html)
</code></pre><ol>
<li><p>SimpleDateFormat类线程不安全</p>
<p> 线程不安全原因：<br> SimpleDateFormat(下面简称sdf)类内部有一个Calendar对象引用,它用来储存和这个sdf相关的日期信息,例如sdf.parse(dateStr), sdf.format(date) 。<br> calendar这个共享变量的访问没有做到线程安全<br> <img src="http://static.oschina.net/uploads/space/2013/0813/033057_iid0_568818.jpg" alt=""></p>
</li>
</ol>
<pre><code>解决方法：

将SimpleDateFormat定义成局部变量：

加一把线程同步锁：synchronized(lock)；

【推荐】使用ThreadLocal: 每个线程都将拥有自己的SimpleDateFormat对象副本。

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.text.ParseException;</div><div class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtil</span> </span>&#123;</div><div class="line">  <span class="comment">/** 锁对象 */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lockObj = <span class="keyword">new</span> Object();</div><div class="line">  <span class="comment">/** 存放不同的日期模板格式的sdf的Map */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ThreadLocal&lt;SimpleDateFormat&gt;&gt; sdfMap = <span class="keyword">new</span> HashMap&lt;String, ThreadLocal&lt;SimpleDateFormat&gt;&gt;();</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 返回一个ThreadLocal的sdf,每个线程只会new一次sdf</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> pattern</div><div class="line">   * <span class="doctag">@return</span></div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat <span class="title">getSdf</span><span class="params">(<span class="keyword">final</span> String pattern)</span> </span>&#123;</div><div class="line">    ThreadLocal&lt;SimpleDateFormat&gt; tl = sdfMap.get(pattern);</div><div class="line">    <span class="comment">// 此处的双重判断和同步是为了防止sdfMap这个单例被多次put重复的sdf</span></div><div class="line">    <span class="keyword">if</span> (tl == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">synchronized</span> (lockObj) &#123;</div><div class="line">        tl = sdfMap.get(pattern);</div><div class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="comment">// 只有Map中还没有这个pattern的sdf才会生成新的sdf并放入map</span></div><div class="line">          System.out.println(<span class="string">"put new sdf of pattern "</span> + pattern + <span class="string">" to map"</span>);</div><div class="line">          <span class="comment">// 这里是关键,使用ThreadLocal&lt;SimpleDateFormat&gt;替代原来直接new SimpleDateFormat</span></div><div class="line">          tl = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">              System.out.println(<span class="string">"thread: "</span> + Thread.currentThread() + <span class="string">" init pattern: "</span> + pattern);</div><div class="line">              <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(pattern);</div><div class="line">            &#125;</div><div class="line">          &#125;;</div><div class="line">          sdfMap.put(pattern, tl);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tl.get();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 是用ThreadLocal&lt;SimpleDateFormat&gt;来获取SimpleDateFormat,这样每个线程只会有一个SimpleDateFormat</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> date</div><div class="line">   * <span class="doctag">@param</span> pattern</div><div class="line">   * <span class="doctag">@return</span></div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(Date date, String pattern)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> getSdf(pattern).format(date);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(String dateStr, String pattern)</span> <span class="keyword">throws</span> ParseException </span>&#123;</div><div class="line">    <span class="keyword">return</span> getSdf(pattern).parse(dateStr);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><ol>
<li><p>高并发的同步调用考虑锁的性能消耗，锁的粒度尽可能小。</p>
<p> 在获得锁之前做完所有需要做的事，只把锁用在需要同步的资源上，用完之后立即释放它。减少锁持有时间。<br> 减小锁粒度：ConcurrentHashMap。<br> 锁粗化：如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。<br> 锁消除：即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。<br> 分别用不同的锁来保护同一个类中多个独立的状态变量，而不是对整个类域只使用一个锁。锁分离。ReadWriteLock。<br> 参考文章：<a href="http://www.jb51.net/article/92453.htm" target="_blank" rel="external">Java 高并发九：锁的优化和注意事项详解</a></p>
</li>
<li><p>对多个资源、库表、对象加锁，需要保持一致的加锁顺序。</p>
<p> 当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。<br> 此外还有加锁时限、死锁检测等方法预防死锁。</p>
</li>
<li><p>并发修改同一记录必须加锁。</p>
<p> 乐观锁，大多是基于数据版本(Version)记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于<a href="http://www.knowsky.com/sql.asp" target="_blank" rel="external">数据库</a>表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。<br> 提交版本必须大于记录当前版本才能执行更新。<br> 悲观锁（Pessimistic Lock），正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他<a href="http://baike.baidu.com/view/121511.htm" target="_blank" rel="external">事务</a>，以及来自外部系统的<a href="http://baike.baidu.com/subview/709594/709594.htm" target="_blank" rel="external">事务处理</a>）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的<a href="http://baike.baidu.com/subview/118455/118455.htm" target="_blank" rel="external">排他性</a>，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
</li>
<li><p>多线程并行之Timer</p>
<p> 定时任务用Timer实现有可能出现异常，因为它是基于绝对时间而不是相对时间进行调度的。当环境的系统时间被修改后，原来的定时任务可能就不跑了。另外需要注意一点，捕获并处理定时任务的异常。如果在TimerTask里抛出了异常，那么Timer认为定时任务被取消并终止执行线程。</p>
</li>
<li><p>异步转同步操作CountDownLatch</p>
<p> CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。<br> CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。<br> <img src="http://incdn1.b0.upaiyun.com/2015/04/f65cc83b7b4664916fad5d1398a36005.png" alt=""></p>
</li>
</ol>
<pre><code>构造器中的**计数值（count）实际上就是闭锁需要等待的线程数量**。这个值只能被设置一次，而且CountDownLatch**没有提供任何机制去重新设置这个计数值**。这种通知机制是通过 **CountDownLatch.countDown()**方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调 用了这个方法，count的值等于0，然后主线程就能通过await()方法，恢复执行自己的任务。
参考文章：[什么时候使用CountDownLatch](http://www.importnew.com/15731.html)
</code></pre><ol>
<li><p>多线程之Random</p>
<p> 任何情况下都不要在多个线程间共享一个<em>java.util.Random</em>实例，而该把它放入<em>ThreadLocal</em>之中。</p>
<p> Java7在<strong>所有</strong>情形下都更推荐使用<em>java.util.concurrent.ThreadLocalRandom</em>——它向下兼容已有的代码且运营成本更低。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTL_Random</span><span class="params">( <span class="keyword">final</span> <span class="keyword">int</span> threads, <span class="keyword">final</span> <span class="keyword">long</span> cnt )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch( threads );</div><div class="line">    <span class="keyword">final</span> ThreadLocal&lt;Random&gt; rnd = <span class="keyword">new</span> ThreadLocal&lt;Random&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> Random <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Random( <span class="number">100</span> );</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads; ++i )</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread( <span class="keyword">new</span> RandomTask( <span class="keyword">null</span>, i, cnt, latch ) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> Random <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> rnd.get();</div><div class="line">            &#125;</div><div class="line">        &#125; );</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 参考文章：<a href="http://www.importnew.com/12460.html" target="_blank" rel="external">多线程环境下生成随机数</a></p>
</li>
<li><p>volatile</p>
<ol>
<li>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>
<li>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</li>
<li>通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</li>
<li><strong>volatile不能确保原子性</strong></li>
<li>可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过AtomicInteger。</li>
<li>java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</li>
<li>好的一面是它通过一个直接机器码指令设置值时，能够最小程度地影响其他线程的执行。坏的一面是如果它在与其他线程竞争设置值时失败了，它不得不再次尝试。在高竞争下，这将转化为一个自旋锁，线程不得不持续尝试设置值，无限循环直到成功。</li>
<li>JDK8中LongAdder实例，并使用intValue()和add()来获取和设置值。神奇的地方发生在幕后。这个类所做的事情是当一个直接CAS由于竞争失败时，它将delta保存在为该线程分配的一个内部单元对象中，然后当intValue()被调用时，它会将这些临时单元的值再相加到结果和中。这就减少了返回重新CAS或者阻塞其他线程的必要。</li>
<li>参考文章：<br> <a href="http://www.importnew.com/24082.html" target="_blank" rel="external">你真的了解volatile关键字吗？</a><br> <a href="http://www.importnew.com/11345.html" target="_blank" rel="external">Java 8 LongAdders：管理并发计数器的正确方式</a></li>
</ol>
</li>
<li><p>HashMap在resize可能发生死链，加锁解决。</p>
<p> 当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。<br> 首先如果多个线程同时使用put方法添加元素，而且假设正好存在两个put的key发生了碰撞(hash值一样)，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程的put的数据被覆盖。<br> 线程安全：<br>   Hashtable<br>   ConcurrentHashMap(性能优势)<br>   Synchronized Map<br> 参考文章：<a href="http://www.importnew.com/21396.html" target="_blank" rel="external">如何线程安全的使用HashMap</a></p>
</li>
<li><p>ThreadLocal</p>
<p>参考文章：<a href="http://www.cnblogs.com/xzwblog/p/7227509.html" target="_blank" rel="external">彻底理解ThreadLocal</a></p>
</li>
</ol>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><ol>
<li><a href="https://yq.aliyun.com/articles/69327?spm=5176.100241.0.0.3rSWCo#" target="_blank" rel="external">【Java编码规范】《阿里巴巴Java开发手册（正式版）》更新（v1.2.0版）——迄今最完善版本</a></li>
<li><a href="http://www.jianshu.com/p/bc8fed863eca" target="_blank" rel="external">白话阿里巴巴Java开发手册(编程规约)</a></li>
<li><a href="http://www.jianshu.com/p/5b6d180bd1c2" target="_blank" rel="external">白话阿里巴巴Java开发手册（异常日志）</a></li>
<li><a href="http://www.jianshu.com/p/9528c4ea1504" target="_blank" rel="external">白话阿里巴巴Java开发手册（安全规约）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;经验，是提高自己的重要途径之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;学习笔记：&quot;&gt;&lt;a href=&quot;#学习笔记：&quot; class=&quot;
    
    </summary>
    
      <category term="学习笔记" scheme="http://lincentma.men/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://lincentma.men/tags/java/"/>
    
      <category term="alibaba" scheme="http://lincentma.men/tags/alibaba/"/>
    
  </entry>
  
  <entry>
    <title>SSM框架整合理解</title>
    <link href="http://lincentma.men/frame_ssm.html"/>
    <id>http://lincentma.men/frame_ssm.html</id>
    <published>2017-07-17T16:32:21.000Z</published>
    <updated>2017-07-17T16:34:41.340Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="SSM框架整合理解"><a href="#SSM框架整合理解" class="headerlink" title="SSM框架整合理解"></a>SSM框架整合理解</h1><blockquote>
<p>把IntelliJ IDEA+Maven+Spring + SpringMVC + MyBatis项目部署，框架流程梳理调试了一遍，加深自己的理解。</p>
</blockquote>
<h2 id="回顾SSM框架"><a href="#回顾SSM框架" class="headerlink" title="回顾SSM框架"></a>回顾SSM框架</h2><p><strong>Spring</strong><br>Spring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。<br>Spring的核心思想是IoC（控制反转），即不再需要程序员去显式地<code>new</code>一个对象，而是让Spring框架帮你来完成这一切。</p>
<p><strong>SpringMVC</strong><br>SpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。SpringMVC相当于SSH框架中struts。</p>
<p><strong>mybatis</strong><br>mybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。</p>
<h2 id="SSM框架流程"><a href="#SSM框架流程" class="headerlink" title="SSM框架流程"></a>SSM框架流程</h2><p><img src="http://images2015.cnblogs.com/blog/713721/201603/713721-20160302144740705-313885038.png" alt="SpringMVC处理流程"></p>
<h2 id="SSM框架搭建"><a href="#SSM框架搭建" class="headerlink" title="SSM框架搭建"></a>SSM框架搭建</h2><h3 id="创建Maven的Web项目"><a href="#创建Maven的Web项目" class="headerlink" title="创建Maven的Web项目"></a>创建Maven的Web项目</h3><ol>
<li>通过IntelliJ IDEA创建maven项目：<ul>
<li>选中Createfrom archetype，选择maven-archetype-webapp</li>
<li>在Properties中添加一个参数 archetypeCatalog=internal，提高maven项目构建速度</li>
</ul>
</li>
<li>SSH框架Web项目框架<ul>
<li>main：<ul>
<li>创建java文件夹：项目代码</li>
<li>resources文件夹：<ol>
<li>mapping文件夹：数据库表xml</li>
<li>xml配置文件</li>
</ol>
</li>
</ul>
</li>
<li>webapp：<ul>
<li>WEB-INF：<ul>
<li>创建jsp文件夹：不同显示页面</li>
<li>web.xml:配置文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Tomcat启动项目<ul>
<li>为项目配置Tomcat</li>
</ul>
</li>
</ol>
<h3 id="配置各种XML"><a href="#配置各种XML" class="headerlink" title="配置各种XML"></a>配置各种XML</h3><ol>
<li><p>pom.xml——引入项目所需要的jar包</p>
<ul>
<li>spring核心依赖</li>
<li>mybatis依赖</li>
<li>mybatis-spring整合包依赖</li>
<li>mysql驱动依赖</li>
<li>其他依赖：<ul>
<li>日志相关：log4j、slf4j</li>
<li>连接池相关：commons-dbcp、c3p0、Druid</li>
<li>Json相关：fastjson</li>
<li>其他：jstl</li>
</ul>
</li>
<li>PS：此外还有SpringBoot可以简化xml中的配置项数量。SpringBoot完全抛弃了繁琐的XML文件配置方式，而是替代性地用注解方式来实现。 <ul>
<li>参考文章：<a href="http://blog.csdn.net/u013248535/article/details/55100979" target="_blank" rel="external">IDEA下从零开始搭建SpringBoot工程</a></li>
<li>调试过程中的错误有很大一部分是所引的jar没有在pom.xml配置，这部分需要仔细细致。</li>
<li>关于jar包的版本号的修改，可以在<properties></properties>标签中用变量保存版本号，<dependencies></dependencies>中具体的jar包的版本用变量代替，方便后续修改。</li>
</ul>
</li>
</ul>
</li>
<li><p>web.xml</p>
<ul>
<li>这是整个web项目的配置文件。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee</span></div><div class="line">          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</div><div class="line">         <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>cloudmusic_ssm_demo<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mybatis.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>log4jConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:log4j.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- 编码过滤器 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- spring监听器 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- 防止spring内存溢出监听器，比如quartz --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.util.IntrospectorCleanupListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- spring mvc servlet--&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 此处也可以配置成 *.do 形式 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- session配置 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><servlet>中的配置，加载<strong>SpringMVC</strong>的配置文件。<ul>
<li>SpringMVC具有统一的入口DispatcherServlet，所有的请求都通过DispatcherServlet。DispatcherServlet是前置控制器，配置在web.xml文件中的。拦截匹配的请求，Servlet拦截匹配规则要自已定义，把拦截下来的请求，依据某某规则分发到目标Controller来处理。</li>
<li>拦截所有的请求，并加载所有的ssm配置文件（路径为classpath:spring-mvc.xml）</li>
</ul>
</servlet></li>
<li>在web.xml中使用contextConfigLocation参数定义要装入的<strong>Spring</strong>配置文件。<ul>
<li>加载路径为classpath:spring-mybatis.xml文件</li>
</ul>
</li>
<li>参考文章： <a href="http://blog.csdn.net/yijiemamin/article/details/51156189" target="_blank" rel="external">SSM:spring+springmvc+mybatis框架中的XML配置文件功能详细解释</a></li>
</ul>
</li>
<li><p>spring-mvc.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">                        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</div><div class="line">                        http://www.springframework.org/schema/context</div><div class="line">                        http://www.springframework.org/schema/context/spring-context-4.0.xsd</div><div class="line">                        http://www.springframework.org/schema/mvc</div><div class="line">                        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 自动扫描  @Controller--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.ssm.demo.controller"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mappingJacksonHttpMessageConverter"</span></span></div><div class="line">          <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageConverters"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"mappingJacksonHttpMessageConverter"</span>/&gt;</span> <span class="comment">&lt;!-- JSON转换器 --&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 定义跳转的文件的前后缀 ，视图模式配置 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 文件上传配置 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 默认编码 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 上传文件大小限制为31M，31*1024*1024 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"32505856"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 内存中的最大值 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxInMemorySize"</span> <span class="attr">value</span>=<span class="string">"4096"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>controller注入：使用组件扫描方式，扫描包下面所有的Controller，可以使用注解来指定访问路径。</li>
<li>Spring 所有功能都在 Bean 的基础上演化而来，所以必须事先将 Controller 变成 Bean。配置了一个 AnnotationMethodHandlerAdapter，它负责根据 Bean 中的 Spring MVC 注解对 Bean 进行加工处理，使这些 Bean 变成控制器并映射特定的 URL 请求。</li>
<li>视图解析：在Controller中设置视图名的时候会自动加上前缀和后缀。</li>
</ul>
</li>
<li><p>spring-mybatis.xml：Spring与MyBatis的整合配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</div><div class="line">                        http://www.springframework.org/schema/context</div><div class="line">                        http://www.springframework.org/schema/context/spring-context-3.1.xsd</div><div class="line">                        http://www.springframework.org/schema/tx</div><div class="line">                        http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 自动扫描 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.ssm.demo"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 第一种方式：加载一个properties文件 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"propertyConfigurer"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">value</span>=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 第二种方式：加载多个properties文件</span></div><div class="line">    &lt;bean id="configProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt;</div><div class="line">        &lt;property name="locations"&gt;</div><div class="line">            &lt;list&gt;</div><div class="line">                &lt;value&gt;classpath:jdbc.properties&lt;/value&gt;</div><div class="line">                &lt;value&gt;classpath:common.properties&lt;/value&gt;</div><div class="line">            &lt;/list&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="fileEncoding" value="UTF-8"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"&gt;</div><div class="line">        &lt;property name="properties" ref="configProperties"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    --&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></span></div><div class="line">          <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;driverClass&#125;"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbcUrl&#125;"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 初始化连接大小 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;initialSize&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 连接池最大数量 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"$&#123;maxActive&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 连接池最大空闲 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"$&#123;maxIdle&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 连接池最小空闲 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"$&#123;minIdle&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 获取连接最大等待时间 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWait"</span> <span class="attr">value</span>=<span class="string">"$&#123;maxWait&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- mybatis和spring完美整合，不需要mybatis的配置映射文件 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 自动扫描mapping.xml文件 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mapping/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.ssm.demo.dao"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>自动扫描，自动注入，配置数据库<ul>
<li>自动扫描,将标注Spring注解的类自动转化Bean，同时完成Bean的注入</li>
<li>加载数据资源属性文件</li>
<li>配置数据源（三种方式，采用DBCP）</li>
<li>配置sessionfactory</li>
<li>装配Dao接口</li>
<li>声明式事务管理 </li>
<li>注解事务切面 </li>
</ul>
</li>
<li>Mapper.xml映射文件中定义了操作数据库的sql，每一个sql是一个statement，映射文件是myBatis的核心。</li>
</ul>
</li>
<li><p>jdbc.properties：JDBC属性文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">driverClass=com.mysql.jdbc.Driver</div><div class="line">jdbcUrl=jdbc:mysql://localhost:3306/db_ssm?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull</div><div class="line">username=root</div><div class="line">password=147789</div><div class="line"></div><div class="line">#定义初始连接数</div><div class="line">initialSize=0</div><div class="line">#定义最大连接数</div><div class="line">maxActive=20</div><div class="line">#定义最大空闲</div><div class="line">maxIdle=20</div><div class="line">#定义最小空闲</div><div class="line">minIdle=1</div><div class="line">#定义最长等待时间</div><div class="line">maxWait=60000</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="创建业务流程"><a href="#创建业务流程" class="headerlink" title="创建业务流程"></a>创建业务流程</h3><blockquote>
<p>以数据库查询表内容为例</p>
<p>持久层：DAO层（mapper）<strong>做数据持久层的工作</strong>，负责与数据库进行联络的一些任务都封装在此，</p>
<ul>
<li>DAO层的设计首先是设计DAO的接口，</li>
<li>然后在Spring的配置文件中定义此接口的实现类，</li>
<li>然后就可在模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰，</li>
<li>DAO层的数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。</li>
</ul>
<p>业务层：Service层  <strong>主要负责业务模块的逻辑应用设计</strong>。</p>
<ul>
<li>首先设计接口，再设计其实现的类</li>
<li>接着再在Spring的配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。</li>
<li>Service层的业务实现，具体要调用到已定义的DAO层的接口，</li>
<li>封装Service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性，程序显得非常简洁。</li>
</ul>
<p>表现层：Controller层（Handler层）<strong>负责具体的业务模块流程的控制</strong></p>
<ul>
<li>在此层里面要调用Service层的接口来控制业务流程，</li>
<li>控制的配置也同样是在Spring的配置文件里面进行，针对具体的业务流程，会有不同的控制器，我们具体的设计过程中可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块，这样不仅使程序结构变得清晰，也大大减少了代码量。</li>
</ul>
<p>模型层：Model层 <strong>主要存放实体类</strong></p>
</blockquote>
<p>项目代码结构：</p>
<ul>
<li><p>controller：</p>
<ul>
<li>“@RequestMapping”请求路径映射，如果标注在某个controller的类级别上，则表明访问此类路径下的方法都要加上其配置的路径；最常用是标注在方法上，表明哪个具体的方法来接受处理某次请求。</li>
<li>调用service层方法</li>
<li>spring mvc 支持如下的返回方式：ModelAndView, Model, ModelMap, Map,View, String, void。本文返回的是String，通过model进行使用。<ul>
<li>参考文章：<a href="https://my.oschina.net/zhdkn/blog/316530" target="_blank" rel="external">SpringMVC返回（return）方式详解</a></li>
</ul>
</li>
</ul>
</li>
<li><p>service：建立service接口和实现类</p>
<ul>
<li>impl:接口对应实现类：<ul>
<li>调用Dao层的数据库操作以及model层的实体类</li>
</ul>
</li>
</ul>
</li>
<li><p>dao</p>
<ul>
<li>定义接口中的方法</li>
<li><strong>一个Dao对应一个对应的mapper文件，实现Dao对应的定义的接口方法</strong></li>
</ul>
</li>
<li><p>mapping：</p>
<ul>
<li>mapper.xml：实现dao中接口定义的方法</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.ssm.demo.dao.UserDao"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"UserBaseMap"</span> <span class="attr">type</span>=<span class="string">"com.ssm.demo.model.User"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"BIGINT"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_name"</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_phone"</span> <span class="attr">property</span>=<span class="string">"userPhone"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_email"</span> <span class="attr">property</span>=<span class="string">"userEmail"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_pwd"</span> <span class="attr">property</span>=<span class="string">"userPwd"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"pwd_salt"</span> <span class="attr">property</span>=<span class="string">"pwdSalt"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"create_time"</span> <span class="attr">property</span>=<span class="string">"createTime"</span> <span class="attr">jdbcType</span>=<span class="string">"DATE"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"modify_time"</span> <span class="attr">property</span>=<span class="string">"modifyTime"</span> <span class="attr">jdbcType</span>=<span class="string">"DATE"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"is_delete"</span> <span class="attr">property</span>=<span class="string">"isDelete"</span> <span class="attr">jdbcType</span>=<span class="string">"SMALLINT"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUserById"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Long"</span> <span class="attr">resultMap</span>=<span class="string">"UserBaseMap"</span>&gt;</span></div><div class="line">        SELECT * FROM t_user</div><div class="line">        WHERE id = #&#123;userId&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUserByPhoneOrEmail"</span> <span class="attr">resultMap</span>=<span class="string">"UserBaseMap"</span>&gt;</span></div><div class="line">        SELECT * FROM t_user</div><div class="line">        WHERE user_email = #&#123;emailOrPhone&#125; OR user_phone = #&#123;emailOrPhone&#125;</div><div class="line">        AND user_state = #&#123;state&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAllUser"</span> <span class="attr">resultMap</span>=<span class="string">"UserBaseMap"</span>&gt;</span></div><div class="line">        SELECT * FROM t_user</div><div class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>namespace:当前库表映射文件的命名空间，唯一的不能重复</li>
<li>映射实体类的数据类型 id：resultMap的唯一标识</li>
<li>column:库表的字段名 property:实体类里的属性名</li>
<li>id：当前sql的唯一标识  </li>
<li>parameterType：输入参数的数据类型   </li>
<li>返回值的数据类型：resultMap适合使用返回值是自定义实体类的情况 ； resultType适合使用返回值的数据类型是非自定义的，即jdk的提供的类型。</li>
<li>{}:用来接受参数的，如果是传递一个参数#{id}内容任意，如果是多个参数就有一定的规则,采用的是预编译的形式select</li>
</ul>
</li>
<li><p>model</p>
<ul>
<li>实体属性——对应表中的元组的属性</li>
<li>getter和setter方法</li>
</ul>
</li>
</ul>
<blockquote>
<p>DataBase ===&gt; Entity ===&gt; Mapper.xml ===&gt; Mapper.<a href="http://lib.csdn.net/base/java" target="_blank" rel="external">Java</a> ===&gt; Service.java ===&gt; Controller.java ===&gt; Jsp.</p>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://blog.csdn.net/gallenzhang/article/details/51932152" target="_blank" rel="external">SSM框架整合（IntelliJ IDEA + maven + Spring + SpringMVC + MyBatis）</a></p>
<h2 id="SSM框架感受"><a href="#SSM框架感受" class="headerlink" title="SSM框架感受"></a>SSM框架感受</h2><blockquote>
<p>本质上的MVC，xml配置、注解，以及mapper的映射，让开发更加简洁和思路清晰</p>
</blockquote>
<p>## </p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;SSM框架整合理解&quot;&gt;&lt;a href=&quot;#SSM框架整合理解&quot; class=&quot;headerlink&quot; title=&quot;SSM框架整合理解&quot;&gt;&lt;/a&gt;SSM框架整合理解
    
    </summary>
    
      <category term="开发笔记" scheme="http://lincentma.men/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SSM" scheme="http://lincentma.men/tags/SSM/"/>
    
      <category term="SpringMVC" scheme="http://lincentma.men/tags/SpringMVC/"/>
    
      <category term="Spring" scheme="http://lincentma.men/tags/Spring/"/>
    
      <category term="Mybatis" scheme="http://lincentma.men/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【面试持续更新】2018校招记录</title>
    <link href="http://lincentma.men/interview_record.html"/>
    <id>http://lincentma.men/interview_record.html</id>
    <published>2017-07-14T16:10:57.000Z</published>
    <updated>2017-07-27T13:02:26.374Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="【面试持续更新】2018校招记录"><a href="#【面试持续更新】2018校招记录" class="headerlink" title="【面试持续更新】2018校招记录"></a>【面试持续更新】2018校招记录</h1><h1 id="工商银行"><a href="#工商银行" class="headerlink" title="工商银行"></a>工商银行</h1><p>一句话，谈人生谈理想，不谈技术</p>
<h1 id="中兴提前批"><a href="#中兴提前批" class="headerlink" title="中兴提前批"></a>中兴提前批</h1><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><ol>
<li>简单自我介绍</li>
<li>实习经历详细介绍</li>
<li>前端请求与后端处理的异常情况如何处理</li>
<li>SQL模糊查询语句，如何提高查询效率</li>
<li>实习所用PHP框架是如何与数据库相连接的</li>
<li>常用Shell命令</li>
<li>Git开发流程</li>
</ol>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><ol>
<li>再次自我介绍</li>
<li>工作地点意向询问</li>
<li>网络请求如何加速（不理解是询问那一方面的加速，自己回答分机房说不对）</li>
<li>实习相关问题</li>
<li>然后就陷入了尴尬的安静</li>
</ol>
<h1 id="海康威视提前批"><a href="#海康威视提前批" class="headerlink" title="海康威视提前批"></a>海康威视提前批</h1><h2 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h2><ol>
<li>简单自我介绍</li>
<li>Spark特性有哪些？</li>
<li>除了Hadoop之外有哪些其他的大数据处理框架？</li>
<li>MapReduce处理过程</li>
<li>Hadoop部署节点？如何部署？</li>
<li>Java与python的交互了解多少？如何进行交互？</li>
<li>Java内存模型介绍？</li>
<li>Java多线程介绍？ </li>
<li>JVM调优经验</li>
<li>使用过Redis等NoSQL数据库吗，Redis如何部署？Redis中的数据最终存储在哪里？ </li>
</ol>
<p>自己询问的问题：</p>
<ol>
<li>部门业务应用场景：大数据构建多特征模型进行行为安全预测判断</li>
<li>技术能力要求：部门有不同方向，不必太在意招聘中的所有要求都需要符合</li>
<li>什么时候有下一步的结果：他也不知道。。。。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;【面试持续更新】2018校招记录&quot;&gt;&lt;a href=&quot;#【面试持续更新】2018校招记录&quot; class=&quot;headerlink&quot; title=&quot;【面试持续更新】20
    
    </summary>
    
      <category term="面试" scheme="http://lincentma.men/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="interview" scheme="http://lincentma.men/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>自己用过的框架</title>
    <link href="http://lincentma.men/used_frames.html"/>
    <id>http://lincentma.men/used_frames.html</id>
    <published>2017-07-14T15:46:16.000Z</published>
    <updated>2017-07-14T15:48:14.875Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="自己用过的框架"><a href="#自己用过的框架" class="headerlink" title="自己用过的框架"></a>自己用过的框架</h1><h2 id="Java之SSH"><a href="#Java之SSH" class="headerlink" title="Java之SSH"></a>Java之SSH</h2><blockquote>
<p>SSH不是一个框架，而是多个框架的集成，是目前较流行的一种Web应用程序开源集成框架，用于构建灵活、易于扩展的多层Web应用程序。</p>
<p>系统从职责上分为四层：表示层、业务逻辑层、数据持久层和域模块层。</p>
</blockquote>
<h3 id="Spring-Struts-Hibernate（SSH）"><a href="#Spring-Struts-Hibernate（SSH）" class="headerlink" title="Spring+Struts+Hibernate（SSH）"></a>Spring+Struts+Hibernate（SSH）</h3><blockquote>
<p>其中使用Struts作为系统的整体基础架构，负责MVC的分离，在Struts框架的模型部分，利用hibernate框架对持久层提供支持，业务层用spring支持。</p>
<p>系统的基本业务流程是：</p>
<p>在表示层中，首先通过JSP页面实现交互界面，负责传送请求(Request)和接收响应(Response)，然后Struts根据配置文件(struts-config.xml)将ActionServlet接收到的Request委派给相应的Action处理。</p>
<p>在业务层中，管理服务组件的 Spring IoC容器负责向Action提供业务模型(Model)组件和该组件的协作对象数据处理(DAO)组件完成业务逻辑，并提供事务处理、缓冲池等容器组件以提升系统性能和保证数据的完整性。</p>
<p>在持久层中，则依赖于Hibernate的对象化映射和数据库交互，处理DAO组件请求的数据，并返回处理结果。</p>
</blockquote>
<p>SSH配置流程：</p>
<ol>
<li>创建web项目</li>
<li>配置struts：<ul>
<li>添加Struts2所需要的基本jar包到 lib目录</li>
<li>在web.xml 文件里添加struts的过滤器配置</li>
<li>在src目录下创建struts配置文件struts.xml</li>
</ul>
</li>
<li>配置spring：<ul>
<li>在lib目录下导入spring相关的jar包（2个spring跟struts结合的jar包）</li>
<li>在web.xml文件下配置监听器</li>
</ul>
</li>
<li>配置hibernate:<ul>
<li>在lib目录里导入hibernate相关的jar包</li>
<li>创建实体类</li>
<li>创建实体类对应的xxx..hbm.xml映射文件</li>
<li><strong>应用IOC实现DAO接口</strong></li>
</ul>
</li>
<li><strong>编写Action类</strong></li>
<li><strong>编写Service(接口类)和ServiceImpl(实现类)</strong></li>
</ol>
<p>Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。</p>
<p>Struts它通过采用 Java Servlet/JSP 技术，实现了基于JavaEE Web应用的MVC设计模式的应用框架，是MVC经典设计模式中的一个经典产品。</p>
<p>Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。</p>
<p>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 </p>
<h3 id="Spring-SpringMVC-Mybatis（SSM）"><a href="#Spring-SpringMVC-Mybatis（SSM）" class="headerlink" title="Spring+SpringMVC+Mybatis（SSM）"></a>Spring+SpringMVC+Mybatis（SSM）</h3><blockquote>
<p> SpringMVC 做控制器(controller)，Spring 管理各层的组件，MyBatis 负责持久化层。</p>
</blockquote>
<p>Struts2与SpringMVC</p>
<p><img src="http://p3.pstatp.com/large/f740001068a5c16f544" alt="avatar"></p>
<p><img src="http://p1.pstatp.com/large/f7500089dc67ac93a17" alt="avatar"></p>
<p>MyBatis与Hibernate</p>
<ul>
<li>MyBatis可以进行更为细致的SQL优化，可以减少查询字段。</li>
<li>MyBatis容易掌握，而Hibernate门槛较高。</li>
<li>Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。</li>
<li>Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。</li>
<li>Hibernate<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="external">数据库</a>移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。</li>
<li>Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳，更新操作不能指定刷新指定记录，会清空整个表，但是也可以使用第三方缓存。</li>
<li>Hibernate 封装性好，屏蔽了数据库差异，自动生成SQL语句，应对数据库变化能力较弱，SQL语句优化困难。</li>
<li>MyBatis仅实现了SQL语句和对象的映射，需要针对具体的数据库写SQL语句，应对数据库变化能力较强，SQL语句优化较为方便。</li>
</ul>
<p>SSM配置流程：</p>
<ol>
<li>创建web项目</li>
<li>在WEB-INF/lib导入jar包（亦可以根目录下用maven配置文件poom.xml进行配置管理jar包）</li>
<li>配置MyBatis:dao层编写dao类以及对应的mapper和xml（为dao接口方法提供sql语句配置）</li>
<li>配置spring：在applicationContext.xml.xml文件下配置</li>
<li>配置springmvc：配置springMVC.xml</li>
<li>编写Service以及ServiceImpl</li>
<li>编写Controller（相当于struts中的action）</li>
</ol>
<blockquote>
<p>SSM和SSH不同主要在MVC实现方式，以及ORM持久化方面不同（Hiibernate与Mybatis）。SSM越来越轻量级配置，将注解开发发挥到极致，且ORM实现更加灵活，SQL优化更简便；而SSH较注重配置开发，其中的Hiibernate对JDBC的完整封装更面向对象，对增删改查的数据维护更自动化，但SQL优化方面较弱，且入门门槛稍高。</p>
</blockquote>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="http://blog.csdn.net/zyb507/article/details/8122649" target="_blank" rel="external">SSH框架的底层机制及原理</a></li>
<li><a href="http://www.cnblogs.com/zhaowancheng/p/5841591.html" target="_blank" rel="external">SSH的框架整合</a></li>
<li><a href="http://blog.csdn.net/shan9liang/article/details/8803989" target="_blank" rel="external">SSH框架总结（框架分析+环境搭建+实例源码下载）</a></li>
<li><a href="http://blog.csdn.net/peak_and_valley/article/details/52925032" target="_blank" rel="external">SSH和SSM对比总结</a></li>
<li><a href="http://www.2cto.com/kf/201606/518341.html" target="_blank" rel="external">手把手教你整合最优雅SSM框架：SpringMVC + Spring + MyBatis</a></li>
<li><a href="http://how2j.cn/k/ssm/ssm-tutorial/1137.html?tid=77#nowhere" target="_blank" rel="external">SSM SPRING+SPING MVC + MYBATIS 三大框架整合详细步骤</a></li>
</ol>
<h2 id="PHP之ODP"><a href="#PHP之ODP" class="headerlink" title="PHP之ODP"></a>PHP之ODP</h2><blockquote>
<p><strong>ODP</strong>是公司发布的在线业务开发平台，面向全百度的在线业务支撑平台，专注于总结大社区类业务模式，其提供了标准的webserver环境、标准php环境、AP框架、SAF社区业务框架、基础库、RAL资源访问层、KSARCH通用服务等组件，统一业务的逻辑和部署结构，为测试、运维等提供一致的视图。</p>
<p>这也是自己实习时候一直在用的框架。</p>
</blockquote>
<p><strong><em>Online Develop Platform = Linux+Lightted/nginx+mysql+PHP</em></strong></p>
<p>ODP核心包含了ODP的核心功能组件，包括运行环境、核心基础库、数据交互层、框架等。</p>
<p>横向看，ODP核心通过库、框架、工具等集成支持了各类规范和模式，也为全流程支持提供接口。</p>
<p>向上看，ODP核心直接为产品线业务提供运行环境和研发支持。</p>
<p>向下看，ODP核心通过数据交互层将底层的通用服务提供给业务。</p>
<p>AP框架目录：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">模板层： odp/template/appname/</div><div class="line"></div><div class="line">Actiono: odp/app/appname/actions/</div><div class="line"></div><div class="line">PageService: odp/app/appname/models/service/page/</div><div class="line"></div><div class="line">DataService: odp/app/appname/models/service/data/</div><div class="line"></div><div class="line">Dao: odp/app/appname/models/dao/</div><div class="line"></div><div class="line">Controller:  odp/app/appname/controller/</div></pre></td></tr></table></figure>
<p>ODP应用程序结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">newapp          // 应用名称</div><div class="line">+--action       // 动作类目录</div><div class="line">|  +--api       // 子系统交互api目录</div><div class="line">|  |  --Sample.php  // 示例api服务端action</div><div class="line">|  --Sample.php // 示例普通action</div><div class="line">+--api          // saf api接口和服务类</div><div class="line">|  --Interface.php  // 接口类</div><div class="line">|  --Service.php    // 实现类</div><div class="line">+--conf         // 配置目录</div><div class="line">|  +--newapp        // 配置目录，配置文件可以拆分</div><div class="line">|     --global.conf // app全局配置文件</div><div class="line">|     --log.conf    // log示例配置文件</div><div class="line">+--controllers      // 控制类目录</div><div class="line">|  --Main.php       // 主控制类</div><div class="line">|  --Api.php        // api控制类</div><div class="line">+--doc          // 文档目录</div><div class="line">+--library      // 本地类根目录</div><div class="line">|  +--newapp        // app本地类目录</div><div class="line">|     --Util.php    // 示例本地类</div><div class="line">+--models       // 数据目录</div><div class="line">|  +--dao       // 数据获取目录</div><div class="line">|  |  --Sample.php  // 示例</div><div class="line">|  +--service       // 页面数据服务目录</div><div class="line">|     +--data       // 主题数据服务目录</div><div class="line">|     |  --Sample.php   // 示例</div><div class="line">|     +--page       // 页面数据服务目录</div><div class="line">|        --Sample.php   // 示例</div><div class="line">|        --SampleApi.php // api示例</div><div class="line">+--script       // 脚本目录</div><div class="line">|  --sampleScript.php   // 示例脚本</div><div class="line">+--test         // 测试目录</div><div class="line">+--Bootstrap.php    // ap框架的引导文件</div><div class="line">+--build.sh     // 打包脚本</div><div class="line">+--index.php        // 入口文件</div><div class="line">+--Makefile     // 自动部署脚本</div><div class="line">--readme.txt        // readme文件，告诉你如何部署和运行</div></pre></td></tr></table></figure>
<p>DB，通过对应参数的不同，实现自动拼接不同的SQL语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$tables 数据表列表，可以是数组或者字符串</div><div class="line">$fields 字段列表，可以是数组或者字符串</div><div class="line">$conds 条件列表，可以是数组或者字符串</div><div class="line">$options 选项列表，可以是数组或者字符串</div><div class="line">$appends 结尾操作列表，可以是数组或者字符串</div><div class="line"></div><div class="line">例如：</div><div class="line">$table = ‘student’;</div><div class="line">$fields = array(‘number’, ‘class’);</div><div class="line">$conds = array(‘grade =‘ =&gt;‘three’, ‘school =‘ =&gt; ‘希望小学’);</div><div class="line">调用select($table, $fields, $conds); </div><div class="line">就会生成 </div><div class="line">select number, class from student where grade = ‘three’ and school = ‘希望小学’   </div><div class="line">的sql语句并执行之。</div></pre></td></tr></table></figure>
<p>逻辑分层之间的调用关系，只能向后依赖，不能向前依赖或者跨层之间依赖。此次逻辑分层从前到后，依次为：Action、PageService、DataService、Dao。具体来说便是指，Dao不能依赖于DataService,PageService,Action；DataService不能依赖于PageService和Action；PageService不能依赖于Action。Action不能直接调用DataService，也不能直接调用Dao；PageService不能直接调用Dao。</p>
<p>SAF是<strong>ODP</strong>环境提供的业务层框架，SAF框架建立的目的是为了把业务逻辑开发过程中一些共性的问题抽取出来，并提供统一的解决方案。SAF框架包含控制器组件，通用业务组件（参数处理，session处理，日志打印等）以及通用配置组件。可以将SAF框架理解为一个工具库，SAF为我们提供了很多的通用功能例如验证用户的登录信息，接收用户提交的数据，更改用户的信息，记录用户的操作行为等。</p>
<p>SAF框架提供了一个很重要的功能就是钩子（Hook）机制，通过在钩子函数中覆写对应的钩子函数,可以实现对cgi(GET POST等)数据的特殊处理，对登陆信息的校验/修改以及对输出到log日志文件的内容的修改等功能。</p>
<p>RAL是一个支持多种交互协议和打包格式的php扩展。RAL规定了一套高度抽象的交互过程规范，将整个后端交互过程分成了交互协议和数据打包/解包两大块，可以支持一些常用的后端交互协议，标准化协议扩充的开发过程，促进代码复用。RAL集成了负载均衡、健康检查等功能，让上游端不需要再关注这些繁琐的通用逻辑，同时实现版本可以在性能方面有更优的表现。</p>
<h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><ol>
<li><a href="https://www.baidu.com/link?url=Ji5p7uSBrfaDJmm7pyKUWuagxe46iOW-3L7yJqIJIEgxG2PIbYtP8UcmVkjkAeNUqiGw473M1C2O56GpY6ifba&amp;wd=&amp;eqid=c406ef2100009259000000035968caf8" target="_blank" rel="external">ODP教程 | 百度外卖手册</a></li>
</ol>
<h2 id="Python之Tornado"><a href="#Python之Tornado" class="headerlink" title="Python之Tornado"></a>Python之Tornado</h2><blockquote>
<p>自己做Sug平台展示时候选择的Python Web框架</p>
</blockquote>
<p>Tornado 和现在的主流 Web 服务器框架（包括大多数 Python 的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。得利于其 非阻塞的方式和对 <a href="http://www.kernel.org/doc/man-pages/online/pages/man4/epoll.4.html" target="_blank" rel="external">epoll</a> 的运用，Tornado 每秒可以处理数以千计的连接，这意味着对于实时 Web 服务来说，Tornado 是一个理想的 Web 框架。我们开发这个 Web 服务器的主要目的就是为了处理 FriendFeed 的实时功能 ——在 FriendFeed 的应用里每一个活动用户都会保持着一个服务器连接。</p>
<h3 id="参考文章：-1"><a href="#参考文章：-1" class="headerlink" title="参考文章："></a>参考文章：</h3><ol>
<li><a href="http://www.tornadoweb.cn/documentation" target="_blank" rel="external">Tornado</a></li>
</ol>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><blockquote>
<p>无论做什么框架，很多时候都离不开nginx</p>
</blockquote>
<p>NGINX 有一个主进程（它执行特权操作，如读取配置和绑定端口）和一些工作进程与辅助进程。</p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理应该是Nginx做的最多的一件事了。反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">server &#123;  </div><div class="line">        listen       80;                                                         </div><div class="line">        server_name  localhost;                                               </div><div class="line">        client_max_body_size 1024M;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://localhost:8080;</div><div class="line">            proxy_set_header Host $host:$server_port;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。</p>
<h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">upstream test &#123;</div><div class="line">    server localhost:8080;</div><div class="line">    server localhost:8081;</div><div class="line">&#125;</div><div class="line">server &#123;</div><div class="line">    listen       81;                                                         </div><div class="line">    server_name  localhost;                                               </div><div class="line">    client_max_body_size 1024M;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://test;</div><div class="line">        proxy_set_header Host $host:$server_port;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h4><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upstream test &#123;</div><div class="line">    server localhost:8080 weight=9;</div><div class="line">    server localhost:8081 weight=1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h4><p><em>ip</em>hash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream test &#123;</div><div class="line">    ip_hash;</div><div class="line">    server localhost:8080;</div><div class="line">    server localhost:8081;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h4><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123; </div><div class="line">    fair; </div><div class="line">    server localhost:8080;</div><div class="line">    server localhost:8081;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h4><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123; </div><div class="line">    hash $request_uri; </div><div class="line">    hash_method crc32; </div><div class="line">    server localhost:8080;</div><div class="line">    server localhost:8081;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">upstream test&#123;  </div><div class="line">       server localhost:8080;  </div><div class="line">       server localhost:8081;  </div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    server &#123;  </div><div class="line">        listen       80;  </div><div class="line">        server_name  localhost;  </div><div class="line"></div><div class="line">        location / &#123;  </div><div class="line">            root   e:wwwroot;  </div><div class="line">            index  index.html;  </div><div class="line">        &#125;  </div><div class="line"></div><div class="line">        # 所有静态请求都由nginx处理，存放目录为html  </div><div class="line">        location ~ .(gif|jpg|jpeg|png|bmp|swf|css|js)$ &#123;  </div><div class="line">            root    e:wwwroot;  </div><div class="line">        &#125;  </div><div class="line"></div><div class="line">        # 所有动态请求都转发给tomcat处理  </div><div class="line">        location ~ .(jsp|do)$ &#123;  </div><div class="line">            proxy_pass  http://test;  </div><div class="line">        &#125;  </div><div class="line"></div><div class="line">        error_page   500 502 503 504  /50x.html;  </div><div class="line">        location = /50x.html &#123;  </div><div class="line">            root   e:wwwroot;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="参考文章：-2"><a href="#参考文章：-2" class="headerlink" title="参考文章："></a>参考文章：</h3><ol>
<li><a href="http://blog.jobbole.com/110400/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts" target="_blank" rel="external">全面了解 Nginx 主要应用场景</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;自己用过的框架&quot;&gt;&lt;a href=&quot;#自己用过的框架&quot; class=&quot;headerlink&quot; title=&quot;自己用过的框架&quot;&gt;&lt;/a&gt;自己用过的框架&lt;/h1&gt;&lt;h2
    
    </summary>
    
      <category term="开发笔记" scheme="http://lincentma.men/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="frame" scheme="http://lincentma.men/tags/frame/"/>
    
  </entry>
  
  <entry>
    <title>尘封已久的新浪微博实习面试问题</title>
    <link href="http://lincentma.men/merge_file_by_multi_threads.html"/>
    <id>http://lincentma.men/merge_file_by_multi_threads.html</id>
    <published>2017-07-05T15:57:49.000Z</published>
    <updated>2017-07-05T16:48:31.318Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="尘封已久的新浪微博实习面试问题"><a href="#尘封已久的新浪微博实习面试问题" class="headerlink" title="尘封已久的新浪微博实习面试问题"></a>尘封已久的新浪微博实习面试问题</h1><blockquote>
<p>假设本地磁盘目录中有若干文本文件（每行存储一个字符串），要求实现一个多线程的应用程序，将这些文本文件合并为一个文件文件。</p>
<p>备注：编程语言为必须Java，考虑代码注释、日志打印及异常处理，可以忽略内存限制。</p>
<p>请将代码以PDF附件的形式回复，谢谢。</p>
</blockquote>
<h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><ul>
<li>最简单的想法，一个线程读一个线程写</li>
<li>其次的想法，多个线程读同一个文件，一个线程写（单线程消费, 这样就严格保证了顺序）</li>
<li>多线程分组读取，是否要考虑文件的顺序？如果考虑顺序该如何？</li>
<li>线程池、生产者消费者模型</li>
<li>NIO</li>
<li>预先对目录中的文件进行分类；线程间通信，全局变量判断文件读取状态，避免重复读取</li>
<li>同步锁、队列</li>
<li>注释、日志、异常处理</li>
</ul>
<h2 id="思路参考"><a href="#思路参考" class="headerlink" title="思路参考"></a>思路参考</h2><ul>
<li><a href="http://blog.csdn.net/xiaoyangsavvy/article/details/72236603" target="_blank" rel="external">java多线程读取多个文件 导入数据库</a></li>
</ul>
<blockquote>
<p>对于处理<a href="http://lib.csdn.net/base/hadoop" target="_blank" rel="external">大数据</a>量的记录，并将处理结果写入文件中的处理方案：<br>方案一(适合于处理和输出的数据量都很大的情况)：<br>生产者：多个线程 读取一定量的数据并处理，然后将处理结果封装成一个队列元素，装进阻塞队列中<br>消费者: 一个线程 取元素 追加写文件(csv) (多个线程写文件是不安全的)</p>
<p>方案二(目前在使用的，适用于需要处理的数据量大，但输出的数据量不大的情况)：<br>生产者：一个线程，分页查询部分数据，将其封装成队列元素装进队列中<br>消费者：多个线程 ，从队列中取出数据元素并处理，存储处理结果。<br>生产者和消费者执行完毕后，再集中将消费者处理的结果一个个输出到相应文件中</p>
</blockquote>
<ul>
<li><a href="http://zx-code.iteye.com/blog/2267434" target="_blank" rel="external">java 使用线程池处理文件夹下面的文件</a></li>
</ul>
<blockquote>
<p>由于LinkedBlockingQueue实现是线程安全的，实现了先进先出等特性，是作为生产者消费者的首选。</p>
<p>LinkedBlockingQueue 可以指定容量，不指定的话，默认最大是Integer.MAX_VALUE，其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，  直到有队列成员被放进来。 </p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/chen_yao_kerr/article/details/70675135" target="_blank" rel="external">java多线程批量读取文件(一)</a></li>
</ul>
<ul>
<li><a href="http://blog.csdn.net/a497006686/article/details/52404081" target="_blank" rel="external">新浪面试题-多线程合并文件</a></li>
<li><a href="http://blog.csdn.net/10km/article/details/51822932" target="_blank" rel="external">java:NIO读写文件的示例</a></li>
<li><a href="http://blog.csdn.net/tiantiandjava/article/details/46311929" target="_blank" rel="external">IntelliJ IDEA 之 jdk Language level</a></li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h2 id="代码感悟"><a href="#代码感悟" class="headerlink" title="代码感悟"></a>代码感悟</h2><blockquote>
<p>看了那么多资料，最后还是最简单的最好理解，一个线程读取然后再写，感觉向一个伪多线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sinatest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">fileWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> File inputFile;</div><div class="line">    <span class="keyword">private</span> String outputFile;</div><div class="line"></div><div class="line">    <span class="comment">//构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">fileWorker</span><span class="params">(File inputFile, String outputFile)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.inputFile = inputFile;</div><div class="line">        <span class="keyword">this</span>.outputFile = outputFile;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        File output = <span class="keyword">new</span> File(outputFile);</div><div class="line">        <span class="keyword">if</span> (!output.exists()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                output.createNewFile();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        FileInputStream fin = <span class="keyword">null</span>;</div><div class="line">        FileOutputStream fout = <span class="keyword">null</span>;</div><div class="line">        FileChannel fic = <span class="keyword">null</span>;</div><div class="line">        FileChannel foc = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            fin = <span class="keyword">new</span> FileInputStream(inputFile);</div><div class="line">            fout = <span class="keyword">new</span> FileOutputStream(output, <span class="keyword">true</span>);</div><div class="line">            <span class="comment">// 从FileInputStream创建用于输入的FileChannel</span></div><div class="line">            fic = fin.getChannel();</div><div class="line">            <span class="comment">// 从FileOutputStream 创建用于输出的FileChannel</span></div><div class="line">            foc = fout.getChannel();</div><div class="line">            <span class="comment">// 16KB缓冲区</span></div><div class="line">            ByteBuffer bb = ByteBuffer.allocate(<span class="number">1024</span> &lt;&lt; <span class="number">4</span>);</div><div class="line">            <span class="comment">// 根据 read返回实际读出的字节数 中止循环</span></div><div class="line">            <span class="keyword">while</span> (fic.read(bb) &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 缓冲区翻转用于输出到foc</span></div><div class="line">                bb.flip();</div><div class="line">                foc.write(bb);</div><div class="line">                <span class="comment">// 清空缓冲区用于下次读取</span></div><div class="line">                bb.clear();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// 安全释放资源</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != fic)</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    fic.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != foc)</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    foc.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != fin)</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    fin.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != fout)</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    fout.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    <span class="comment">//线程池线程数量</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_POOL_SIZE = <span class="number">5</span>;</div><div class="line">    <span class="comment">//遍历文件夹</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;File&gt; filePathsList = <span class="keyword">new</span> ArrayList&lt;File&gt;();</div><div class="line">    <span class="comment">//缓存队列</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue BLOCKING_QUEUE = <span class="keyword">new</span> LinkedBlockingQueue();</div><div class="line">    <span class="comment">//1、遍历文件夹</span></div><div class="line">    <span class="comment">//2、线程池读取</span></div><div class="line">    <span class="comment">//3、线程写入</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//读取文件类型</span></div><div class="line">        String fileSuffix = <span class="string">".txt"</span>;</div><div class="line">        <span class="comment">//读取文件目录</span></div><div class="line">        String fileFolder = <span class="string">"D://Project//Java//MergeFile//datatest"</span>;</div><div class="line">        <span class="comment">//合并文件夹路径</span></div><div class="line">        String outputFilePath = <span class="string">"D://Project//Java//MergeFile//output.txt"</span>;</div><div class="line">        <span class="comment">//遍历文件夹</span></div><div class="line">        getFileList(fileFolder, fileSuffix);</div><div class="line">        <span class="comment">//创建线程池</span></div><div class="line">        ExecutorService es = Executors.newFixedThreadPool(THREAD_POOL_SIZE);</div><div class="line">        <span class="comment">//每一个线程读取一个文件</span></div><div class="line">        <span class="keyword">for</span> (File filePath : filePathsList) &#123;</div><div class="line">            es.execute(<span class="keyword">new</span> fileWorker(filePath, outputFilePath));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFileList</span><span class="params">(String fileFolder, String fileSuffix)</span> </span>&#123;</div><div class="line">        File f = <span class="keyword">new</span> File(fileFolder);</div><div class="line">        File[] filePaths = f.listFiles();</div><div class="line">        <span class="keyword">for</span> (File s : filePaths) &#123;</div><div class="line">            <span class="keyword">if</span> (s.isDirectory()) &#123;</div><div class="line">                getFileList(s.toString(), fileSuffix);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (-<span class="number">1</span> != s.getName().lastIndexOf(fileSuffix)) &#123;</div><div class="line">                    filePathsList.add(s);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>[ ] 解决写入顺序问题</li>
<li>[ ] 采用生产者消费者模式实现，究竟是多线程读取一个文件，还是多线程读取多个文件，还是多线程写一个文件，哪一个在实际生产环境中是最合适的</li>
<li>[ ] 日志记录以及异常处理</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;尘封已久的新浪微博实习面试问题&quot;&gt;&lt;a href=&quot;#尘封已久的新浪微博实习面试问题&quot; class=&quot;headerlink&quot; title=&quot;尘封已久的新浪微博实习面
    
    </summary>
    
      <category term="开发笔记" scheme="http://lincentma.men/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://lincentma.men/tags/java/"/>
    
      <category term="multi-thread" scheme="http://lincentma.men/tags/multi-thread/"/>
    
  </entry>
  
  <entry>
    <title>Python命令行查询成都铁路局12306检票口信息</title>
    <link href="http://lincentma.men/find_train_check_in.html"/>
    <id>http://lincentma.men/find_train_check_in.html</id>
    <published>2017-07-04T13:16:33.000Z</published>
    <updated>2017-07-04T13:29:35.339Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote>
<p>Github地址：</p>
<p>[Find-Train-Ticket-Check-in]: <a href="https://github.com/lingma1993/Find-Train-Ticket-Check-in" target="_blank" rel="external">https://github.com/lingma1993/Find-Train-Ticket-Check-in</a></p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>近日多地大雨导致铁路多趟列车停运，自己关注成都铁路12306微信公众号，发现一个新的侯乘信息查询功能。</p>
<p>该功能提供了动车和高铁的列车检票口的信息，正好圆了自己的之前挖的坑。</p>
<h2 id="如何获取接口"><a href="#如何获取接口" class="headerlink" title="如何获取接口"></a>如何获取接口</h2><p>链接地址：</p>
<p>chrome F12 点击查询在Network中找到相关接口的信息</p>
<p><a href="http://www.cd-rail.com:9090/CTKF/GeneralProServlet?code=C50101&amp;login=[&quot;10.192.111.79&quot;,&quot;hhs&quot;,&quot;hhs&quot;]&amp;sql=[&quot;20170703&quot;,&quot;ICW&quot;]&amp;where=[]&amp;order=[" target="_blank" rel="external">http://www.cd-rail.com:9090/CTKF/GeneralProServlet?code=C50101&amp;login=[&quot;10.192.111.79&quot;,&quot;hhs&quot;,&quot;hhs&quot;]&amp;sql=[&quot;20170703&quot;,&quot;ICW&quot;]&amp;where=[]&amp;order=[</a>]</p>
<p>通过<em><a href="">Postman</a></em>模拟数据请求获取数据获取信息请求的格式</p>
<h2 id="接口参数"><a href="#接口参数" class="headerlink" title="接口参数"></a>接口参数</h2><ol>
<li>车站查询</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">参数名称</th>
<th style="text-align:left">参数含义</th>
<th style="text-align:left">参数示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">code</td>
<td style="text-align:left"></td>
<td style="text-align:left">C50101</td>
</tr>
<tr>
<td style="text-align:left">login</td>
<td style="text-align:left">登陆信息</td>
<td style="text-align:left">[“10.192.111.79”,”hhs”,”hhs”]</td>
</tr>
<tr>
<td style="text-align:left">sql</td>
<td style="text-align:left">查询语句</td>
<td style="text-align:left">[“20170703”,”ICW”]</td>
</tr>
<tr>
<td style="text-align:left">where</td>
<td style="text-align:left"></td>
<td style="text-align:left">[]</td>
</tr>
<tr>
<td style="text-align:left">order</td>
<td style="text-align:left"></td>
<td style="text-align:left">[]</td>
</tr>
</tbody>
</table>
<ol>
<li>车次查询</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">参数名称</th>
<th style="text-align:left">参数含义</th>
<th style="text-align:left">参数示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">code</td>
<td style="text-align:left"></td>
<td style="text-align:left">C5010</td>
</tr>
<tr>
<td style="text-align:left">login</td>
<td style="text-align:left">登陆信息</td>
<td style="text-align:left">[“10.192.111.79”,”hhs”,”hhs”]</td>
</tr>
<tr>
<td style="text-align:left">sql</td>
<td style="text-align:left">查询语句</td>
<td style="text-align:left">[“20170703”,”8503”,”ICW”]</td>
</tr>
<tr>
<td style="text-align:left">where</td>
<td style="text-align:left"></td>
<td style="text-align:left">[]</td>
</tr>
<tr>
<td style="text-align:left">order</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<ol>
<li>车站名称查询</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">参数名称</th>
<th style="text-align:left">参数含义</th>
<th style="text-align:left">参数示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">code</td>
<td style="text-align:left"></td>
<td style="text-align:left">C50102</td>
</tr>
<tr>
<td style="text-align:left">login</td>
<td style="text-align:left">登陆信息</td>
<td style="text-align:left">[“10.192.111.79”,”hhs”,”hhs”]</td>
</tr>
<tr>
<td style="text-align:left">sql</td>
<td style="text-align:left">查询语句</td>
<td style="text-align:left">[]</td>
</tr>
<tr>
<td style="text-align:left">where</td>
<td style="text-align:left"></td>
<td style="text-align:left">[]</td>
</tr>
<tr>
<td style="text-align:left">order</td>
<td style="text-align:left"></td>
<td style="text-align:left">[]</td>
</tr>
</tbody>
</table>
<h2 id="解析接口返回结果"><a href="#解析接口返回结果" class="headerlink" title="解析接口返回结果"></a>解析接口返回结果</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&#123;<span class="attr">"CHECK_STATUS"</span>:<span class="string">"停止检票"</span>,<span class="attr">"CHECK_TICKET"</span>:<span class="string">"A10、A11"</span>,<span class="attr">"END_CHECK_TIME"</span>:<span class="string">"2017/07/04 09:30:00"</span>,<span class="attr">"END_STN"</span>:<span class="string">"重庆北"</span>,<span class="attr">"END_STN_CODE"</span>:<span class="string">"CUW"</span>,<span class="attr">"IN_DATE"</span>:<span class="string">"2017/07/04 18:59:52"</span>,<span class="attr">"START_CHECK_TIME"</span>:<span class="string">"2017/07/04 09:14:00"</span>,<span class="attr">"START_STN"</span>:<span class="string">"成都东"</span>,<span class="attr">"START_STN_CODE"</span>:<span class="string">"ICW"</span>,<span class="attr">"STATUS_TRAIN"</span>:<span class="string">"正点"</span>,<span class="attr">"STN_CODE"</span>:<span class="string">"ICW"</span>,<span class="attr">"TD_DATE_ARR"</span>:<span class="string">"00:00:00"</span>,<span class="attr">"TD_DATE_DEP11"</span>:<span class="string">"09:33"</span>,<span class="attr">"TRAIN_DEP"</span>:<span class="string">"G8503"</span>,<span class="attr">"WAIT_ROOM"</span>:<span class="string">"2层候车区"</span>,<span class="attr">"WGQBZ"</span>:<span class="string">"0"</span>&#125;]</div></pre></td></tr></table></figure>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ol>
<li>urlib、urlib2<ul>
<li>构建Header，模拟Post请求</li>
</ul>
</li>
<li>prettytable<ul>
<li>处理返回数据格式化为表格</li>
</ul>
</li>
<li>re<ul>
<li>匹配站点名称以及检索结果</li>
</ul>
</li>
</ol>
<h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p><img src="http://orj5hqpmw.bkt.clouddn.com/find_train_check_in.png" alt="TIM截图20170704212154"></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;Github地址：&lt;/p&gt;
&lt;p&gt;[Find-Train-Ticket-Check-in]: &lt;a href=&quot;https://github.com
    
    </summary>
    
      <category term="开发笔记" scheme="http://lincentma.men/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="python" scheme="http://lincentma.men/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>记如何折腾让博客加HTTPS</title>
    <link href="http://lincentma.men/hexo_https.html"/>
    <id>http://lincentma.men/hexo_https.html</id>
    <published>2017-06-27T16:09:54.000Z</published>
    <updated>2017-06-27T16:58:24.162Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="记如何折腾让博客加HTTPS"><a href="#记如何折腾让博客加HTTPS" class="headerlink" title="记如何折腾让博客加HTTPS"></a>记如何折腾让博客加HTTPS</h1><blockquote>
<p>折腾了一晚上的博客的HTTPS问题，最后才明白一个道理，世上没有免费的午餐，如果有，那么也是你用最宝贵的时间或是其他换来的。</p>
<p>最终折腾完一圈，回到原点的时候，明白了需求分析而不是说走就走的重要。</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="1-Google-抓取重定向301"><a href="#1-Google-抓取重定向301" class="headerlink" title="1 - Google 抓取重定向301"></a>1 - Google 抓取重定向301</h3><p>在Google搜索site:lincentma.men，查找自己的网站是否被Google收录。</p>
<p>自己的在Google Search Console 中，自己添加了sitemap之后，尝试抓取网站页面，显示：</p>
<table>
<thead>
<tr>
<th><a href="http://lincentma.men/">http://lincentma.men/</a></th>
<th>请求编入索引</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Googlebot类型： 桌面</td>
</tr>
<tr>
<td></td>
<td>已重定向 抓取时间：2017年6月26日星期一 GMT-7 下午8:25:37</td>
</tr>
<tr>
<td></td>
<td>此网址已重定向至：<a href="https://lincentma.men/">https://lincentma.men/</a></td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 301 Moved Permanently</div><div class="line">Content-Type: application/x-gzip</div><div class="line">Location: https://lincentma.men/</div><div class="line">Server: Coding Pages</div><div class="line">Vary: Accept-Encoding</div><div class="line">Date: Tue, 27 Jun 2017 03:25:39 GMT</div><div class="line">Content-Length: 57</div></pre></td></tr></table></figure>
<p>导致在Google上没有自己博客更新的文章。</p>
<h4 id="原因：Coding-Pages-产生中间页"><a href="#原因：Coding-Pages-产生中间页" class="headerlink" title="原因：Coding Pages 产生中间页"></a>原因：Coding Pages 产生中间页</h4><p>从上面的HTTP响应头部的标志可以看出，Google重定向到了一个Coding Pages的服务商，也就是我双线同步博客的coding pages。</p>
<p>在其官网上我发现：</p>
<blockquote>
<p>银牌会员的 Coding Pages 在访问时默认会先加载 Pages 跳转页，您可选择在网站首页任意位置放置「Hosted by Coding Pages」的文字版或图片版，然后勾选下方的「已放置 Hosted by Coding Pages」选项，通过审核后您的 Pages 将不会显示跳转页。请务必将「Hosted by Coding Pages」持续保留在网站首页，撤掉后跳转页会再次出现。</p>
</blockquote>
<p>也就是没有银牌会员或者没有在博客上加载广告的时候，就会先跳转到中间页。Google在抓取页面的时候就会发现和目标地址不一致，导致抓取失败。所以没有免费的午餐。</p>
<h3 id="2-百度-HTTPS站点认证失败"><a href="#2-百度-HTTPS站点认证失败" class="headerlink" title="2 - 百度 HTTPS站点认证失败"></a>2 - 百度 HTTPS站点认证失败</h3><p>失败详情：您的站点有链接未通过https检验。</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>抓取操作不会跟踪重定向。如果您抓取的网页存在重定向，您将需要手动前往重定向到的网址。</li>
<li>301转向(或叫301重定向，301跳转)是当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。</li>
<li>302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。302 重定向会造成网址URL 劫持现象。</li>
<li>HTTP请求格式：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>请求头</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Host</strong></td>
<td>接受请求的服务器地址，可以是IP:端口号，也可以是域名</td>
</tr>
<tr>
<td><strong>User-Agent</strong></td>
<td>发送请求的应用程序名称</td>
</tr>
<tr>
<td><strong>Connection</strong></td>
<td>指定与连接相关的属性，如Connection:Keep-Alive</td>
</tr>
<tr>
<td><strong>Accept-Charset</strong></td>
<td>通知服务端可以发送的编码格式</td>
</tr>
<tr>
<td><strong>Accept-Encoding</strong></td>
<td>通知服务端可以发送的数据压缩格式</td>
</tr>
<tr>
<td><strong>Accept-Language</strong></td>
<td>通知服务端可以发送的语言</td>
</tr>
</tbody>
</table>
<ul>
<li>HTTP响应格式：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>响应头</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Server</strong></td>
<td>服务器应用程序软件的名称和版本</td>
</tr>
<tr>
<td><strong>Content-Type</strong></td>
<td>响应正文的类型（是图片还是二进制字符串）</td>
</tr>
<tr>
<td><strong>Content-Length</strong></td>
<td>响应正文长度</td>
</tr>
<tr>
<td><strong>Content-Charset</strong></td>
<td>响应正文使用的编码</td>
</tr>
<tr>
<td><strong>Content-Encoding</strong></td>
<td>响应正文使用的数据压缩格式</td>
</tr>
<tr>
<td><strong>Content-Language</strong></td>
<td>响应正文使用的语言</td>
</tr>
</tbody>
</table>
<ul>
<li><p>HTTPS：HTTPS 协议就是 HTTP+SSL/TLS，即在 HTTP 基础上加入 SSL /TLS 层，提供了内容加密、身份认证和数据完整性3大功能，目的就是为了加密数据，用于安全的数据传输。</p>
</li>
<li><p>其中一个问题：网站改用 HTTPS 以后，由 HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用 301、302 跳转）</p>
</li>
<li><p>[推荐文章]: <a href="http://support.upyun.com/hc/kb/article/1044299/" target="_blank" rel="external">http://support.upyun.com/hc/kb/article/1044299/</a></p>
</li>
</ul>
<ul>
<li>Google宣布了，从2017年1月份正式发布的Chrome 56开始，Google将把某些包含敏感内容的https页面标记为“不安全”。</li>
</ul>
<p>HTTPS是趋势，然而Github不支持自定义域名的强制HTTPS，Coding国内的必须加广告才能强制HTTPS且没有中间跳转页。所以自己就开始了折腾HTTPS的道路。</p>
<h2 id="折腾HTTPS："><a href="#折腾HTTPS：" class="headerlink" title="折腾HTTPS："></a>折腾HTTPS：</h2><h3 id="折腾：配置CloudFare失败"><a href="#折腾：配置CloudFare失败" class="headerlink" title="折腾：配置CloudFare失败"></a>折腾：配置CloudFare失败</h3><p>终究会有免费的午餐，那就是CloudFare。</p>
<h4 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h4><h4 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h4><ul>
<li><p>CloudFlare作为一家CDN提供商，他为免费用户提供的服务室不完整的，根据官网SSL服务的介绍，<strong>CloudFlare仅会在浏览器与CloudFlare的通讯中加密，CloudFlare与本地服务器的通讯本身并没有加密。</strong>这也是Flexible和Full模式的区别所在。</p>
</li>
<li><p>SSL：在客户端与服务器间传输的数据是通过使用对称算法（如 DES 或 RC4）进行加密的。公用密钥算法（通常为 RSA）是用来获得加密密钥交换和数字签名的，此算法使用服务器的SSL数字证书中的公用密钥。有了服务器的SSL数字证书，客户端也可以验证服务器的身份。SSL 协议的版本 1 和 2 只提供服务器认证。版本 3 添加了客户端认证，此认证同时需要客户端和服务器的数字证书。</p>
</li>
<li><p>关于Let&#39;s Encrypt：[给站点添加 https 小绿锁]: <a href="http://www.cnblogs.com/xinpureZhu/articles/lets-encrypt-to-add-https-site-little-green-lock.html" target="_blank" rel="external">http://www.cnblogs.com/xinpureZhu/articles/lets-encrypt-to-add-https-site-little-green-lock.html</a></p>
</li>
</ul>
<p>但是，都设置好了。然后就无法访问网页的了。DNS的锅。</p>
<p>发现阿里云的DNS修改后仍处于未更改的状态，即使CloudFlare显示Status：Active。</p>
<p>自己认为可能的是国外DNS被墙，或者是强制HTTPS生效时间过长导致没有及时生效。</p>
<h3 id="返回Coding-Pages-加广告"><a href="#返回Coding-Pages-加广告" class="headerlink" title="返回Coding Pages 加广告"></a>返回Coding Pages 加广告</h3><p>无奈返回去添加广告。</p>
<h4 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h4><ul>
<li>Hexo ，快速、简单且功能强大的 <a href="http://lib.csdn.net/base/nodejs" target="_blank" rel="external">Node.js</a> 博客框架。</li>
<li>页面布局</li>
<li>Hexo中自己感觉一个很有意思的特点是，在_config.yml以及md文件中，通过对于指定字段的true或者false的设置来实现功能，对于使用者来说是黑盒操作，降低了使用难度，提高了使用的体验。这是一种很好的方式。</li>
</ul>
<h3 id="阿里云更改域名配置"><a href="#阿里云更改域名配置" class="headerlink" title="阿里云更改域名配置"></a>阿里云更改域名配置</h3><p>买了一个域名：lincentma.men</p>
<p>参考文章：[hexo博客添加域名实现双线部署（github和coding)]: <a href="http://blog.csdn.net/qiuchengjia/article/details/52923156" target="_blank" rel="external">http://blog.csdn.net/qiuchengjia/article/details/52923156</a></p>
<h4 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h4><ul>
<li>域名解析就是国际域名或者国内域名以及中文域名等域名申请后做的到IP地址的转换过程。IP地址是网路上标识您站点的数字地址，为了简单好记，采用域名来代替ip地址标识站点地址。域名的解析工作由DNS服务器完成。</li>
<li>域名解析的A：A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。</li>
<li>域名解析的CNAME：别名记录。这种记录允许您将多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。</li>
<li>A记录就是把一个域名解析到一个<strong>IP地址</strong>（Address，特制数字IP地址），而CNAME记录就是把域名解析到另外一个<strong>域名</strong>。</li>
<li>还有MX记录（邮件记录）和NS记录（解析服务器记录，NS记录只对子域名生效）</li>
</ul>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>[ ] 站点地图的HTTPS是安全的，其他页面是信息不安全的，why？</li>
<li>[ ] Ngnix与SSL</li>
<li>[ ] 自己在Github博客申请SSL证书</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;记如何折腾让博客加HTTPS&quot;&gt;&lt;a href=&quot;#记如何折腾让博客加HTTPS&quot; class=&quot;headerlink&quot; title=&quot;记如何折腾让博客加HTTPS
    
    </summary>
    
      <category term="开发笔记" scheme="http://lincentma.men/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://lincentma.men/tags/hexo/"/>
    
      <category term="https" scheme="http://lincentma.men/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>【解析】Java Skills For Interview</title>
    <link href="http://lincentma.men/java_skills_for_interview.html"/>
    <id>http://lincentma.men/java_skills_for_interview.html</id>
    <published>2017-06-25T17:43:55.000Z</published>
    <updated>2017-06-26T07:25:20.279Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="【解析】Java-Skills-For-Interview"><a href="#【解析】Java-Skills-For-Interview" class="headerlink" title="【解析】Java Skills For Interview"></a>【解析】Java Skills For Interview</h1><blockquote>
<p>从网上偶得之，把每个函数弄明白，源码是怎么写的，为什么这么写。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//import不要使用通配符，需要import哪一个就import哪一个。</span></div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaSkillsForInterview</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="comment">// String</span></div><div class="line">        String s = <span class="string">"abc"</span>;</div><div class="line">        s.charAt(<span class="number">0</span>);<span class="comment">//返回指定索引处的 char 值。</span></div><div class="line">        s.length();<span class="comment">//返回此字符串的长度。</span></div><div class="line">        s.substring(<span class="number">0</span>, <span class="number">1</span>);<span class="comment">//返回字符串的子字符串。beginIndex - 起始索引（包括），endIndex - 结束索引（不包括）。左闭右开。</span></div><div class="line">        s.substring(<span class="number">1</span>);<span class="comment">//返回beginIndex - 起始索引（包括）到字符串末尾的子字符串。</span></div><div class="line">        s.equals(<span class="string">"b"</span>);<span class="comment">//将此字符串与指定的对象比较。</span></div><div class="line">        s = s.trim();<span class="comment">//返回字符串的副本，忽略前导空白和尾部空白。用于删除字符串的头尾空白符。</span></div><div class="line">        s.indexOf(<span class="string">"a"</span>);<span class="comment">//返回指定字符在此字符串中第一次出现处的索引。如果此字符串中没有这样的字符，则返回-1。</span></div><div class="line">        s.indexOf(<span class="string">"a"</span>, <span class="number">1</span>);<span class="comment">//返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</span></div><div class="line">        s.lastIndexOf(<span class="string">"a"</span>);<span class="comment">//返回指定字符在此字符串中最后一次出现处的索引。</span></div><div class="line">        s.lastindexOf(<span class="string">"a"</span>, <span class="number">1</span>);<span class="comment">//返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</span></div><div class="line">        s.toCharArray();<span class="comment">//【常用】将此字符串转换为一个新的字符数组。</span></div><div class="line">        Integer.valueOf(s); <span class="comment">// returns an Integer object，valueOf会返回一个Integer（整型）对象</span></div><div class="line">        <span class="comment">//【注意】Integer类有一个静态缓存，存储了256个特殊的Integer对象——每个对象分别对应`-128 和127之间的一个值。</span></div><div class="line">        <span class="comment">// Integer.valueOf("127")==Integer.valueOf("127");【true】</span></div><div class="line">        <span class="comment">// Integer.valueOf("128")==Integer.valueOf("128");【false】</span></div><div class="line">        Integer.parseInt(s); <span class="comment">// returns an int primitive， 将形参s转化为整数。Interger.parseInt("1")=1;</span></div><div class="line">        String.valueOf(s); <span class="comment">// integer to string 返回指定参数的字符串表示形式。</span></div><div class="line"></div><div class="line">        <span class="comment">// StringBuilder</span></div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        sb.append(<span class="string">"a"</span>);<span class="comment">//将指定的字符串追加到此字符序列。</span></div><div class="line">        sb.insert(<span class="number">0</span>, <span class="string">"a"</span>); <span class="comment">//在index指示的字符之前插入指定的字符串。</span></div><div class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>); <span class="comment">//在这个序列中的指定位置，此方法将删除字符。	</span></div><div class="line">        sb.reverse(); <span class="comment">//此方法会导致此字符序列被替换为该序列的反转序列。</span></div><div class="line">        sb.toString(); <span class="comment">//该方法返回一个字符串，它表示这个序列中的数据。</span></div><div class="line">        <span class="comment">//String 长度大小不可变</span></div><div class="line">        <span class="comment">//StringBuffer 和 StringBuilder 长度可变</span></div><div class="line">        <span class="comment">//StringBuffer 线程安全 StringBuilder 线程不安全</span></div><div class="line">        <span class="comment">//StringBuilder 速度快</span></div><div class="line">        </div><div class="line">        <span class="comment">// Array</span></div><div class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//初始化方式1</span></div><div class="line">        <span class="keyword">char</span>[] b = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>&#125;;<span class="comment">//初始化方式2</span></div><div class="line">        <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];<span class="comment">//二维数组</span></div><div class="line">        <span class="keyword">int</span> m = a.length;<span class="comment">//数组长度</span></div><div class="line">        <span class="keyword">int</span> n = c[<span class="number">0</span>].length;<span class="comment">//二维数组的列数</span></div><div class="line">        <span class="keyword">int</span> max = Integer.MAX_VALUE; <span class="comment">//MAX_VALUE = 0x7fffffff （Java语言规范规定int型为4字节）</span></div><div class="line">        <span class="keyword">int</span> min = Integer.MIN_VALUE; <span class="comment">//MIN_VALUE = 0x80000000</span></div><div class="line">        Arrays.sort(a);<span class="comment">//数组升序排序	（import java.util.Arrays;）int[]，double[]，char[]等基数据类型的数组，只提供了默认的升序排列，没有提供相应的降序排列方法。</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++) &#123;</div><div class="line">            System.out.println(c[i]);</div><div class="line">        &#125;<span class="comment">// 遍历数组输出元素</span></div><div class="line">        </div><div class="line">        <span class="comment">// List</span></div><div class="line">        <span class="comment">//List是一个接口，而ArrayList是一个类。 ArrayList继承并实现了List。 </span></div><div class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();<span class="comment">//List初始化</span></div><div class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">//ArrayList初始化</span></div><div class="line">        List&lt;List&lt;Integer&gt;&gt; list2 = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;(); <span class="comment">//而为List</span></div><div class="line">        list.add(<span class="number">0</span>);<span class="comment">//指定元素E追加到列表的末尾。此方法返回true。</span></div><div class="line">        list.add(<span class="number">0</span>, <span class="number">1</span>);<span class="comment">//方法将指定的元素E在此列表中的指定位置。此方法不返回任何值。</span></div><div class="line">        list.addAll(list1);<span class="comment">//方法会将所有指定集合中的元素添加到此列表的结尾。</span></div><div class="line">        list.get(<span class="number">0</span>);<span class="comment">//此方法返回在此列表中的指定位置的元素。</span></div><div class="line">        list.size();<span class="comment">//此方法返回此列表中的元素数。</span></div><div class="line">        list.remove(list.size() - <span class="number">1</span>);<span class="comment">//此方法返回从列表中移除的元素。</span></div><div class="line">        <span class="comment">//Collections是一个类而Collection是一个接口。</span></div><div class="line">        Collections.sort(list);<span class="comment">//方法用于指定列表按升序进行排序，根据其元素的自然顺序。</span></div><div class="line">        Collections.sort(list, Collections.reverseOrder());<span class="comment">//反序排列。</span></div><div class="line">        <span class="comment">//自定义排序。根据Collections.sort重载方法来实现。</span></div><div class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o1 - o2;<span class="comment">// 0-&gt;1</span></div><div class="line">                <span class="comment">// return o2 - o1; 1-&gt;0</span></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        <span class="comment">// Stack</span></div><div class="line">        <span class="comment">// import java.util.Stack;  </span></div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">        stack.push(<span class="number">0</span>);<span class="comment">//把项item压入栈顶，返回item参数。</span></div><div class="line">        stack.pop();<span class="comment">//返回位于堆栈顶部的元素，在这个过程中除去它。</span></div><div class="line">        stack.peek();<span class="comment">//返回到堆栈顶部的元素，但不会将其删除。</span></div><div class="line">        stack.isEmpty();<span class="comment">//栈是否为空。空返回true，否则false。</span></div><div class="line">        <span class="comment">// isEmpty() 和 empty()的区别：命名区别。</span></div><div class="line">        <span class="comment">// For example, it was named empty() in original class but was named isEmpty() of Collection interface.</span></div><div class="line">        stack.size(); <span class="comment">//栈中元素的个数。</span></div><div class="line">        stack.search(<span class="string">"code"</span>); <span class="comment">//此方法返回从1开始的位置，一个对象在栈中。栈顶位置为1。</span></div><div class="line">        </div><div class="line">        <span class="comment">// Queue add ‐‐‐‐‐‐&gt; remove, peek</span></div><div class="line">        <span class="comment">// import java.util.Queue;  import java.util.LinkedList;</span></div><div class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">        q.add(<span class="number">0</span>);<span class="comment">//增加一个元索。</span></div><div class="line">        q.remove();<span class="comment">//移除并返回队列头部的元素。</span></div><div class="line">        q.peek();<span class="comment">//返回队列头部的元素。</span></div><div class="line">        <span class="comment">//Queue使用也可以offer()来加入元素，使用poll()来获取并移出元素。</span></div><div class="line">        q.isEmpty();<span class="comment">//返回队列是否为空。</span></div><div class="line">        q.size();<span class="comment">//返回队列中元素的个数。</span></div><div class="line">        </div><div class="line">        <span class="comment">// HashMap</span></div><div class="line">        <span class="comment">// import java.util.HashMap;</span></div><div class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();<span class="comment">//初始化。</span></div><div class="line">        map.put(<span class="string">'c'</span>, <span class="number">1</span>);<span class="comment">//关联与此映射中的指定键指定的值。添加映射。</span></div><div class="line">        map.get(<span class="string">'c'</span>);<span class="comment">//返回指定键映射在此标识哈希映射，或者null，如果映射不包含此键的值。</span></div><div class="line">        <span class="keyword">if</span> (map.containsKey(<span class="string">'c'</span>)) &#123;<span class="comment">//如果此映射包含指定键的映射关系返回true。</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (map.containsValue(<span class="number">1</span>)) &#123;<span class="comment">//如果此映射一个或多个键映射到指定值返回true。</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (Character d : map.keySet()) &#123;<span class="comment">//遍历Hashmap的键集合。Set keySet()返回此映射中包含的键的set视图。</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (Integer i : map.values()) &#123;<span class="comment">//遍历Hashmap的值集合。Collection values()返回此映射中包含的值的collection视图。</span></div><div class="line">        &#125;</div><div class="line">        map.isEmpty();<span class="comment">//如果此映射不包含键 - 值映射关系返回true。</span></div><div class="line">        map.size();<span class="comment">//返回键 - 值映射关系在这个映射中的数量。</span></div><div class="line">        </div><div class="line">        <span class="comment">// HashSet</span></div><div class="line">        <span class="comment">// HashSet借助HashMap来实现的，利用HashMap中Key的唯一性，来保证HashSet中不出现重复值。</span></div><div class="line">        <span class="comment">// HashMap中的Key是根据对象的hashCode() 和 euqals()来判断是否唯一的。</span></div><div class="line">        <span class="comment">// import java.util.HashSet;</span></div><div class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();<span class="comment">//初始化。</span></div><div class="line">        set.add(<span class="number">0</span>);<span class="comment">//将指定的元素添加到此集合，如果它是不存在的。</span></div><div class="line">        set.remove(<span class="number">0</span>);<span class="comment">//从集合中删除指定的元素（如果存在）。</span></div><div class="line">        <span class="keyword">if</span> (set.contains(<span class="number">0</span>)) &#123;<span class="comment">//如果此set包含指定的元素，则返回true。</span></div><div class="line">        &#125;</div><div class="line">        set.isEmpty();<span class="comment">//返回true如果此set不包含任何元素。</span></div><div class="line">        set.size();<span class="comment">//返回元素的数目（它的基数）。</span></div><div class="line">        </div><div class="line">        <span class="comment">// mini heap</span></div><div class="line">        <span class="comment">// import java.util.PriorityQueue;</span></div><div class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();<span class="comment">//初始化。</span></div><div class="line">        pq.add(<span class="number">0</span>);<span class="comment">//该方法调用返回true(所指定的Collection.add(E))</span></div><div class="line">        pq.offer(<span class="number">0</span>);<span class="comment">//该方法调用返回true(所指定的Queue.offer(E))</span></div><div class="line">        pq.remove();<span class="comment">//该方法调用返回true，如果此队列由于调用而更改的结果。</span></div><div class="line">        pq.peek();<span class="comment">//在方法调用返回此队列的头部，或null，如果此队列为空。但它不会将其删除。</span></div><div class="line">        pq.poll();<span class="comment">//方法用于检索并移除此队列的头，则返回null，如果此队列为空。	</span></div><div class="line">        pq.isEmpty();<span class="comment">//判读是否为空。</span></div><div class="line">        pq.size();<span class="comment">//在方法调用返回的元素在此集合数</span></div><div class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="阿里巴巴Java开发规范"><a href="#阿里巴巴Java开发规范" class="headerlink" title="阿里巴巴Java开发规范"></a>阿里巴巴Java开发规范</h2><p><a href="http://orj5hqpmw.bkt.clouddn.com/4ce9918d7f5a082177a8a2741d0ab3ce.pdf" target="_blank" rel="external">阿里巴巴Java开发规范</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;【解析】Java-Skills-For-Interview&quot;&gt;&lt;a href=&quot;#【解析】Java-Skills-For-Interview&quot; class=&quot;hea
    
    </summary>
    
      <category term="开发笔记" scheme="http://lincentma.men/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://lincentma.men/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历那点事</title>
    <link href="http://lincentma.men/binary_tree_traversal.html"/>
    <id>http://lincentma.men/binary_tree_traversal.html</id>
    <published>2017-06-24T15:34:33.000Z</published>
    <updated>2017-06-24T16:06:53.106Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="二叉树遍历那点事"><a href="#二叉树遍历那点事" class="headerlink" title="二叉树遍历那点事"></a>二叉树遍历那点事</h1><blockquote>
<p>刷leetcode，碰见二叉树，看了一下午二叉树遍历，还在茫然着，写出来就明白了。好脑子不如烂笔头。</p>
</blockquote>
<h2 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Definition for binary tree</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</div><div class="line">    <span class="keyword">private</span> BinaryTreeNode left;</div><div class="line">    <span class="keyword">private</span> BinaryTreeNode right;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">(<span class="keyword">int</span> data, BinaryTreeNode left, BinaryTreeNode right)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">        <span class="keyword">this</span>.left = left;</div><div class="line">        <span class="keyword">this</span>.right = right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> left;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(BinaryTreeNode left)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.left = left;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(BinaryTreeNode right)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.right = right;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数组转换为二叉树"><a href="#数组转换为二叉树" class="headerlink" title="数组转换为二叉树"></a>数组转换为二叉树</h2><ul>
<li>二叉树上的元素存放位置在数组中是固定的。</li>
<li>如果树的i位置（从0开始按层编号）有元素，就放在数组的i号位置，没有元素，数组对应的位置就空着。i的左右子树的编号为2i+1和2i+2。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</div><div class="line"></div><div class="line">    BinaryTreeNode root;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> value;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> paraValue)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.value = paraValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        root = createBinaryTreeByArray(array, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">createBinaryTreeByArray</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        TreeNode tn = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (index &lt; array.length) &#123;</div><div class="line">            <span class="keyword">int</span> value = array[index];</div><div class="line">            tn = <span class="keyword">new</span> TreeNode(value);</div><div class="line">            tn.left = createBinaryTreeByArray(array, <span class="number">2</span> * index + <span class="number">1</span>);</div><div class="line">            tn.right = createBinaryTreeByArray(array, <span class="number">2</span> * index + <span class="number">2</span>);</div><div class="line">            <span class="keyword">return</span> tn;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> tn;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="递归与非递归"><a href="#递归与非递归" class="headerlink" title="递归与非递归"></a>递归与非递归</h2><p>一言以蔽之，非递归比递归难太多。</p>
<p>前序递归遍历算法：访问根结点–&gt;递归遍历根结点的左子树–&gt;递归遍历根结点的右子树<br>中序递归遍历算法：递归遍历根结点的左子树–&gt;访问根结点–&gt;递归遍历根结点的右子树<br>后序递归遍历算法：递归遍历根结点的左子树–&gt;递归遍历根结点的右子树–&gt;访问根结点</p>
<p>明白了思路，递归代码几行就能搞定了。</p>
<p>但是问题来了：</p>
<p>摘自知乎：</p>
<ul>
<li>递归是函数自身调用自身，涉及到保护现场（变量入栈，记录地址等），时间和空间开销较大，而这操作都是在栈上，调用层级太多很容易溢出。</li>
<li>迭代（非递归）虽然也是用栈，可是这个栈和递归栈可不是一个概念，这个栈完全可以在堆上开辟，空间更大，不容易溢出。迭代也不涉及函数调用，效率也更高。</li>
</ul>
<p>如何写出非递归的遍历呢？如何把手写遍历结果的过程用代码表达出来。</p>
<p>非递归方法需要借助栈</p>
<h2 id="前序二叉树"><a href="#前序二叉树" class="headerlink" title="前序二叉树"></a>前序二叉树</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>前序遍历的递归定义：先根节点，后左子树，再右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</div><div class="line">    System.out.print(root.val);</div><div class="line">    preOrder(root.getLeft());</div><div class="line">    preOrder(root.getRight());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><p>在手写结果的过程中，我们可以总结出以下规律：</p>
<ul>
<li>画出二叉树的图，输出顺序都是沿左下方向的直线，输出顺序LIFO，后进先出，满足栈的定义。</li>
<li>借助栈来保存节点，通过节点来打印右子树的数据。</li>
<li>只有入栈时才输出数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNonRecursive</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</div><div class="line">  Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="comment">//首先从根节点开始遍历所有的左子树，并输出节点数据</span></div><div class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</div><div class="line">      System.out.print(root.getData() + <span class="string">"\t"</span>);</div><div class="line">      stack.push(root);</div><div class="line">      root = root.getLeft();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//循环终止条件：栈容量为0，说明右子树以及遍历完全，跳出。</span></div><div class="line">    <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">break</span>;</div><div class="line">    <span class="comment">//当上面的while循环完成后，也就是左子树输出完成，栈弹出元素，也就是离得最近的有右子树的节点。</span></div><div class="line">    root = stack.pop();</div><div class="line">    <span class="comment">//返回循环，以该节点作为新的root循环输出。</span></div><div class="line">    root = root.getRight();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="中序二叉树"><a href="#中序二叉树" class="headerlink" title="中序二叉树"></a>中序二叉树</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>中序遍历的递归定义：先左子树，后根节点，再右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</div><div class="line">        inorder(root.nodeLeft);</div><div class="line">        System.out.print(root.val);</div><div class="line">        inorder(root.nodeRight);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h3><p>在手写结果的过程中，我们可以总结出以下规律：</p>
<ul>
<li>与先序类似，只不过输出数据的时机发生了改变。</li>
<li>出栈的时候输出数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderNonRecursive</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</div><div class="line">  Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="comment">//遍历左子树，并保存到栈中</span></div><div class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</div><div class="line">      stack.push(root);</div><div class="line">      root = root.getLeft();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遍历跳出条件</span></div><div class="line">    <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">break</span>;</div><div class="line">    <span class="comment">//当上面的while循环完成后，也就是左子树输出完成，栈弹出元素，也就是离得最近的有右子树的节点。</span></div><div class="line">    root = stack.pop();</div><div class="line">    <span class="comment">//根据中序遍历的输出顺序，先输出左子树的节点的值</span></div><div class="line">    System.out.print(root.getData() + <span class="string">"\t"</span>);</div><div class="line">    <span class="comment">//以最左下的节点为例，它的右节点为null，那么再次循环时，就会跳过遍历左子树的循环，栈出栈的节点为它的父节点，也就是根节点，输出其值，再转为其右子树，完成中序遍历的输出顺序。</span></div><div class="line">    root = root.getRight();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="后序二叉树"><a href="#后序二叉树" class="headerlink" title="后序二叉树"></a>后序二叉树</h2><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>后序遍历的递归定义：先左子树，后右子树，再根节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</div><div class="line">        postOrder(root.nodeLeft);</div><div class="line">        postOrder(root.nodeRight);</div><div class="line">        System.out.print(root.val);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="非递归-2"><a href="#非递归-2" class="headerlink" title="非递归"></a>非递归</h3><p>在手写结果的过程中，我们可以总结出以下规律：</p>
<ul>
<li>与前面区别在于，判读出栈时，要考虑该节点是否在之前已经访问过。</li>
<li>在stack中，最后添加的数据需要通过lastElement方法获取。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderNonRecursive</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</div><div class="line">    Stack&lt;BinaryTreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</div><div class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">        <span class="comment">//遍历左子树，并保存到栈中</span></div><div class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(root);</div><div class="line">            root=root.getLeft();</div><div class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//此时，当遍历到最左下的叶节点时，它的左子树是null。</span></div><div class="line">            <span class="comment">//后序遍历的顺序</span></div><div class="line">            <span class="keyword">if</span>(stack.isEmpty()) <span class="keyword">return</span>; <span class="comment">// 遍历终止条件1：栈空</span></div><div class="line">          </div><div class="line">            <span class="comment">//栈中最近添加的元素的右子树为空则弹出并输出该元素</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>==stack.lastElement().getRight())&#123;</div><div class="line">                root=stack.pop();</div><div class="line">                <span class="comment">//输出最开始左子树的叶节点，也就是遍历顺序中的左子树（以及代入的右子树值）</span></div><div class="line">                System.out.print(root.getData()+<span class="string">"\t"</span>);</div><div class="line">                <span class="comment">//while循环终止条件1：出栈后的最近添加的元素则为父节点的右子树与之前出栈的元素相等</span></div><div class="line">                <span class="keyword">while</span>(root==stack.lastElement().getRight())&#123;</div><div class="line">                    <span class="comment">//root（右子树遍历完成）与此时栈中的最近添加的元素（父节点）的右子树相等，那么说明lastElement为根节点</span></div><div class="line">                    <span class="comment">//输出根节点</span></div><div class="line">                    System.out.print(stack.lastElement().getData()+<span class="string">"\t"</span>);</div><div class="line">                    <span class="comment">//出栈（右子树的叶节点）</span></div><div class="line">                    root=stack.pop();</div><div class="line">                    <span class="comment">// while终止条件2：栈空</span></div><div class="line">                    <span class="keyword">if</span>(stack.isEmpty())&#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//栈不空，则root赋值为栈最近添加元素的右子树，开始从右子树继续遍历</span></div><div class="line">            <span class="keyword">if</span>(!stack.isEmpty())</div><div class="line">                root=stack.lastElement().getRight();</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="comment">//栈空，赋值为null，确保进入遍历结束条件判断的地方</span></div><div class="line">                root=<span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PS：感觉有点绕，stack.lastElement()这个也可以用pre节点来代替，这样可能更便于理解。</p>
<h2 id="非递归的统一化"><a href="#非递归的统一化" class="headerlink" title="非递归的统一化"></a>非递归的统一化</h2><p>非递归是否也可以像递归一样，只用修改语句的位置，实现不同方式的遍历呢？</p>
<p>答案是肯定的，大牛就是多。</p>
<ul>
<li><p>统一三种更简单的非递归遍历方法的基本思想：<strong>有重合元素的局部有序一定能导致整体有序</strong>。</p>
<p><img src="http://zisong.qiniudn.com/algorithm%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.png" alt="Alt text"></p>
</li>
</ul>
<ul>
<li>三种非递归遍历唯一不同的就是局部入栈的三行代码的先后顺序。所以不管是<code>根-&gt;左-&gt;右</code>,<code>左-&gt;根-&gt;右</code>,<code>左-&gt;右-&gt;根</code>,甚至是<code>根-&gt;右-&gt;左</code>,<code>右-&gt;根-&gt;左</code>,<code>右-&gt;左-&gt;根</code>定义的新顺序，算法实现都无变化，除了改变局部入栈顺序。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderTraversalNew</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">stack</span>&lt; pair&lt;TreeNode *, <span class="keyword">bool</span>&gt; &gt; s;</div><div class="line">    s.push(make_pair(root, <span class="literal">false</span>));</div><div class="line">    <span class="keyword">bool</span> visited;</div><div class="line">    <span class="keyword">while</span>(!s.empty())</div><div class="line">    &#123;</div><div class="line">        root = s.top().first;</div><div class="line">        visited = s.top().second;</div><div class="line">        s.pop();</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span>(visited)</div><div class="line">        &#123;</div><div class="line">            path.push_back(root-&gt;val);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            s.push(make_pair(root, <span class="literal">true</span>));</div><div class="line">            s.push(make_pair(root-&gt;right, <span class="literal">false</span>));</div><div class="line">            s.push(make_pair(root-&gt;left, <span class="literal">false</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PS: 有时间改写成Java版本的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2>]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;二叉树遍历那点事&quot;&gt;&lt;a href=&quot;#二叉树遍历那点事&quot; class=&quot;headerlink&quot; title=&quot;二叉树遍历那点事&quot;&gt;&lt;/a&gt;二叉树遍历那点事&lt;/h1
    
    </summary>
    
      <category term="开发笔记" scheme="http://lincentma.men/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="binary tree" scheme="http://lincentma.men/tags/binary-tree/"/>
    
      <category term="recursive" scheme="http://lincentma.men/tags/recursive/"/>
    
      <category term="iterate" scheme="http://lincentma.men/tags/iterate/"/>
    
  </entry>
  
  <entry>
    <title>Java、Python与PHP的虚拟机异同</title>
    <link href="http://lincentma.men/program_language_virtual_machine.html"/>
    <id>http://lincentma.men/program_language_virtual_machine.html</id>
    <published>2017-06-23T15:59:24.000Z</published>
    <updated>2017-06-23T16:07:27.662Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="Java-JVM"><a href="#Java-JVM" class="headerlink" title="Java-JVM"></a>Java-JVM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>JDK(Java Development Kit) 是 Java 语言的软件开发工具包（SDK）。JDK 物理存在，是 programming tools、JRE 和 JVM 的一个集合</li>
<li>JRE（Java Runtime Environment）Java 运行时环境，JRE 物理存在，主要由Java API 和 JVM 组成，提供了用于执行 java 应用程序最低要求的环境。</li>
<li>JVM(Java Virtual Machine) 是一种软件实现，执行像物理机程序的机器（即电脑）。JVM 通过执行 Java bytecode 可以使 java 代码在不改变的情况下运行在各种硬件之上。JVM是基于栈的。</li>
</ul>
<h3 id="JVM-执行"><a href="#JVM-执行" class="headerlink" title="JVM 执行"></a>JVM 执行</h3><ul>
<li>加载代码</li>
<li>验证代码</li>
<li>执行代码</li>
<li>提供运行环境</li>
</ul>
<h3 id="JVM-生命周期"><a href="#JVM-生命周期" class="headerlink" title="JVM 生命周期"></a>JVM 生命周期</h3><ul>
<li>启动：任何一个拥有main函数的class都可以作为JVM实例运行的起点</li>
<li>运行：main函数为起点，程序中的其他线程均有它启动，包括daemon守护线程和non-daemon普通线程。daemon是JVM自己使用的线程比如GC线程，main方法的初始线程是non-daemon。</li>
<li>消亡：所有线程终止时，JVM实例结束生命。</li>
</ul>
<h3 id="JVM结构及内存模型"><a href="#JVM结构及内存模型" class="headerlink" title="JVM结构及内存模型"></a>JVM结构及内存模型</h3><p><img src="http://upload-images.jianshu.io/upload_images/634730-089a64921220b40d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>名词解释：</p>
<ul>
<li>Class Loader：类加载器负责加载程序中的类型（类和接口），并赋予唯一的名字。为什么使用双亲委托模型——ClassLoader 隔离问题。</li>
<li>Execution Engine：执行引擎。执行引擎以指令为单位读取 Java 字节码。它就像一个 CPU 一样，一条一条地执行机器指令。</li>
<li>Runtime Data Areas:：运行时数据区。</li>
<li>PS：想起面试的时候被问到过这样的问题：你在使用java过程中是否遇到过OOM的情况？当时一阵懵比。现在总结下：<ul>
<li>PC寄存器（PC Register）是唯一一个在 Java 虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</li>
<li>JVM 栈（Java Virtual Machine Stack）：如果JVM Stack可以动态扩展，但是在尝试扩展时无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的虚拟机栈时抛出。</li>
<li>本地方法栈(Native method stack)：如果本地方法栈可以动态扩展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的本地方法栈，那Java虚拟机将会抛出一个OutOfMemoryError异常。</li>
<li>方法区(Method area)：如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。</li>
<li>运行时常量池(Runtime constant pool)：当创建类和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内存空间后就会抛出OutOfMemoryError</li>
<li>堆(Heap)：如果实际所需的堆超过了自动内存管理系统能提供的最大容量时抛出。</li>
<li>总结一下就是无法申请到足够的内存以及超出最大容量两方面原因</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p><img src="http://upload-images.jianshu.io/upload_images/2184951-327156d44f4f2446.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>新生代由 Eden 与 Survivor Space（S0，S1）构成，大小通过-Xmn参数指定，Eden 与 Survivor Space 的内存大小比例默认为8:1，可以通过-XX:SurvivorRatio 参数指定，比如新生代为10M 时，Eden分配8M，S0和S1各分配1M。</p>
<p>Eden：希腊语，意思为伊甸园，在圣经中，伊甸园含有乐园的意思，根据《旧约·创世纪》记载，上帝耶和华照自己的形像造了第一个男人亚当，再用亚当的一个肋骨创造了一个女人夏娃，并安置他们住在了伊甸园。</p>
<p>大多数情况下，对象在Eden中分配，当Eden没有足够空间时，会触发一次Minor GC，虚拟机提供了-XX:+PrintGCDetails参数，告诉虚拟机在发生垃圾回收时打印内存回收日志。</p>
<p>Survivor：意思为幸存者，是新生代和老年代的缓冲区域。<br>当新生代发生GC（Minor GC）时，会将存活的对象移动到S0内存区域，并清空Eden区域，当再次发生Minor GC时，将Eden和S0中存活的对象移动到S1内存区域。</p>
<p>存活对象会反复在S0和S1之间移动，当对象从Eden移动到Survivor或者在Survivor之间移动时，对象的GC年龄自动累加，当GC年龄超过默认阈值15时，会将该对象移动到老年代，可以通过参数-XX:MaxTenuringThreshold 对GC年龄的阈值进行设置。</p>
</li>
</ul>
<ul>
<li><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>老年代的空间大小即-Xmx 与-Xmn 两个参数之差，用于存放经过几次Minor GC之后依旧存活的对象。当老年代的空间不足时，会触发Major GC/Full GC，速度一般比Minor GC慢10倍以上。</p>
</li>
</ul>
<ul>
<li><h4 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h4><p>在JDK8之前的HotSpot实现中，类的元数据如方法数据、方法信息（字节码，栈和变量大小）、运行时常量池、已确定的符号引用和虚方法表等被保存在永久代中，32位默认永久代的大小为64M，64位默认为85M，可以通过参数-XX:MaxPermSize进行设置，一旦类的元数据超过了永久代大小，就会抛出OOM异常。</p>
<p>虚拟机团队在JDK8的HotSpot中，把永久代从Java堆中移除了，并把类的元数据直接保存在本地内存区域（堆外内存），称之为元空间。</p>
<p>这样做有什么好处？<br>有经验的同学会发现，对永久代的调优过程非常困难，永久代的大小很难确定，其中涉及到太多因素，如类的总数、常量池大小和方法数量等，而且永久代的数据可能会随着每一次Full GC而发生移动。</p>
<p>而在JDK8中，类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用内存空间，可以避免永久代的内存溢出问题，不过需要监控内存的消耗情况，一旦发生内存泄漏，会占用大量的本地内存。</p>
</li>
</ul>
<h4 id="判断垃圾回收"><a href="#判断垃圾回收" class="headerlink" title="判断垃圾回收"></a>判断垃圾回收</h4><ol>
<li><p>引用计数法：在对象上添加一个引用计数器，每当有一个对象引用它时，计数器加1，当使用完该对象时，计数器减1，计数器值为0的对象表示不可能再被使用。引用计数法实现简单，判定高效，但不能解决对象之间相互引用的问题。</p>
</li>
<li><p>可达性分析法：通过一系列称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，搜索路径称为 “引用链”，以下对象可作为GC Roots：</p>
<ul>
<li>本地变量表中引用的对象</li>
<li>方法区中静态变量引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>Native方法引用的对象</li>
</ul>
<p>当一个对象到 GC Roots 没有任何引用链时，意味着该对象可以被回收。</p>
</li>
</ol>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ol>
<li>标记-清除算法<br>对待回收的对象进行标记。<br>算法缺点：效率问题，标记和清除过程效率都很低；空间问题，收集之后会产生大量的内存碎片，不利于大对象的分配。</li>
<li>复制算法<br>复制算法将可用内存划分成大小相等的两块A和B，每次只使用其中一块，当A的内存用完了，就把存活的对象复制到B，并清空A的内存，不仅提高了标记的效率，因为只需要标记存活的对象，同时也避免了内存碎片的问题，代价是可用内存缩小为原来的一半。</li>
<li>标记-整理算法<br>在老年代中，对象存活率较高，复制算法的效率很低。在标记-整理算法中，标记出所有存活的对象，并移动到一端，然后直接清理边界以外的内存。</li>
</ol>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><p>[清蒸 JVM （一）]: <a href="http://www.importnew.com/23658.html" target="_blank" rel="external">http://www.importnew.com/23658.html</a></p>
</li>
<li><p>[Java GC的那些事（上）]: <a href="http://www.importnew.com/23633.html" target="_blank" rel="external">http://www.importnew.com/23633.html</a></p>
</li>
<li><p>[Java GC的那些事（下）]: <a href="http://www.importnew.com/23640.html" target="_blank" rel="external">http://www.importnew.com/23640.html</a></p>
</li>
</ol>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="PVM"><a href="#PVM" class="headerlink" title="PVM"></a>PVM</h3><p>PVM是Python的运行引擎。他通常表现为python系统的一部分。并且他是实际运行脚本的组件。</p>
<p>编译器：将源码编译成运行在虚拟机上执行的opcode(pyc文件)，pyc文件是在python虚拟机上执行的一种跨平台字节码。</p>
<p>运行时：虚拟机解释器把opcode(pyc文件)解释成具体机器的机器码，执行。</p>
<h3 id="JVM与PVM"><a href="#JVM与PVM" class="headerlink" title="JVM与PVM"></a>JVM与PVM</h3><ul>
<li>Java代码从源程序到执行，要经过的过程是：编译器(javac)把源代码转化为字节码，然后解释器（Java.exe）把字节码转换为计算机理解的机器码来执行。其中编译器和解释器都是Java虚拟机（JVM）的一部分，由于针对不同的硬件与OS，Java解释器有所不同，因此可以实现“一次编译、到处执行”。所以JVM是Java跨平台特性的关键所在。</li>
<li>对于Python，其源代码到执行也要经过如下过程：源代码—&gt;字节码—&gt;机器码。与Java不同的是，Python使用的虚拟机是基于其他语言实现的，比如我们一般使用的Python实际为Cpython，也就是其虚拟机由C实现，这个虚拟机负责把Python源码编译为字节码，再解释执行。另外，还有Jypython、Ironpython等。</li>
</ul>
<h2 id="PHP-Zend-amp-HHVM"><a href="#PHP-Zend-amp-HHVM" class="headerlink" title="PHP-Zend&amp;HHVM"></a>PHP-Zend&amp;HHVM</h2><p><img src="http://img.it-home.org/data/attachment/forum/2016pic3/20141226102950_924.jpg" alt=""></p>
<ul>
<li>Zend引擎默认做法，是先编译为opcode，然后再逐条执行，通常每条指令对应的是C语言级别的函数。如果我们产生大量重复的opcode（纯PHP写的代码和函数），对应的则是Zend多次逐条执行这些C代码。</li>
<li>HHVM生成和执行PHP的中间字节码（HHVM生成自己格式的中间字节码），执行时通过JIT（Just In Time，即时编译是种软件优化技术，指在运行时才会去编译字节码为机器码）转为机器码执行。JIT将大量重复执行的字节码在运行的时候编译为机器码，达到提高执行效率的目的。通常，触发JIT的条件是代码或者函数被多次重复调用。</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>时间匆忙，囫囵吞枣，努力完善。</p>
<p>后端开发离不开Java，python和php，深入学习原理，比较异同，最佳使用。</p>
<p>2017.06.23</p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Java-JVM&quot;&gt;&lt;a href=&quot;#Java-JVM&quot; class=&quot;headerlink&quot; title=&quot;Java-JVM&quot;&gt;&lt;/a&gt;Java-JVM&lt;/h2
    
    </summary>
    
      <category term="开发笔记" scheme="http://lincentma.men/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="python" scheme="http://lincentma.men/tags/python/"/>
    
      <category term="java" scheme="http://lincentma.men/tags/java/"/>
    
      <category term="virtual machine" scheme="http://lincentma.men/tags/virtual-machine/"/>
    
      <category term="php" scheme="http://lincentma.men/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>几个小问题的解答</title>
    <link href="http://lincentma.men/learn_for_some_questions.html"/>
    <id>http://lincentma.men/learn_for_some_questions.html</id>
    <published>2017-06-22T15:25:38.000Z</published>
    <updated>2017-06-22T15:43:43.699Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote>
<p>她给我提了一下几个问题，自己一眼看上去觉得简单，但是说不出来所以然，犯了眼高手低的毛病，记录自省。</p>
</blockquote>
<ul>
<li>[x] 一共10级楼梯，每次可以走一步或两步，求一共多少种走法。</li>
<li>[x] 一个细胞，一个小时分裂一次，生命周期是3小时，求n小时后容器内，有多少细胞。</li>
<li>[x] 斐波那契数列的实现。</li>
<li>[x] 递归算法的核心</li>
</ul>
<h1 id="Question1—走楼梯"><a href="#Question1—走楼梯" class="headerlink" title="Question1—走楼梯"></a>Question1—走楼梯</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>楼梯问题，一眼看上去，应该是一个递归问题跑不了了。</p>
<p>那么该如何递归，找到其中的规律呢？</p>
<p><strong><em>逆向思考。</em></strong></p>
<p>要想走到M(M=10)级,可以分为2种情况。 </p>
<ol>
<li>从m-2级迈两步 </li>
<li>从m-1级迈一步 </li>
</ol>
<p>那么对于m-2和m-1的情况也是各自分为两种，以此类推。</p>
<p>那么走法的和就是m-2的走法和m-1的走法之和。</p>
<p>那么递归到最基本的（当前人在第0阶台阶）</p>
<p>第0阶台阶：0</p>
<p>第1阶台阶：1</p>
<p>第2阶台阶：2（1+1或者2）</p>
<p>得到公式，也就是斐波那契数列。<br>$$<br>f(n)=f(n-1)+f(n-2)<br>$$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ml on 2017/6/21.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">taijie</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countNumber</span><span class="params">(<span class="keyword">int</span> stepsNum)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (stepsNum == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (stepsNum == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stepsNum == <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stepsNum &gt; <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span>  countNumber(stepsNum - <span class="number">2</span>) + countNumber(stepsNum - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startMili=System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</div><div class="line">            System.out.println(<span class="string">"楼梯台阶数:"</span> + i + <span class="string">", 走法有:"</span> + countNumber(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> endMili=System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"耗时:"</span> + String.valueOf(endMili - startMili) + <span class="string">"毫秒"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">楼梯台阶数:0, 走法有:0</div><div class="line">楼梯台阶数:1, 走法有:1</div><div class="line">楼梯台阶数:2, 走法有:2</div><div class="line">楼梯台阶数:3, 走法有:3</div><div class="line">楼梯台阶数:4, 走法有:5</div><div class="line">楼梯台阶数:5, 走法有:8</div><div class="line">楼梯台阶数:6, 走法有:13</div><div class="line">楼梯台阶数:7, 走法有:21</div><div class="line">楼梯台阶数:8, 走法有:34</div><div class="line">楼梯台阶数:9, 走法有:55</div><div class="line">楼梯台阶数:10, 走法有:89</div><div class="line">耗时:0毫秒</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure>
<h2 id="其他的方法"><a href="#其他的方法" class="headerlink" title="其他的方法"></a>其他的方法</h2><p>该算法的运算时间是指数级增长的，还有其他方法吗？</p>
<p>动态规划？</p>
<p>其实动态规划（dynamicprogramming）是通过组合子问题而解决整个问题的解。乍一看和递归的写法差不多，都是相加。但是递归式是包含了许多重复计算的步骤，对应台阶就是每一个台阶计算前面都是重复的。动态规划<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="external">算法</a>对每个子问题只求解一次，将其结果保存起来，从而避免每次遇到各个子问题时重新计算答案。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ml on 2017/6/21.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">taijie</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> n;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//注意坐标起始点的区别</span></div><div class="line">        <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">        r[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">        r[<span class="number">2</span>] = <span class="number">2</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</div><div class="line">            r[i] = r[i-<span class="number">1</span>] + r[i-<span class="number">2</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> r[n];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startMili=System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</div><div class="line">            System.out.println(<span class="string">"楼梯台阶数:"</span> + i + <span class="string">", 走法有:"</span> + climbStairs(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> endMili=System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"耗时:"</span> + String.valueOf(endMili - startMili) + <span class="string">"毫秒"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">楼梯台阶数:0, 走法有:0</div><div class="line">楼梯台阶数:1, 走法有:1</div><div class="line">楼梯台阶数:2, 走法有:2</div><div class="line">楼梯台阶数:3, 走法有:3</div><div class="line">楼梯台阶数:4, 走法有:5</div><div class="line">楼梯台阶数:5, 走法有:8</div><div class="line">楼梯台阶数:6, 走法有:13</div><div class="line">楼梯台阶数:7, 走法有:21</div><div class="line">楼梯台阶数:8, 走法有:34</div><div class="line">楼梯台阶数:9, 走法有:55</div><div class="line">楼梯台阶数:10, 走法有:89</div><div class="line">耗时:0毫秒</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure>
<p>之前数学课本上如何思考的？</p>
<ol>
<li>先求出走完台阶需要几步？</li>
<li>再求出总步数中，走一个台阶是几步，走两个台阶式几步，不同种类为排列组合计算</li>
</ol>
<h2 id="类似问题"><a href="#类似问题" class="headerlink" title="类似问题"></a>类似问题</h2><p>再看一个硬币的凑法：</p>
<blockquote>
<p>用1分、2分和5分的硬币凑成1元，共有多少种不同的凑法？（华为机试题）</p>
</blockquote>
<p>它和走楼梯的区别在于，楼梯不同顺序是不同的走法，硬币则与顺序无关，程序可用穷举法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">coin</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getKinds</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> num=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">21</span>; i++) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">100</span>-<span class="number">5</span>*i; j++) &#123;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">100</span>-<span class="number">5</span>*i-<span class="number">2</span>*j; k++) &#123;</div><div class="line">					<span class="keyword">if</span>(<span class="number">5</span>*i+<span class="number">2</span>*j+k==<span class="number">100</span>)&#123;</div><div class="line">						num++;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> num;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(getKinds());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么这个问题可以推广为一般性问题吗？M阶，一次走a阶或者b阶或者。。。，求不同走法。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><h1 id="Question2—细胞分裂"><a href="#Question2—细胞分裂" class="headerlink" title="Question2—细胞分裂"></a>Question2—细胞分裂</h1><h2 id="非递归思路"><a href="#非递归思路" class="headerlink" title="非递归思路"></a>非递归思路</h2><p>乍一看，关键是如何处理生命周期是3小时。如何在分裂的同时提出死亡的细胞。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ml on 2017/6/22.</div><div class="line"> * 思路：每个细胞定义为一维数组的元素，元素的值为细胞的生存时间，每分裂一次，在数组末尾添加新的元素，初始值为0，同时原来的元素值加1</div><div class="line"> * 当元素的值为3时，将该元素剔除</div><div class="line"> * 最后返回该数组的大小</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xibao</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cellNum2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; cell = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="comment">//定义cellnum</span></div><div class="line">        <span class="keyword">int</span> cellnum = <span class="number">0</span>;</div><div class="line">        <span class="comment">//加入初始细胞</span></div><div class="line">        cell.add(<span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="comment">//记录当前数组大小（剔除完成后的数组）</span></div><div class="line">            <span class="keyword">int</span> size = cell.size();</div><div class="line">            <span class="comment">//计算分裂后新的数组的大小</span></div><div class="line">            cellnum = <span class="number">2</span> * cell.size();</div><div class="line">            <span class="comment">//原有生存时间加1</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cell.size(); j++) &#123;</div><div class="line">                cell.set(j, cell.get(j) + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//遍历剔除元素值为3 PS：ArrayList中遍历可以删除的只有迭代器</span></div><div class="line">            Iterator&lt;Integer&gt; it = cell.iterator();</div><div class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">                <span class="keyword">if</span> (it.next().equals(<span class="number">3</span>))</div><div class="line">                    it.remove();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//在数组末尾添加新的元素</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = size; j &lt; cellnum; j++) &#123;</div><div class="line">                cell.add(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cell.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cellNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">        HashMap&lt;Integer, Integer&gt; cell = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> cellnum = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">            cellnum *= <span class="number">2</span>;</div><div class="line">            <span class="keyword">int</span> size = cell.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = size; j &lt; cellnum; j++) &#123;</div><div class="line">                cell.put(j, <span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">            Iterator&lt;HashMap.Entry&lt;Integer, Integer&gt;&gt; iter = cell.entrySet().iterator();</div><div class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">                Map.Entry entry = iter.next();</div><div class="line">                <span class="keyword">int</span> key = (<span class="keyword">int</span>) entry.getKey();</div><div class="line">                <span class="keyword">int</span> val = (<span class="keyword">int</span>) entry.getValue();</div><div class="line">                <span class="keyword">if</span> (key &lt; size) &#123;</div><div class="line">                    cell.put(key, val + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cell.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startMili = System.currentTimeMillis();</div><div class="line">        <span class="keyword">int</span> n = <span class="number">6</span>;</div><div class="line">        System.out.println(n + <span class="string">"小时后容器细胞:"</span> + cellNum2(n) + <span class="string">"个"</span>);</div><div class="line">        <span class="keyword">long</span> endMili = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"耗时:"</span> + String.valueOf(endMili - startMili) + <span class="string">"毫秒"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">3小时后容器细胞:7个</div><div class="line">耗时:0毫秒</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure>
<h3 id="关于ArrayList"><a href="#关于ArrayList" class="headerlink" title="关于ArrayList"></a>关于ArrayList</h3><ol>
<li>迭代器是作为当前集合的内部类实现的，当迭代器创建的时候保持了当前集合的引用；</li>
<li>集合内部维护一个字段叫modiCount，用来记录集合被修改的次数，比如add，remove，set等都会使该字段递增；</li>
<li>迭代器内部也维护着当前集合的修改次数的字段，迭代器创建时该字段初始化为集合的modiCount值</li>
<li>当每一次迭代时，迭代器会比较迭代器维护的字段和modiCount的值是否相等，如果不相等就抛ConcurrentModifiedException异常；</li>
<li>当然，如果用迭代器调用remove方法，那么集合和迭代器维护的修改字数都会递增，以保持两个状态的一致。</li>
</ol>
<p>这就是为什么你只可以用迭代器来删除，而不能用其他方式来修改集合。</p>
<h2 id="这类问题如何递归？"><a href="#这类问题如何递归？" class="headerlink" title="这类问题如何递归？"></a>这类问题如何递归？</h2><p>公式法：<br>$$<br>n=t/a<del>~</del><del>~</del>~~y=2^n<br>$$<br>但是这个只适用于最简单的没有任何附加状态条件的情况。</p>
<p>递归如何来分析？</p>
<p>细胞的生存周期是3个小时，那我们就可以把细胞在题目中状态分为以下几个状态：</p>
<ul>
<li>a：刚分裂态——1</li>
<li>b：分裂1小时态——a分裂出b和a</li>
<li>c：分裂2小时态——b分裂出c和a</li>
<li>d：分裂3小时态——死亡（停止分裂）</li>
</ul>
<p>那么，我们就可以根据细胞状态设定函数。分析每一个状态的来源是哪里即可。<br>$$<br>a(t)=a(t-1)+b(t-1)+c(t-1)\\b(t)=a(t-1)\\c(t)=b(t-1)\\d(t)=d(t-1)+c(t-1)<br>$$<br>容器中存活的细胞数目就是a、b、c三种状态数量的总和。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ml on 2017/6/22.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xibao</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aStatus</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (t == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> aStatus(t - <span class="number">1</span>) + bStatus(t - <span class="number">1</span>) + cStatus(t - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bStatus</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (t == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> aStatus(t-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cStatus</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (t == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bStatus(t-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dStatus</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (t == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (t == <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dStatus(t-<span class="number">1</span>) + cStatus(t-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startMili = System.currentTimeMillis();</div><div class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</div><div class="line">        <span class="keyword">int</span> res = aStatus(n) + bStatus(n) + cStatus(n);</div><div class="line">        System.out.println(n + <span class="string">"小时后容器细胞:"</span> + res + <span class="string">"个"</span>);</div><div class="line">        <span class="keyword">long</span> endMili = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"耗时:"</span> + String.valueOf(endMili - startMili) + <span class="string">"毫秒"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">3小时后容器细胞:7个</div><div class="line">耗时:0毫秒</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure>
<h2 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h2><h1 id="Question3—Fibonacci数列"><a href="#Question3—Fibonacci数列" class="headerlink" title="Question3—Fibonacci数列"></a>Question3—Fibonacci数列</h1><p>经典问题：求Fibonacci数列前n项。<br>$$<br>{an}：a1=1，a2=1，a_{n+2}=a_{n+1}+a_n（n≥1）。<br>$$</p>
<p>PS: Markdown 中公式书写规则</p>
<ul>
<li><code>\\</code>符号后接的字符为上标</li>
<li><code>^</code>符号后接的字符为上标 </li>
<li><code>_</code>符号后接的字符为下标 </li>
<li>如果同时有两个下标，则需要使用<code>{}</code>来将符号括起来</li>
</ul>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fab</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++)&#123;</div><div class="line">            System.out.print(recursion(i) + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++)&#123;</div><div class="line">            System.out.print(loop(i) + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 递归</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> recursion(n -<span class="number">1</span>) + recursion(n -<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 循环</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">loop</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> s1 = <span class="number">1</span>,s2 = <span class="number">1</span>, sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n - <span class="number">2</span>; i ++)&#123;</div><div class="line">            sum = s1 + s2;</div><div class="line">            s1 = s2;</div><div class="line">            s2 = sum;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1 1 2 3 5 8 13 21 34 </div><div class="line">1 1 2 3 5 8 13 21 34 </div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure>
<p>值得注意的是（递归方法有栈溢出的风险）。</p>
<h2 id="参考文章-2"><a href="#参考文章-2" class="headerlink" title="参考文章"></a>参考文章</h2><h1 id="Question4—递归核心"><a href="#Question4—递归核心" class="headerlink" title="Question4—递归核心"></a>Question4—递归核心</h1><p>那么总结一下，递归算法的核心是什么呢？</p>
<p>那就是：</p>
<ul>
<li><strong><em><u>在有限次可预见性结果中，找到结果与上一次结果之间的关系。</u></em></strong></li>
<li>f(n)与f(n-1)的关系有时候很简单，如同走楼梯，状态单一；又有时如同细胞分裂，多种状态组合影响结果。</li>
<li>关键在于梳理清楚本次结果和上一次结果的关系有哪些方面或是因素，刚开始看的时候可能会很乱。</li>
<li>在草稿纸上写出前几次的结果，或者画图，这样更容易找到规律，这种规律实际上就是递归方程。</li>
<li><strong>*在算法的分析中，当一个算法中包含递归调用时，其时间复杂度的分析会转化成为一个递归方程的求解。而对递归方程的求解，方法多种多样，不一而足。</strong></li>
</ul>
<p>动态规划就是在递归的基础上，保存每一步的数据，避免重复计算。<br>在递归计算调用次数过多时，可以考虑更换其他方法解答。</p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;她给我提了一下几个问题，自己一眼看上去觉得简单，但是说不出来所以然，犯了眼高手低的毛病，记录自省。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;
    
    </summary>
    
      <category term="开发笔记" scheme="http://lincentma.men/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://lincentma.men/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Rank小记</title>
    <link href="http://lincentma.men/learn_rank.html"/>
    <id>http://lincentma.men/learn_rank.html</id>
    <published>2017-06-21T04:13:27.000Z</published>
    <updated>2017-06-22T03:16:46.299Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><pre><code>搜索引擎，你每天用的，知其然，不知其所以然。
                                        ——读《搜索引擎 : 信息检索实践》
</code></pre><h2 id="信息检索的定义"><a href="#信息检索的定义" class="headerlink" title="信息检索的定义"></a>信息检索的定义</h2><p>信息检索是关于信息的结构、分析、组织、存储、搜索和检索的领域——Gerard Salton</p>
<h2 id="搜索引擎的指标"><a href="#搜索引擎的指标" class="headerlink" title="搜索引擎的指标"></a>搜索引擎的指标</h2><p>处理数十亿网页的商业化网络搜索引擎时代的今天，搜索引擎的指标体现在以下五个方面：</p>
<ol>
<li>全</li>
<li>新</li>
<li>准</li>
<li>快</li>
<li>稳</li>
</ol>
<p>其中Rank的目标就是准</p>
<h2 id="Rank"><a href="#Rank" class="headerlink" title="Rank"></a>Rank</h2><p>如何所搜即所得是Rank的目的。</p>
<ul>
<li>海量网页快速排序</li>
<li>相关性：搜索结果与用户需求的匹配程度 </li>
</ul>
<ol>
<li>多样性（Query对应多个结果，通过用户行为数据进行选择和匹配）</li>
<li>权威性（被引用次数，链接分析。类似于学术文章的因子。）</li>
<li>时效性（Query的频次随时间的变化趋势）</li>
<li>个性化（构建用户个人数据，计算结果与用户喜好匹配程度）</li>
<li>用户成本</li>
</ol>
<h3 id="如何排序"><a href="#如何排序" class="headerlink" title="如何排序"></a>如何排序</h3><p>自己的理解，排序就是算分，按照分数来进行排序，key是算分。</p>
<blockquote>
<p>经典IR模型:TF-IDF是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。<br>距离特征</p>
<p>Boolean Model：布尔（Boolean）模型是基于集合论和布尔代数的一种简单检索模型。它的特点是查找那些于某个查询词返回为“真”的文档。在该模型中，一个查询词就是一个布尔表达式，包括关键词以及逻辑运算符。通过布尔表达式，可以表达用户希望文档所具有的特征。</p>
<p>Vetor-Space:VSM概念简单，把对文本内容的处理简化为向量空间中的向量运算，并且它以空间上的相似度表达语义的相似度，直观易懂。当文档被表示为文档空间的向量，就可以通过计算向量之间的相似性来度量文档间的相似性。文本处理中最常用的相似性度量方式是余弦距离</p>
</blockquote>
<h3 id="Rank关键技术"><a href="#Rank关键技术" class="headerlink" title="Rank关键技术"></a>Rank关键技术</h3><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>在线计算转为离线计算<br>分布式计算系统</p>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>辣鸡信息：找出特征，计算分数，剔除。</p>
<h4 id="人工识别与机器学习。"><a href="#人工识别与机器学习。" class="headerlink" title="人工识别与机器学习。"></a>人工识别与机器学习。</h4><p>Learning to Rank</p>
<p>找了一些文档博客，慢慢学习~</p>
<p>Point-Wise：RankSVM<br>Pair-Wise：RankNet<br>List-Wise：RankForest</p>
<p><em>努力学算法一定可以搞懂的！</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;pre&gt;&lt;code&gt;搜索引擎，你每天用的，知其然，不知其所以然。
                                        ——读《搜索引擎 : 信息检索实
    
    </summary>
    
      <category term="intern" scheme="http://lincentma.men/categories/intern/"/>
    
    
      <category term="rank" scheme="http://lincentma.men/tags/rank/"/>
    
  </entry>
  
  <entry>
    <title>为找工作而准备着</title>
    <link href="http://lincentma.men/prepare_for_work.html"/>
    <id>http://lincentma.men/prepare_for_work.html</id>
    <published>2017-06-17T08:57:30.000Z</published>
    <updated>2017-06-22T03:15:06.575Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="为找工作而准备着"><a href="#为找工作而准备着" class="headerlink" title="为找工作而准备着"></a>为找工作而准备着</h1><h2 id="行业了解"><a href="#行业了解" class="headerlink" title="行业了解"></a>行业了解</h2><p>互联网+行业——改变传统行业</p>
<p>未来的行业是属于数据驱动的行业：</p>
<ul>
<li>物流行业（快递物流数据），物流成本仍有巨大空间优化</li>
<li>金融行业（金融数据），普惠金融有广阔的空间</li>
<li>电商行业（交易数据），定制化，差异化，个性化会随着物质条件的不断提高而不断重要</li>
<li>视频行业（视频数据），视频对于文件具有更有效地传播</li>
<li>农业（作物，天气等数据），高品质农业作物的需求不断上升，小作坊式模式对于行情波动的适应性有巨大的改善空间</li>
<li>云（云数据），理论上任何公司的数据都可以上云来进行弹性管理，提高效率</li>
<li>新兴科技（新兴技术），探索无止境，更多广阔的市场是由新兴技术所开创</li>
</ul>
<h2 id="公司了解"><a href="#公司了解" class="headerlink" title="公司了解"></a>公司了解</h2><ul>
<li>物流行业：菜鸟物流</li>
<li>金融行业：蚂蚁金融、支付宝、微信支付</li>
<li>电商行业：阿里巴巴、京东、美团点评、网易严选考拉</li>
<li>视频行业：今日头条、腾讯视频、B站</li>
<li>农业：网易未央、京东、联想农业</li>
<li>云：阿里云、腾讯云</li>
<li>新兴科技：大疆科技</li>
</ul>
<h2 id="部门了解"><a href="#部门了解" class="headerlink" title="部门了解"></a>部门了解</h2><ul>
<li>技术营销：通过基础数据分析，找到赋能新方法</li>
<li>基础研发：如何让数据更加适合的展现</li>
<li>产品研发：如何研发用用户不易察觉的方式解决用户痛点的产品</li>
<li>内部研发：研发如何提高开发效率的工具</li>
</ul>
<h2 id="技术栈了解"><a href="#技术栈了解" class="headerlink" title="技术栈了解"></a>技术栈了解</h2><p><strong>Unix/Linux</strong></p>
<p>后端必须掌握的操作系统。<br>建议的书籍：《Linux编程》《Unix环境高级编程》</p>
<p><strong>网络编程</strong></p>
<p>建议书籍：《Unix网络编程》《TCP/IP协议详解》</p>
<p><strong>脚本语言</strong><br>PHP、Python深入学习。</p>
<p><strong>数据库</strong></p>
<p>无论是关系型数据库还是非关系型数据库，都是必须要吃透牢牢掌握的东西</p>
<h2 id="工作使命感"><a href="#工作使命感" class="headerlink" title="工作使命感"></a>工作使命感</h2><p>互联网的技术日新月异的目标就是让人们更加方面的获取一切，享受科技带来的便利；</p>
<p>不可否认互联网技术同样是一把双刃剑，人们在低成本享受的同时，同时也会出现键盘侠、恶意抹黑、舆论控制等让社会阴暗面放大的趋势。</p>
<p>如同微博让人们无所不谈，同时也会有水军，造谣；大疆无人机让我们获得前所未有的影像视角，同时也被用于装备军队送上战场。</p>
<p>在致力于互联网技术和产品不断发展的同时，同时还需要致力于让技术和产品如何正确地服务于人，而避免用于歧途。</p>
<p><em>数据亦然，发掘数据蕴含的价值创造正能量价值，尽所能。</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;为找工作而准备着&quot;&gt;&lt;a href=&quot;#为找工作而准备着&quot; class=&quot;headerlink&quot; title=&quot;为找工作而准备着&quot;&gt;&lt;/a&gt;为找工作而准备着&lt;/h1
    
    </summary>
    
      <category term="job" scheme="http://lincentma.men/categories/job/"/>
    
    
      <category term="job" scheme="http://lincentma.men/tags/job/"/>
    
  </entry>
  
  <entry>
    <title>在百度实习的日子</title>
    <link href="http://lincentma.men/internship_in_baidu.html"/>
    <id>http://lincentma.men/internship_in_baidu.html</id>
    <published>2017-06-17T08:57:10.000Z</published>
    <updated>2017-06-22T03:16:19.535Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="在百度实习的日子"><a href="#在百度实习的日子" class="headerlink" title="在百度实习的日子"></a>在百度实习的日子</h1><blockquote>
<p>转眼从百度离开回到了在学校的日子。也应该记录下自己在帝都，在百度的255天。</p>
</blockquote>
<h2 id="在百度糯米"><a href="#在百度糯米" class="headerlink" title="在百度糯米"></a>在百度糯米</h2><p>在百度糯米第一次接触了规范的开发流程，公司庞大的知识储备库，让自己如同海绵一样广泛吸水般吸收知识。有非常nice团队来让我迅速适应这样的开发环境，让我熟悉开发流程，带我一起和产品交流、和运营交流、和测试交流。</p>
<h2 id="在百度搜索"><a href="#在百度搜索" class="headerlink" title="在百度搜索"></a>在百度搜索</h2><p>在百度搜索我接触到了搜索是如何运转，自己尝试接触Sug的海量数据进行数据分析监控，第一次理解亲身理解大数据所蕴含的价值。<br>一次次的技术分享，让我更加深刻理解百度搜索里面的核心技术的深度，自己仍有很长的路要走。</p>
<h2 id="在百度"><a href="#在百度" class="headerlink" title="在百度"></a>在百度</h2><p>目前为止我见过最好的办公环境，nice的伙食，健身设备，班车交通，让我每个周末也来公司给自己充电。<br>每天的问好，晚上的坐上班车返回住所，每一天任务的完成带给自己的充实感让自己不断向前。<br>体验过996，体验过封闭开发，体验过部门内分享，体验过酸甜苦辣。<br>感谢百度，感谢曾经的同事，感谢让自己不断成长。</p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;在百度实习的日子&quot;&gt;&lt;a href=&quot;#在百度实习的日子&quot; class=&quot;headerlink&quot; title=&quot;在百度实习的日子&quot;&gt;&lt;/a&gt;在百度实习的日子&lt;/h1
    
    </summary>
    
      <category term="intern" scheme="http://lincentma.men/categories/intern/"/>
    
    
      <category term="intern" scheme="http://lincentma.men/tags/intern/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之重新初始化</title>
    <link href="http://lincentma.men/hexo_init.html"/>
    <id>http://lincentma.men/hexo_init.html</id>
    <published>2017-06-15T07:04:32.000Z</published>
    <updated>2017-06-25T18:25:43.666Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>站在巨人的肩膀上，搭建Hexo，事半功倍。但是巨人太多，选择好的巨人很重要，不然就不得其法，回到原点。</p>
<h2 id="Hexo参考文档"><a href="#Hexo参考文档" class="headerlink" title="Hexo参考文档"></a>Hexo参考文档</h2><ul>
<li>[NexT]:  <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">http://theme-next.iissnan.com/getting-started.html</a>    “NexT”</li>
<li>[NexT优化]:  <a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="external">http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html</a></li>
</ul>
<h2 id="Hexo搭建问题记录"><a href="#Hexo搭建问题记录" class="headerlink" title="Hexo搭建问题记录"></a>Hexo搭建问题记录</h2><ul>
<li>多说评论替换</li>
<li>背景效果</li>
<li>腾讯云搭建Hexo</li>
</ul>
<h2 id="Hexo-性能优化"><a href="#Hexo-性能优化" class="headerlink" title="Hexo 性能优化"></a>Hexo 性能优化</h2><ul>
<li>[hexo博客进阶－性能优化]:  <a href="https://www.liuxinggang.com/2016-12-06-hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%8D%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" target="_blank" rel="external">https://www.liuxinggang.com/2016-12-06-hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%8D%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</a></li>
</ul>
<p>自己更换电脑，没有保存Hexo的源文件，借此机会重新部署学习，完善自己的博客。</p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;站在巨人的肩膀上，搭建Hexo，事半功倍。但是巨人太多，选择好的巨人很重要，不然就不得其法，回到原点。&lt;/p&gt;
&lt;h2 id=&quot;Hexo参考文档&quot;&gt;&lt;a href=&quot;#Hex
    
    </summary>
    
      <category term="教程" scheme="http://lincentma.men/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="http://lincentma.men/tags/hexo/"/>
    
  </entry>
  
</feed>

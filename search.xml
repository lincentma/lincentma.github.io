<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java、Python与PHP的虚拟机异同]]></title>
    <url>%2Fprogram_language_virtual_machine.html</url>
    <content type="text"><![CDATA[Java、Python与PHP的虚拟机异同Java-JVM定义 JDK(Java Development Kit) 是 Java 语言的软件开发工具包（SDK）。JDK 物理存在，是 programming tools、JRE 和 JVM 的一个集合 JRE（Java Runtime Environment）Java 运行时环境，JRE 物理存在，主要由Java API 和 JVM 组成，提供了用于执行 java 应用程序最低要求的环境。 JVM(Java Virtual Machine) 是一种软件实现，执行像物理机程序的机器（即电脑）。JVM 通过执行 Java bytecode 可以使 java 代码在不改变的情况下运行在各种硬件之上。JVM是基于栈的。 JVM 执行 加载代码 验证代码 执行代码 提供运行环境 JVM 生命周期 启动：任何一个拥有main函数的class都可以作为JVM实例运行的起点 运行：main函数为起点，程序中的其他线程均有它启动，包括daemon守护线程和non-daemon普通线程。daemon是JVM自己使用的线程比如GC线程，main方法的初始线程是non-daemon。 消亡：所有线程终止时，JVM实例结束生命。 JVM结构及内存模型 名词解释： Class Loader：类加载器负责加载程序中的类型（类和接口），并赋予唯一的名字。为什么使用双亲委托模型——ClassLoader 隔离问题。 Execution Engine：执行引擎。执行引擎以指令为单位读取 Java 字节码。它就像一个 CPU 一样，一条一条地执行机器指令。 Runtime Data Areas:：运行时数据区。 PS：想起面试的时候被问到过这样的问题：你在使用java过程中是否遇到过OOM的情况？当时一阵懵比。现在总结下： PC寄存器（PC Register）是唯一一个在 Java 虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 JVM 栈（Java Virtual Machine Stack）：如果JVM Stack可以动态扩展，但是在尝试扩展时无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的虚拟机栈时抛出。 本地方法栈(Native method stack)：如果本地方法栈可以动态扩展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的本地方法栈，那Java虚拟机将会抛出一个OutOfMemoryError异常。 方法区(Method area)：如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。 运行时常量池(Runtime constant pool)：当创建类和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内存空间后就会抛出OutOfMemoryError 堆(Heap)：如果实际所需的堆超过了自动内存管理系统能提供的最大容量时抛出。 总结一下就是无法申请到足够的内存以及超出最大容量两方面原因 垃圾回收 新生代新生代由 Eden 与 Survivor Space（S0，S1）构成，大小通过-Xmn参数指定，Eden 与 Survivor Space 的内存大小比例默认为8:1，可以通过-XX:SurvivorRatio 参数指定，比如新生代为10M 时，Eden分配8M，S0和S1各分配1M。 Eden：希腊语，意思为伊甸园，在圣经中，伊甸园含有乐园的意思，根据《旧约·创世纪》记载，上帝耶和华照自己的形像造了第一个男人亚当，再用亚当的一个肋骨创造了一个女人夏娃，并安置他们住在了伊甸园。 大多数情况下，对象在Eden中分配，当Eden没有足够空间时，会触发一次Minor GC，虚拟机提供了-XX:+PrintGCDetails参数，告诉虚拟机在发生垃圾回收时打印内存回收日志。 Survivor：意思为幸存者，是新生代和老年代的缓冲区域。当新生代发生GC（Minor GC）时，会将存活的对象移动到S0内存区域，并清空Eden区域，当再次发生Minor GC时，将Eden和S0中存活的对象移动到S1内存区域。 存活对象会反复在S0和S1之间移动，当对象从Eden移动到Survivor或者在Survivor之间移动时，对象的GC年龄自动累加，当GC年龄超过默认阈值15时，会将该对象移动到老年代，可以通过参数-XX:MaxTenuringThreshold 对GC年龄的阈值进行设置。 老年代老年代的空间大小即-Xmx 与-Xmn 两个参数之差，用于存放经过几次Minor GC之后依旧存活的对象。当老年代的空间不足时，会触发Major GC/Full GC，速度一般比Minor GC慢10倍以上。 永久代在JDK8之前的HotSpot实现中，类的元数据如方法数据、方法信息（字节码，栈和变量大小）、运行时常量池、已确定的符号引用和虚方法表等被保存在永久代中，32位默认永久代的大小为64M，64位默认为85M，可以通过参数-XX:MaxPermSize进行设置，一旦类的元数据超过了永久代大小，就会抛出OOM异常。 虚拟机团队在JDK8的HotSpot中，把永久代从Java堆中移除了，并把类的元数据直接保存在本地内存区域（堆外内存），称之为元空间。 这样做有什么好处？有经验的同学会发现，对永久代的调优过程非常困难，永久代的大小很难确定，其中涉及到太多因素，如类的总数、常量池大小和方法数量等，而且永久代的数据可能会随着每一次Full GC而发生移动。 而在JDK8中，类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用内存空间，可以避免永久代的内存溢出问题，不过需要监控内存的消耗情况，一旦发生内存泄漏，会占用大量的本地内存。 判断垃圾回收 引用计数法：在对象上添加一个引用计数器，每当有一个对象引用它时，计数器加1，当使用完该对象时，计数器减1，计数器值为0的对象表示不可能再被使用。引用计数法实现简单，判定高效，但不能解决对象之间相互引用的问题。 可达性分析法：通过一系列称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，搜索路径称为 “引用链”，以下对象可作为GC Roots： 本地变量表中引用的对象 方法区中静态变量引用的对象 方法区中常量引用的对象 Native方法引用的对象 当一个对象到 GC Roots 没有任何引用链时，意味着该对象可以被回收。 垃圾回收算法 标记-清除算法对待回收的对象进行标记。算法缺点：效率问题，标记和清除过程效率都很低；空间问题，收集之后会产生大量的内存碎片，不利于大对象的分配。 复制算法复制算法将可用内存划分成大小相等的两块A和B，每次只使用其中一块，当A的内存用完了，就把存活的对象复制到B，并清空A的内存，不仅提高了标记的效率，因为只需要标记存活的对象，同时也避免了内存碎片的问题，代价是可用内存缩小为原来的一半。 标记-整理算法在老年代中，对象存活率较高，复制算法的效率很低。在标记-整理算法中，标记出所有存活的对象，并移动到一端，然后直接清理边界以外的内存。 参考文章 [清蒸 JVM （一）]: http://www.importnew.com/23658.html [Java GC的那些事（上）]: http://www.importnew.com/23633.html [Java GC的那些事（下）]: http://www.importnew.com/23640.html PythonPVMPVM是Python的运行引擎。他通常表现为python系统的一部分。并且他是实际运行脚本的组件。 编译器：将源码编译成运行在虚拟机上执行的opcode(pyc文件)，pyc文件是在python虚拟机上执行的一种跨平台字节码。 运行时：虚拟机解释器把opcode(pyc文件)解释成具体机器的机器码，执行。 JVM与PVM Java代码从源程序到执行，要经过的过程是：编译器(javac)把源代码转化为字节码，然后解释器（Java.exe）把字节码转换为计算机理解的机器码来执行。其中编译器和解释器都是Java虚拟机（JVM）的一部分，由于针对不同的硬件与OS，Java解释器有所不同，因此可以实现“一次编译、到处执行”。所以JVM是Java跨平台特性的关键所在。 对于Python，其源代码到执行也要经过如下过程：源代码—&gt;字节码—&gt;机器码。与Java不同的是，Python使用的虚拟机是基于其他语言实现的，比如我们一般使用的Python实际为Cpython，也就是其虚拟机由C实现，这个虚拟机负责把Python源码编译为字节码，再解释执行。另外，还有Jypython、Ironpython等。 PHP-Zend&amp;HHVM Zend引擎默认做法，是先编译为opcode，然后再逐条执行，通常每条指令对应的是C语言级别的函数。如果我们产生大量重复的opcode（纯PHP写的代码和函数），对应的则是Zend多次逐条执行这些C代码。 HHVM生成和执行PHP的中间字节码（HHVM生成自己格式的中间字节码），执行时通过JIT（Just In Time，即时编译是种软件优化技术，指在运行时才会去编译字节码为机器码）转为机器码执行。JIT将大量重复执行的字节码在运行的时候编译为机器码，达到提高执行效率的目的。通常，触发JIT的条件是代码或者函数被多次重复调用。 写在最后时间匆忙，囫囵吞枣，努力完善。 后端开发离不开Java，python和php，深入学习原理，比较异同，最佳使用。 2017.06.23]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>virtual machine</tag>
        <tag>python</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几个小问题的解答]]></title>
    <url>%2Flearn_for_some_questions.html</url>
    <content type="text"><![CDATA[她给我提了一下几个问题，自己一眼看上去觉得简单，但是说不出来所以然，犯了眼高手低的毛病，记录自省。 [x] 一共10级楼梯，每次可以走一步或两步，求一共多少种走法。 [x] 一个细胞，一个小时分裂一次，生命周期是3小时，求n小时后容器内，有多少细胞。 [x] 斐波那契数列的实现。 [x] 递归算法的核心 Question1—走楼梯思路楼梯问题，一眼看上去，应该是一个递归问题跑不了了。 那么该如何递归，找到其中的规律呢？ 逆向思考。 要想走到M(M=10)级,可以分为2种情况。 从m-2级迈两步 从m-1级迈一步 那么对于m-2和m-1的情况也是各自分为两种，以此类推。 那么走法的和就是m-2的走法和m-1的走法之和。 那么递归到最基本的（当前人在第0阶台阶） 第0阶台阶：0 第1阶台阶：1 第2阶台阶：2（1+1或者2） 得到公式，也就是斐波那契数列。$$f(n)=f(n-1)+f(n-2)$$ 代码1234567891011121314151617181920212223242526272829import java.util.Scanner;/** * Created by ml on 2017/6/21. */public class taijie &#123; public static int countNumber(int stepsNum) &#123; int sum = 0; if (stepsNum == 0) &#123; return 0; &#125; if (stepsNum == 1) &#123; return 1; &#125; else if (stepsNum == 2) &#123; return 2; &#125; else if (stepsNum &gt; 2) &#123; return countNumber(stepsNum - 2) + countNumber(stepsNum - 1); &#125; return sum; &#125; public static void main(String[] args) &#123; long startMili=System.currentTimeMillis(); for (int i = 0; i &lt;= 10; i++) &#123; System.out.println("楼梯台阶数:" + i + ", 走法有:" + countNumber(i)); &#125; long endMili=System.currentTimeMillis(); System.out.println("耗时:" + String.valueOf(endMili - startMili) + "毫秒"); &#125;&#125; 1234567891011121314楼梯台阶数:0, 走法有:0楼梯台阶数:1, 走法有:1楼梯台阶数:2, 走法有:2楼梯台阶数:3, 走法有:3楼梯台阶数:4, 走法有:5楼梯台阶数:5, 走法有:8楼梯台阶数:6, 走法有:13楼梯台阶数:7, 走法有:21楼梯台阶数:8, 走法有:34楼梯台阶数:9, 走法有:55楼梯台阶数:10, 走法有:89耗时:0毫秒Process finished with exit code 0 其他的方法该算法的运算时间是指数级增长的，还有其他方法吗？ 动态规划？ 其实动态规划（dynamicprogramming）是通过组合子问题而解决整个问题的解。乍一看和递归的写法差不多，都是相加。但是递归式是包含了许多重复计算的步骤，对应台阶就是每一个台阶计算前面都是重复的。动态规划算法对每个子问题只求解一次，将其结果保存起来，从而避免每次遇到各个子问题时重新计算答案。 代码如下： 1234567891011121314151617181920212223242526272829import java.util.Scanner;/** * Created by ml on 2017/6/21. */public class taijie &#123; public static int climbStairs(int n) &#123; if (n == 0 || n == 1 || n == 2) &#123; return n; &#125; //注意坐标起始点的区别 int[] r = new int[n+1]; r[1] = 1; r[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; r[i] = r[i-1] + r[i-2]; &#125; return r[n]; &#125; public static void main(String[] args) &#123; long startMili=System.currentTimeMillis(); for (int i = 0; i &lt;= 10; i++) &#123; System.out.println("楼梯台阶数:" + i + ", 走法有:" + climbStairs(i)); &#125; long endMili=System.currentTimeMillis(); System.out.println("耗时:" + String.valueOf(endMili - startMili) + "毫秒"); &#125;&#125; 1234567891011121314楼梯台阶数:0, 走法有:0楼梯台阶数:1, 走法有:1楼梯台阶数:2, 走法有:2楼梯台阶数:3, 走法有:3楼梯台阶数:4, 走法有:5楼梯台阶数:5, 走法有:8楼梯台阶数:6, 走法有:13楼梯台阶数:7, 走法有:21楼梯台阶数:8, 走法有:34楼梯台阶数:9, 走法有:55楼梯台阶数:10, 走法有:89耗时:0毫秒Process finished with exit code 0 之前数学课本上如何思考的？ 先求出走完台阶需要几步？ 再求出总步数中，走一个台阶是几步，走两个台阶式几步，不同种类为排列组合计算 类似问题再看一个硬币的凑法： 用1分、2分和5分的硬币凑成1元，共有多少种不同的凑法？（华为机试题） 它和走楼梯的区别在于，楼梯不同顺序是不同的走法，硬币则与顺序无关，程序可用穷举法。 123456789101112131415161718192021public class coin &#123; public static int getKinds()&#123; int num=0; for (int i = 0; i &lt; 21; i++) &#123; for (int j = 0; j &lt;= 100-5*i; j++) &#123; for (int k = 0; k &lt;= 100-5*i-2*j; k++) &#123; if(5*i+2*j+k==100)&#123; num++; &#125; &#125; &#125; &#125; return num; &#125; public static void main(String[] args) &#123; System.out.println(getKinds()); &#125;&#125; 那么这个问题可以推广为一般性问题吗？M阶，一次走a阶或者b阶或者。。。，求不同走法。 参考文章Question2—细胞分裂非递归思路乍一看，关键是如何处理生命周期是3小时。如何在分裂的同时提出死亡的细胞。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/** * Created by ml on 2017/6/22. * 思路：每个细胞定义为一维数组的元素，元素的值为细胞的生存时间，每分裂一次，在数组末尾添加新的元素，初始值为0，同时原来的元素值加1 * 当元素的值为3时，将该元素剔除 * 最后返回该数组的大小 */public class xibao &#123; public static int cellNum2(int n) &#123; ArrayList&lt;Integer&gt; cell = new ArrayList&lt;Integer&gt;(); //定义cellnum int cellnum = 0; //加入初始细胞 cell.add(0); for (int i = 0; i &lt; n; i++) &#123; //记录当前数组大小（剔除完成后的数组） int size = cell.size(); //计算分裂后新的数组的大小 cellnum = 2 * cell.size(); //原有生存时间加1 for (int j = 0; j &lt; cell.size(); j++) &#123; cell.set(j, cell.get(j) + 1); &#125; //遍历剔除元素值为3 PS：ArrayList中遍历可以删除的只有迭代器 Iterator&lt;Integer&gt; it = cell.iterator(); while (it.hasNext()) &#123; if (it.next().equals(3)) it.remove(); &#125; //在数组末尾添加新的元素 for (int j = size; j &lt; cellnum; j++) &#123; cell.add(0); &#125; &#125; return cell.size(); &#125; public static int cellNum(int n) &#123; HashMap&lt;Integer, Integer&gt; cell = new HashMap&lt;&gt;(); int cellnum = 1; for (int i = 1; i &lt;= n; i++) &#123; cellnum *= 2; int size = cell.size(); for (int j = size; j &lt; cellnum; j++) &#123; cell.put(j, 0); &#125; Iterator&lt;HashMap.Entry&lt;Integer, Integer&gt;&gt; iter = cell.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry = iter.next(); int key = (int) entry.getKey(); int val = (int) entry.getValue(); if (key &lt; size) &#123; cell.put(key, val + 1); &#125; &#125; &#125; return cell.size(); &#125; public static void main(String[] args) &#123; long startMili = System.currentTimeMillis(); int n = 6; System.out.println(n + "小时后容器细胞:" + cellNum2(n) + "个"); long endMili = System.currentTimeMillis(); System.out.println("耗时:" + String.valueOf(endMili - startMili) + "毫秒"); &#125;&#125; 12343小时后容器细胞:7个耗时:0毫秒Process finished with exit code 0 关于ArrayList 迭代器是作为当前集合的内部类实现的，当迭代器创建的时候保持了当前集合的引用； 集合内部维护一个字段叫modiCount，用来记录集合被修改的次数，比如add，remove，set等都会使该字段递增； 迭代器内部也维护着当前集合的修改次数的字段，迭代器创建时该字段初始化为集合的modiCount值 当每一次迭代时，迭代器会比较迭代器维护的字段和modiCount的值是否相等，如果不相等就抛ConcurrentModifiedException异常； 当然，如果用迭代器调用remove方法，那么集合和迭代器维护的修改字数都会递增，以保持两个状态的一致。 这就是为什么你只可以用迭代器来删除，而不能用其他方式来修改集合。 这类问题如何递归？公式法：$$n=t/a~~~~y=2^n$$但是这个只适用于最简单的没有任何附加状态条件的情况。 递归如何来分析？ 细胞的生存周期是3个小时，那我们就可以把细胞在题目中状态分为以下几个状态： a：刚分裂态——1 b：分裂1小时态——a分裂出b和a c：分裂2小时态——b分裂出c和a d：分裂3小时态——死亡（停止分裂） 那么，我们就可以根据细胞状态设定函数。分析每一个状态的来源是哪里即可。$$a(t)=a(t-1)+b(t-1)+c(t-1)\\b(t)=a(t-1)\\c(t)=b(t-1)\\d(t)=d(t-1)+c(t-1)$$容器中存活的细胞数目就是a、b、c三种状态数量的总和。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/** * Created by ml on 2017/6/22. */public class xibao &#123; public static int aStatus(int t) &#123; if (t == 0) &#123; return 1; &#125; return aStatus(t - 1) + bStatus(t - 1) + cStatus(t - 1); &#125; public static int bStatus(int t) &#123; if (t == 0) &#123; return 0; &#125; return aStatus(t-1); &#125; public static int cStatus(int t) &#123; if (t == 0) &#123; return 0; &#125; if (t == 1) &#123; return 0; &#125; return bStatus(t-1); &#125; public static int dStatus(int t) &#123; if (t == 0) &#123; return 0; &#125; if (t == 1) &#123; return 0; &#125; if (t == 2) &#123; return 0; &#125; return dStatus(t-1) + cStatus(t-1); &#125; public static void main(String[] args) &#123; long startMili = System.currentTimeMillis(); int n = 3; int res = aStatus(n) + bStatus(n) + cStatus(n); System.out.println(n + "小时后容器细胞:" + res + "个"); long endMili = System.currentTimeMillis(); System.out.println("耗时:" + String.valueOf(endMili - startMili) + "毫秒"); &#125;&#125; 12343小时后容器细胞:7个耗时:0毫秒Process finished with exit code 0 参考文章Question3—Fibonacci数列经典问题：求Fibonacci数列前n项。$${an}：a1=1，a2=1，a_{n+2}=a_{n+1}+a_n（n≥1）。$$ PS: Markdown 中公式书写规则 \\符号后接的字符为上标 ^符号后接的字符为上标 _符号后接的字符为下标 如果同时有两个下标，则需要使用{}来将符号括起来 代码1234567891011121314151617181920212223242526272829303132333435public class fab &#123; public static void main(String[] args) &#123; for(int i = 1; i &lt; 10; i ++)&#123; System.out.print(recursion(i) + " "); &#125; System.out.println(); for(int i = 1; i &lt; 10; i ++)&#123; System.out.print(loop(i) + " "); &#125; &#125; /** * 递归 */ public static int recursion(int n)&#123; if(n &lt;= 2)&#123; return 1; &#125; return recursion(n -1) + recursion(n -2); &#125; /** * 循环 */ public static int loop(int n)&#123; if(n &lt;= 2)&#123; return 1; &#125; int s1 = 1,s2 = 1, sum = 0; for(int i = 0 ; i &lt; n - 2; i ++)&#123; sum = s1 + s2; s1 = s2; s2 = sum; &#125; return sum; &#125;&#125; 1231 1 2 3 5 8 13 21 34 1 1 2 3 5 8 13 21 34 Process finished with exit code 0 值得注意的是（递归方法有栈溢出的风险）。 参考文章Question4—递归核心那么总结一下，递归算法的核心是什么呢？ 那就是： 在有限次可预见性结果中，找到结果与上一次结果之间的关系。 f(n)与f(n-1)的关系有时候很简单，如同走楼梯，状态单一；又有时如同细胞分裂，多种状态组合影响结果。 关键在于梳理清楚本次结果和上一次结果的关系有哪些方面或是因素，刚开始看的时候可能会很乱。 在草稿纸上写出前几次的结果，或者画图，这样更容易找到规律，这种规律实际上就是递归方程。 *在算法的分析中，当一个算法中包含递归调用时，其时间复杂度的分析会转化成为一个递归方程的求解。而对递归方程的求解，方法多种多样，不一而足。 动态规划就是在递归的基础上，保存每一步的数据，避免重复计算。在递归计算调用次数过多时，可以考虑更换其他方法解答。]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rank小记]]></title>
    <url>%2Flearn_rank.html</url>
    <content type="text"><![CDATA[搜索引擎，你每天用的，知其然，不知其所以然。 ——读《搜索引擎 : 信息检索实践》 信息检索的定义信息检索是关于信息的结构、分析、组织、存储、搜索和检索的领域——Gerard Salton 搜索引擎的指标处理数十亿网页的商业化网络搜索引擎时代的今天，搜索引擎的指标体现在以下五个方面： 全 新 准 快 稳 其中Rank的目标就是准 Rank如何所搜即所得是Rank的目的。 海量网页快速排序 相关性：搜索结果与用户需求的匹配程度 多样性（Query对应多个结果，通过用户行为数据进行选择和匹配） 权威性（被引用次数，链接分析。类似于学术文章的因子。） 时效性（Query的频次随时间的变化趋势） 个性化（构建用户个人数据，计算结果与用户喜好匹配程度） 用户成本 如何排序自己的理解，排序就是算分，按照分数来进行排序，key是算分。 经典IR模型:TF-IDF是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。距离特征 Boolean Model：布尔（Boolean）模型是基于集合论和布尔代数的一种简单检索模型。它的特点是查找那些于某个查询词返回为“真”的文档。在该模型中，一个查询词就是一个布尔表达式，包括关键词以及逻辑运算符。通过布尔表达式，可以表达用户希望文档所具有的特征。 Vetor-Space:VSM概念简单，把对文本内容的处理简化为向量空间中的向量运算，并且它以空间上的相似度表达语义的相似度，直观易懂。当文档被表示为文档空间的向量，就可以通过计算向量之间的相似性来度量文档间的相似性。文本处理中最常用的相似性度量方式是余弦距离 Rank关键技术倒排索引在线计算转为离线计算分布式计算系统 Cache辣鸡信息：找出特征，计算分数，剔除。 人工识别与机器学习。Learning to Rank 找了一些文档博客，慢慢学习~ Point-Wise：RankSVMPair-Wise：RankNetList-Wise：RankForest 努力学算法一定可以搞懂的！]]></content>
      <categories>
        <category>intern</category>
      </categories>
      <tags>
        <tag>rank</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为找工作而准备着]]></title>
    <url>%2Fprepare_for_work.html</url>
    <content type="text"><![CDATA[为找工作而准备着行业了解互联网+行业——改变传统行业 未来的行业是属于数据驱动的行业： 物流行业（快递物流数据），物流成本仍有巨大空间优化 金融行业（金融数据），普惠金融有广阔的空间 电商行业（交易数据），定制化，差异化，个性化会随着物质条件的不断提高而不断重要 视频行业（视频数据），视频对于文件具有更有效地传播 农业（作物，天气等数据），高品质农业作物的需求不断上升，小作坊式模式对于行情波动的适应性有巨大的改善空间 云（云数据），理论上任何公司的数据都可以上云来进行弹性管理，提高效率 新兴科技（新兴技术），探索无止境，更多广阔的市场是由新兴技术所开创 公司了解 物流行业：菜鸟物流 金融行业：蚂蚁金融、支付宝、微信支付 电商行业：阿里巴巴、京东、美团点评、网易严选考拉 视频行业：今日头条、腾讯视频、B站 农业：网易未央、京东、联想农业 云：阿里云、腾讯云 新兴科技：大疆科技 部门了解 技术营销：通过基础数据分析，找到赋能新方法 基础研发：如何让数据更加适合的展现 产品研发：如何研发用用户不易察觉的方式解决用户痛点的产品 内部研发：研发如何提高开发效率的工具 技术栈了解Unix/Linux 后端必须掌握的操作系统。建议的书籍：《Linux编程》《Unix环境高级编程》 网络编程 建议书籍：《Unix网络编程》《TCP/IP协议详解》 脚本语言PHP、Python深入学习。 数据库 无论是关系型数据库还是非关系型数据库，都是必须要吃透牢牢掌握的东西 工作使命感互联网的技术日新月异的目标就是让人们更加方面的获取一切，享受科技带来的便利； 不可否认互联网技术同样是一把双刃剑，人们在低成本享受的同时，同时也会出现键盘侠、恶意抹黑、舆论控制等让社会阴暗面放大的趋势。 如同微博让人们无所不谈，同时也会有水军，造谣；大疆无人机让我们获得前所未有的影像视角，同时也被用于装备军队送上战场。 在致力于互联网技术和产品不断发展的同时，同时还需要致力于让技术和产品如何正确地服务于人，而避免用于歧途。 数据亦然，发掘数据蕴含的价值创造正能量价值，尽所能。]]></content>
      <categories>
        <category>job</category>
      </categories>
      <tags>
        <tag>job</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在百度实习的日子]]></title>
    <url>%2Finternship_in_baidu.html</url>
    <content type="text"><![CDATA[在百度实习的日子 转眼从百度离开回到了在学校的日子。也应该记录下自己在帝都，在百度的255天。 在百度糯米在百度糯米第一次接触了规范的开发流程，公司庞大的知识储备库，让自己如同海绵一样广泛吸水般吸收知识。有非常nice团队来让我迅速适应这样的开发环境，让我熟悉开发流程，带我一起和产品交流、和运营交流、和测试交流。 在百度搜索在百度搜索我接触到了搜索是如何运转，自己尝试接触Sug的海量数据进行数据分析监控，第一次理解亲身理解大数据所蕴含的价值。一次次的技术分享，让我更加深刻理解百度搜索里面的核心技术的深度，自己仍有很长的路要走。 在百度目前为止我见过最好的办公环境，nice的伙食，健身设备，班车交通，让我每个周末也来公司给自己充电。每天的问好，晚上的坐上班车返回住所，每一天任务的完成带给自己的充实感让自己不断向前。体验过996，体验过封闭开发，体验过部门内分享，体验过酸甜苦辣。感谢百度，感谢曾经的同事，感谢让自己不断成长。]]></content>
      <categories>
        <category>intern</category>
      </categories>
      <tags>
        <tag>intern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之重新初始化]]></title>
    <url>%2Fhexo_init.html</url>
    <content type="text"><![CDATA[站在巨人的肩膀上，搭建Hexo，事半功倍。但是巨人太多，选择好的巨人很重要，不然就不得其法，回到原点。 Hexo参考文档 [NexT]: http://theme-next.iissnan.com/getting-started.html “NexT” [NexT优化]: http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html Hexo搭建问题记录 多说评论替换 背景效果 腾讯云搭建Hexo 自己更换电脑，没有保存Hexo的源文件，借此机会重新部署学习，完善自己的博客。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
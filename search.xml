<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[几个小问题的解答]]></title>
    <url>%2Flearn_for_some_questions.html</url>
    <content type="text"><![CDATA[她给我提了一下几个问题，自己一眼看上去觉得简单，但是说不出来所以然，犯了眼高手低的毛病，记录自省。 [x] 一共10级楼梯，每次可以走一步或两步，求一共多少种走法。 [x] 一个细胞，一个小时分裂一次，生命周期是3小时，求n小时后容器内，有多少细胞。 [x] 斐波那契数列的实现。 [x] 递归算法的核心 Question1—走楼梯思路楼梯问题，一眼看上去，应该是一个递归问题跑不了了。 那么该如何递归，找到其中的规律呢？ 逆向思考。 要想走到M(M=10)级,可以分为2种情况。 从m-2级迈两步 从m-1级迈一步 那么对于m-2和m-1的情况也是各自分为两种，以此类推。 那么走法的和就是m-2的走法和m-1的走法之和。 那么递归到最基本的（当前人在第0阶台阶） 第0阶台阶：0 第1阶台阶：1 第2阶台阶：2（1+1或者2） 得到公式，也就是斐波那契数列。$$f(n)=f(n-1)+f(n-2)$$ 代码1234567891011121314151617181920212223242526272829import java.util.Scanner;/** * Created by ml on 2017/6/21. */public class taijie &#123; public static int countNumber(int stepsNum) &#123; int sum = 0; if (stepsNum == 0) &#123; return 0; &#125; if (stepsNum == 1) &#123; return 1; &#125; else if (stepsNum == 2) &#123; return 2; &#125; else if (stepsNum &gt; 2) &#123; return countNumber(stepsNum - 2) + countNumber(stepsNum - 1); &#125; return sum; &#125; public static void main(String[] args) &#123; long startMili=System.currentTimeMillis(); for (int i = 0; i &lt;= 10; i++) &#123; System.out.println("楼梯台阶数:" + i + ", 走法有:" + countNumber(i)); &#125; long endMili=System.currentTimeMillis(); System.out.println("耗时:" + String.valueOf(endMili - startMili) + "毫秒"); &#125;&#125; 1234567891011121314楼梯台阶数:0, 走法有:0楼梯台阶数:1, 走法有:1楼梯台阶数:2, 走法有:2楼梯台阶数:3, 走法有:3楼梯台阶数:4, 走法有:5楼梯台阶数:5, 走法有:8楼梯台阶数:6, 走法有:13楼梯台阶数:7, 走法有:21楼梯台阶数:8, 走法有:34楼梯台阶数:9, 走法有:55楼梯台阶数:10, 走法有:89耗时:0毫秒Process finished with exit code 0 其他的方法该算法的运算时间是指数级增长的，还有其他方法吗？ 动态规划？ 其实动态规划（dynamicprogramming）是通过组合子问题而解决整个问题的解。乍一看和递归的写法差不多，都是相加。但是递归式是包含了许多重复计算的步骤，对应台阶就是每一个台阶计算前面都是重复的。动态规划算法对每个子问题只求解一次，将其结果保存起来，从而避免每次遇到各个子问题时重新计算答案。 代码如下： 1234567891011121314151617181920212223242526272829import java.util.Scanner;/** * Created by ml on 2017/6/21. */public class taijie &#123; public static int climbStairs(int n) &#123; if (n == 0 || n == 1 || n == 2) &#123; return n; &#125; //注意坐标起始点的区别 int[] r = new int[n+1]; r[1] = 1; r[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; r[i] = r[i-1] + r[i-2]; &#125; return r[n]; &#125; public static void main(String[] args) &#123; long startMili=System.currentTimeMillis(); for (int i = 0; i &lt;= 10; i++) &#123; System.out.println("楼梯台阶数:" + i + ", 走法有:" + climbStairs(i)); &#125; long endMili=System.currentTimeMillis(); System.out.println("耗时:" + String.valueOf(endMili - startMili) + "毫秒"); &#125;&#125; 1234567891011121314楼梯台阶数:0, 走法有:0楼梯台阶数:1, 走法有:1楼梯台阶数:2, 走法有:2楼梯台阶数:3, 走法有:3楼梯台阶数:4, 走法有:5楼梯台阶数:5, 走法有:8楼梯台阶数:6, 走法有:13楼梯台阶数:7, 走法有:21楼梯台阶数:8, 走法有:34楼梯台阶数:9, 走法有:55楼梯台阶数:10, 走法有:89耗时:0毫秒Process finished with exit code 0 之前数学课本上如何思考的？ 先求出走完台阶需要几步？ 再求出总步数中，走一个台阶是几步，走两个台阶式几步，不同种类为排列组合计算 类似问题再看一个硬币的凑法： 用1分、2分和5分的硬币凑成1元，共有多少种不同的凑法？（华为机试题） 它和走楼梯的区别在于，楼梯不同顺序是不同的走法，硬币则与顺序无关，程序可用穷举法。 123456789101112131415161718192021public class coin &#123; public static int getKinds()&#123; int num=0; for (int i = 0; i &lt; 21; i++) &#123; for (int j = 0; j &lt;= 100-5*i; j++) &#123; for (int k = 0; k &lt;= 100-5*i-2*j; k++) &#123; if(5*i+2*j+k==100)&#123; num++; &#125; &#125; &#125; &#125; return num; &#125; public static void main(String[] args) &#123; System.out.println(getKinds()); &#125;&#125; 那么这个问题可以推广为一般性问题吗？M阶，一次走a阶或者b阶或者。。。，求不同走法。 参考文章Question2—细胞分裂非递归思路乍一看，关键是如何处理生命周期是3小时。如何在分裂的同时提出死亡的细胞。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/** * Created by ml on 2017/6/22. * 思路：每个细胞定义为一维数组的元素，元素的值为细胞的生存时间，每分裂一次，在数组末尾添加新的元素，初始值为0，同时原来的元素值加1 * 当元素的值为3时，将该元素剔除 * 最后返回该数组的大小 */public class xibao &#123; public static int cellNum2(int n) &#123; ArrayList&lt;Integer&gt; cell = new ArrayList&lt;Integer&gt;(); //定义cellnum int cellnum = 0; //加入初始细胞 cell.add(0); for (int i = 0; i &lt; n; i++) &#123; //记录当前数组大小（剔除完成后的数组） int size = cell.size(); //计算分裂后新的数组的大小 cellnum = 2 * cell.size(); //原有生存时间加1 for (int j = 0; j &lt; cell.size(); j++) &#123; cell.set(j, cell.get(j) + 1); &#125; //遍历剔除元素值为3 PS：ArrayList中遍历可以删除的只有迭代器 Iterator&lt;Integer&gt; it = cell.iterator(); while (it.hasNext()) &#123; if (it.next().equals(3)) it.remove(); &#125; //在数组末尾添加新的元素 for (int j = size; j &lt; cellnum; j++) &#123; cell.add(0); &#125; &#125; return cell.size(); &#125; public static int cellNum(int n) &#123; HashMap&lt;Integer, Integer&gt; cell = new HashMap&lt;&gt;(); int cellnum = 1; for (int i = 1; i &lt;= n; i++) &#123; cellnum *= 2; int size = cell.size(); for (int j = size; j &lt; cellnum; j++) &#123; cell.put(j, 0); &#125; Iterator&lt;HashMap.Entry&lt;Integer, Integer&gt;&gt; iter = cell.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry = iter.next(); int key = (int) entry.getKey(); int val = (int) entry.getValue(); if (key &lt; size) &#123; cell.put(key, val + 1); &#125; &#125; &#125; return cell.size(); &#125; public static void main(String[] args) &#123; long startMili = System.currentTimeMillis(); int n = 6; System.out.println(n + "小时后容器细胞:" + cellNum2(n) + "个"); long endMili = System.currentTimeMillis(); System.out.println("耗时:" + String.valueOf(endMili - startMili) + "毫秒"); &#125;&#125; 12343小时后容器细胞:7个耗时:0毫秒Process finished with exit code 0 关于ArrayList 迭代器是作为当前集合的内部类实现的，当迭代器创建的时候保持了当前集合的引用； 集合内部维护一个字段叫modiCount，用来记录集合被修改的次数，比如add，remove，set等都会使该字段递增； 迭代器内部也维护着当前集合的修改次数的字段，迭代器创建时该字段初始化为集合的modiCount值 当每一次迭代时，迭代器会比较迭代器维护的字段和modiCount的值是否相等，如果不相等就抛ConcurrentModifiedException异常； 当然，如果用迭代器调用remove方法，那么集合和迭代器维护的修改字数都会递增，以保持两个状态的一致。 这就是为什么你只可以用迭代器来删除，而不能用其他方式来修改集合。 这类问题如何递归？公式法：$$n=t/a~~~~y=2^n$$但是这个只适用于最简单的没有任何附加状态条件的情况。 递归如何来分析？ 细胞的生存周期是3个小时，那我们就可以把细胞在题目中状态分为以下几个状态： a：刚分裂态——1 b：分裂1小时态——a分裂出b和a c：分裂2小时态——b分裂出c和a d：分裂3小时态——死亡（停止分裂） 那么，我们就可以根据细胞状态设定函数。分析每一个状态的来源是哪里即可。$$a(t)=a(t-1)+b(t-1)+c(t-1)\\b(t)=a(t-1)\\c(t)=b(t-1)\\d(t)=d(t-1)+c(t-1)$$容器中存活的细胞数目就是a、b、c三种状态数量的总和。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/** * Created by ml on 2017/6/22. */public class xibao &#123; public static int aStatus(int t) &#123; if (t == 0) &#123; return 1; &#125; return aStatus(t - 1) + bStatus(t - 1) + cStatus(t - 1); &#125; public static int bStatus(int t) &#123; if (t == 0) &#123; return 0; &#125; return aStatus(t-1); &#125; public static int cStatus(int t) &#123; if (t == 0) &#123; return 0; &#125; if (t == 1) &#123; return 0; &#125; return bStatus(t-1); &#125; public static int dStatus(int t) &#123; if (t == 0) &#123; return 0; &#125; if (t == 1) &#123; return 0; &#125; if (t == 2) &#123; return 0; &#125; return dStatus(t-1) + cStatus(t-1); &#125; public static void main(String[] args) &#123; long startMili = System.currentTimeMillis(); int n = 3; int res = aStatus(n) + bStatus(n) + cStatus(n); System.out.println(n + "小时后容器细胞:" + res + "个"); long endMili = System.currentTimeMillis(); System.out.println("耗时:" + String.valueOf(endMili - startMili) + "毫秒"); &#125;&#125; 12343小时后容器细胞:7个耗时:0毫秒Process finished with exit code 0 参考文章Question3—Fibonacci数列经典问题：求Fibonacci数列前n项。$${an}：a1=1，a2=1，a_{n+2}=a_{n+1}+a_n（n≥1）。$$ PS: Markdown 中公式书写规则 \\符号后接的字符为上标 ^符号后接的字符为上标 _符号后接的字符为下标 如果同时有两个下标，则需要使用{}来将符号括起来 代码1234567891011121314151617181920212223242526272829303132333435public class fab &#123; public static void main(String[] args) &#123; for(int i = 1; i &lt; 10; i ++)&#123; System.out.print(recursion(i) + " "); &#125; System.out.println(); for(int i = 1; i &lt; 10; i ++)&#123; System.out.print(loop(i) + " "); &#125; &#125; /** * 递归 */ public static int recursion(int n)&#123; if(n &lt;= 2)&#123; return 1; &#125; return recursion(n -1) + recursion(n -2); &#125; /** * 循环 */ public static int loop(int n)&#123; if(n &lt;= 2)&#123; return 1; &#125; int s1 = 1,s2 = 1, sum = 0; for(int i = 0 ; i &lt; n - 2; i ++)&#123; sum = s1 + s2; s1 = s2; s2 = sum; &#125; return sum; &#125;&#125; 1231 1 2 3 5 8 13 21 34 1 1 2 3 5 8 13 21 34 Process finished with exit code 0 值得注意的是（递归方法有栈溢出的风险）。 参考文章Question4—递归核心那么总结一下，递归算法的核心是什么呢？ 那就是： 在有限次可预见性结果中，找到结果与上一次结果之间的关系。 f(n)与f(n-1)的关系有时候很简单，如同走楼梯，状态单一；又有时如同细胞分裂，多种状态组合影响结果。 关键在于梳理清楚本次结果和上一次结果的关系有哪些方面或是因素，刚开始看的时候可能会很乱。 在草稿纸上写出前几次的结果，或者画图，这样更容易找到规律，这种规律实际上就是递归方程。 *在算法的分析中，当一个算法中包含递归调用时，其时间复杂度的分析会转化成为一个递归方程的求解。而对递归方程的求解，方法多种多样，不一而足。 动态规划就是在递归的基础上，保存每一步的数据，避免重复计算。在递归计算调用次数过多时，可以考虑更换其他方法解答。]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rank小记]]></title>
    <url>%2Flearn_rank.html</url>
    <content type="text"><![CDATA[搜索引擎，你每天用的，知其然，不知其所以然。 ——读《搜索引擎 : 信息检索实践》 信息检索的定义信息检索是关于信息的结构、分析、组织、存储、搜索和检索的领域——Gerard Salton 搜索引擎的指标处理数十亿网页的商业化网络搜索引擎时代的今天，搜索引擎的指标体现在以下五个方面： 全 新 准 快 稳 其中Rank的目标就是准 Rank如何所搜即所得是Rank的目的。 海量网页快速排序 相关性：搜索结果与用户需求的匹配程度 多样性（Query对应多个结果，通过用户行为数据进行选择和匹配） 权威性（被引用次数，链接分析。类似于学术文章的因子。） 时效性（Query的频次随时间的变化趋势） 个性化（构建用户个人数据，计算结果与用户喜好匹配程度） 用户成本 如何排序自己的理解，排序就是算分，按照分数来进行排序，key是算分。 经典IR模型:TF-IDF是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。距离特征 Boolean Model：布尔（Boolean）模型是基于集合论和布尔代数的一种简单检索模型。它的特点是查找那些于某个查询词返回为“真”的文档。在该模型中，一个查询词就是一个布尔表达式，包括关键词以及逻辑运算符。通过布尔表达式，可以表达用户希望文档所具有的特征。 Vetor-Space:VSM概念简单，把对文本内容的处理简化为向量空间中的向量运算，并且它以空间上的相似度表达语义的相似度，直观易懂。当文档被表示为文档空间的向量，就可以通过计算向量之间的相似性来度量文档间的相似性。文本处理中最常用的相似性度量方式是余弦距离 Rank关键技术倒排索引在线计算转为离线计算分布式计算系统 Cache辣鸡信息：找出特征，计算分数，剔除。 人工识别与机器学习。Learning to Rank 找了一些文档博客，慢慢学习~ Point-Wise：RankSVMPair-Wise：RankNetList-Wise：RankForest 努力学算法一定可以搞懂的！]]></content>
      <categories>
        <category>intern</category>
      </categories>
      <tags>
        <tag>rank</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为找工作而准备着]]></title>
    <url>%2Fprepare_for_work.html</url>
    <content type="text"><![CDATA[为找工作而准备着行业了解互联网+行业——改变传统行业 未来的行业是属于数据驱动的行业： 物流行业（快递物流数据），物流成本仍有巨大空间优化 金融行业（金融数据），普惠金融有广阔的空间 电商行业（交易数据），定制化，差异化，个性化会随着物质条件的不断提高而不断重要 视频行业（视频数据），视频对于文件具有更有效地传播 农业（作物，天气等数据），高品质农业作物的需求不断上升，小作坊式模式对于行情波动的适应性有巨大的改善空间 云（云数据），理论上任何公司的数据都可以上云来进行弹性管理，提高效率 新兴科技（新兴技术），探索无止境，更多广阔的市场是由新兴技术所开创 公司了解 物流行业：菜鸟物流 金融行业：蚂蚁金融、支付宝、微信支付 电商行业：阿里巴巴、京东、美团点评、网易严选考拉 视频行业：今日头条、腾讯视频、B站 农业：网易未央、京东、联想农业 云：阿里云、腾讯云 新兴科技：大疆科技 部门了解 技术营销：通过基础数据分析，找到赋能新方法 基础研发：如何让数据更加适合的展现 产品研发：如何研发用用户不易察觉的方式解决用户痛点的产品 内部研发：研发如何提高开发效率的工具 技术栈了解Unix/Linux 后端必须掌握的操作系统。建议的书籍：《Linux编程》《Unix环境高级编程》 网络编程 建议书籍：《Unix网络编程》《TCP/IP协议详解》 脚本语言PHP、Python深入学习。 数据库 无论是关系型数据库还是非关系型数据库，都是必须要吃透牢牢掌握的东西 工作使命感互联网的技术日新月异的目标就是让人们更加方面的获取一切，享受科技带来的便利； 不可否认互联网技术同样是一把双刃剑，人们在低成本享受的同时，同时也会出现键盘侠、恶意抹黑、舆论控制等让社会阴暗面放大的趋势。 如同微博让人们无所不谈，同时也会有水军，造谣；大疆无人机让我们获得前所未有的影像视角，同时也被用于装备军队送上战场。 在致力于互联网技术和产品不断发展的同时，同时还需要致力于让技术和产品如何正确地服务于人，而避免用于歧途。 数据亦然，发掘数据蕴含的价值创造正能量价值，尽所能。]]></content>
      <categories>
        <category>job</category>
      </categories>
      <tags>
        <tag>job</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在百度实习的日子]]></title>
    <url>%2Finternship_in_baidu.html</url>
    <content type="text"><![CDATA[在百度实习的日子 转眼从百度离开回到了在学校的日子。也应该记录下自己在帝都，在百度的255天。 在百度糯米在百度糯米第一次接触了规范的开发流程，公司庞大的知识储备库，让自己如同海绵一样广泛吸水般吸收知识。有非常nice团队来让我迅速适应这样的开发环境，让我熟悉开发流程，带我一起和产品交流、和运营交流、和测试交流。 在百度搜索在百度搜索我接触到了搜索是如何运转，自己尝试接触Sug的海量数据进行数据分析监控，第一次理解亲身理解大数据所蕴含的价值。一次次的技术分享，让我更加深刻理解百度搜索里面的核心技术的深度，自己仍有很长的路要走。 在百度目前为止我见过最好的办公环境，nice的伙食，健身设备，班车交通，让我每个周末也来公司给自己充电。每天的问好，晚上的坐上班车返回住所，每一天任务的完成带给自己的充实感让自己不断向前。体验过996，体验过封闭开发，体验过部门内分享，体验过酸甜苦辣。感谢百度，感谢曾经的同事，感谢让自己不断成长。]]></content>
      <categories>
        <category>intern</category>
      </categories>
      <tags>
        <tag>intern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之重新初始化]]></title>
    <url>%2Fhexo_init.html</url>
    <content type="text"><![CDATA[站在巨人的肩膀上，搭建Hexo，事半功倍。但是巨人太多，选择好的巨人很重要，不然就不得其法，回到原点。 Hexo参考文档 [NexT]: http://theme-next.iissnan.com/getting-started.html “NexT” [NexT优化]: http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html Hexo搭建问题记录 多说评论替换 背景效果 腾讯云搭建Hexo 自己更换电脑，没有保存Hexo的源文件，借此机会重新部署学习，完善自己的博客。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>